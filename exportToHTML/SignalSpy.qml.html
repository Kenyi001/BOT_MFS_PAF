<html>
<head>
<title>SignalSpy.qml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #bcbec4;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
SignalSpy.qml</font>
</center></td></tr></table>
<pre><span class="s0">/****************************************************************************</span>
<span class="s0">**</span>
<span class="s0">** Copyright (C) 2016 The Qt Company Ltd.</span>
<span class="s0">** Contact: https://www.qt.io/licensing/</span>
<span class="s0">**</span>
<span class="s0">** This file is part of the test suite of the Qt Toolkit.</span>
<span class="s0">**</span>
<span class="s0">** $QT_BEGIN_LICENSE:LGPL$</span>
<span class="s0">** Commercial License Usage</span>
<span class="s0">** Licensees holding valid commercial Qt licenses may use this file in</span>
<span class="s0">** accordance with the commercial license agreement provided with the</span>
<span class="s0">** Software or, alternatively, in accordance with the terms contained in</span>
<span class="s0">** a written agreement between you and The Qt Company. For licensing terms</span>
<span class="s0">** and conditions see https://www.qt.io/terms-conditions. For further</span>
<span class="s0">** information use the contact form at https://www.qt.io/contact-us.</span>
<span class="s0">**</span>
<span class="s0">** GNU Lesser General Public License Usage</span>
<span class="s0">** Alternatively, this file may be used under the terms of the GNU Lesser</span>
<span class="s0">** General Public License version 3 as published by the Free Software</span>
<span class="s0">** Foundation and appearing in the file LICENSE.LGPL3 included in the</span>
<span class="s0">** packaging of this file. Please review the following information to</span>
<span class="s0">** ensure the GNU Lesser General Public License version 3 requirements</span>
<span class="s0">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</span>
<span class="s0">**</span>
<span class="s0">** GNU General Public License Usage</span>
<span class="s0">** Alternatively, this file may be used under the terms of the GNU</span>
<span class="s0">** General Public License version 2.0 or (at your option) the GNU General</span>
<span class="s0">** Public license version 3 or any later version approved by the KDE Free</span>
<span class="s0">** Qt Foundation. The licenses are as published by the Free Software</span>
<span class="s0">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</span>
<span class="s0">** included in the packaging of this file. Please review the following</span>
<span class="s0">** information to ensure the GNU General Public License requirements will</span>
<span class="s0">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</span>
<span class="s0">** https://www.gnu.org/licenses/gpl-3.0.html.</span>
<span class="s0">**</span>
<span class="s0">** $QT_END_LICENSE$</span>
<span class="s0">**</span>
<span class="s0">****************************************************************************/</span>

<span class="s2">import </span><span class="s1">QtQuick </span><span class="s3">2.0</span>
<span class="s2">import </span><span class="s1">QtTest </span><span class="s3">1.1</span>

<span class="s4">/*! 
    \qmltype SignalSpy 
    \inqmlmodule QtTest 
    \brief Enables introspection of signal emission. 
    \since 4.8 
    \ingroup qtquicktest 
 
    In the following example, a SignalSpy is installed to watch the 
    &quot;clicked&quot; signal on a user-defined Button type.  When the signal 
    is emitted, the \l count property on the spy will be increased. 
 
    \code 
    Button { 
        id: button 
        SignalSpy { 
            id: spy 
            target: button 
            signalName: &quot;clicked&quot; 
        } 
        TestCase { 
            name: &quot;ButtonClick&quot; 
            function test_click() { 
                compare(spy.count, 0) 
                button.clicked(); 
                compare(spy.count, 1) 
            } 
        } 
    } 
    \endcode 
 
    The above style of test is suitable for signals that are emitted 
    synchronously.  For asynchronous signals, the wait() method can be 
    used to block the test until the signal occurs (or a timeout expires). 
 
    \sa {QtTest::TestCase}{TestCase}, {Qt Quick Test} 
*/</span>

<span class="s1">Item </span><span class="s5">{</span>
    <span class="s1">id</span><span class="s5">: </span><span class="s1">spy</span>
    <span class="s1">visible</span><span class="s5">: </span><span class="s2">false</span>

    <span class="s1">TestUtil </span><span class="s5">{</span>
        <span class="s1">id</span><span class="s5">: </span><span class="s1">util</span>
    <span class="s5">}</span>
    <span class="s4">// Public API.</span>
    <span class="s4">/*! 
        \qmlproperty object SignalSpy::target 
 
        This property defines the target object that will be used to 
        listen for emissions of the \l signalName signal. 
 
        \sa signalName, count 
    */</span>
    <span class="s1">property </span><span class="s2">var </span><span class="s1">target</span><span class="s5">: </span><span class="s2">null</span>
    <span class="s4">/*! 
        \qmlproperty string SignalSpy::signalName 
 
        This property defines the name of the signal on \l target to 
        listen for. 
 
        \sa target, count 
    */</span>
    <span class="s1">property string signalName</span><span class="s5">: </span><span class="s6">&quot;&quot;</span>
    <span class="s4">/*! 
        \qmlproperty int SignalSpy::count 
 
        This property defines the number of times that \l signalName has 
        been emitted from \l target since the last call to clear(). 
 
        \sa target, signalName, clear() 
        \readonly 
    */</span>
    <span class="s1">readonly property alias count</span><span class="s5">: </span><span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_count</span>
    <span class="s4">/*! 
        \qmlproperty bool SignalSpy::valid 
 
        This property defines the current signal connection status. It will be true when the \l signalName of the \l target is connected successfully, otherwise it will be false. 
 
        \sa count, target, signalName, clear() 
        \readonly 
    */</span>
    <span class="s1">readonly property alias valid</span><span class="s5">:</span><span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_valid</span>
    <span class="s4">/*! 
        \qmlproperty list SignalSpy::signalArguments 
 
        This property holds a list of emitted signal arguments. Each emission of the signal will append one item to the list, containing the arguments of the signal. 
        When connecting to a new \l target or new \l signalName or calling the \l clear() method, the \l signalArguments will be reset to empty. 
 
        \sa signalName, clear() 
        \readonly 
    */</span>
    <span class="s1">readonly property alias signalArguments</span><span class="s5">:</span><span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_signalArguments</span>

    <span class="s4">/*! 
        \qmlmethod SignalSpy::clear() 
 
        Clears \l count to 0, resets \l valid to false and clears the \l signalArguments to empty. 
 
        \sa count, wait() 
    */</span>
    <span class="s2">function </span><span class="s1">clear</span><span class="s5">() {</span>
        <span class="s1">qtest_count </span><span class="s5">= </span><span class="s3">0</span>
        <span class="s1">qtest_expectedCount </span><span class="s5">= </span><span class="s3">0</span>
        <span class="s1">qtest_signalArguments </span><span class="s5">= []</span>
    <span class="s5">}</span>

    <span class="s4">/*! 
        \qmlmethod SignalSpy::wait(timeout = 5000) 
 
        Waits for the signal \l signalName on \l target to be emitted, 
        for up to \a timeout milliseconds.  The test case will fail if 
        the signal is not emitted. 
 
        \code 
        SignalSpy { 
            id: spy 
            target: button 
            signalName: &quot;clicked&quot; 
        } 
 
        function test_async_click() { 
            ... 
            // do something that will cause clicked() to be emitted 
            ... 
            spy.wait() 
            compare(spy.count, 1) 
        } 
        \endcode 
 
        There are two possible scenarios: the signal has already been 
        emitted when wait() is called, or the signal has not yet been 
        emitted.  The wait() function handles the first scenario by immediately 
        returning if the signal has already occurred. 
 
        The clear() method can be used to discard information about signals 
        that have already occurred to synchronize wait() with future signal 
        emissions. 
 
        \sa clear(), TestCase::tryCompare() 
    */</span>
    <span class="s2">function </span><span class="s1">wait</span><span class="s5">(</span><span class="s1">timeout</span><span class="s5">) {</span>
        <span class="s2">if </span><span class="s5">(</span><span class="s1">timeout </span><span class="s5">=== </span><span class="s1">undefined</span><span class="s5">)</span>
            <span class="s1">timeout </span><span class="s5">= </span><span class="s3">5000</span>
        <span class="s2">var </span><span class="s1">expected </span><span class="s5">= ++</span><span class="s1">qtest_expectedCount</span>
        <span class="s2">var </span><span class="s1">i </span><span class="s5">= </span><span class="s3">0</span>
        <span class="s2">while </span><span class="s5">(</span><span class="s1">i </span><span class="s5">&lt; </span><span class="s1">timeout </span><span class="s5">&amp;&amp; </span><span class="s1">qtest_count </span><span class="s5">&lt; </span><span class="s1">expected</span><span class="s5">) {</span>
            <span class="s1">qtest_results</span><span class="s5">.</span><span class="s1">wait</span><span class="s5">(</span><span class="s3">50</span><span class="s5">)</span>
            <span class="s1">i </span><span class="s5">+= </span><span class="s3">50</span>
        <span class="s5">}</span>
        <span class="s2">var </span><span class="s1">success </span><span class="s5">= (</span><span class="s1">qtest_count </span><span class="s5">&gt;= </span><span class="s1">expected</span><span class="s5">)</span>
        <span class="s2">if </span><span class="s5">(!</span><span class="s1">qtest_results</span><span class="s5">.</span><span class="s1">verify</span><span class="s5">(</span><span class="s1">success</span><span class="s5">, </span><span class="s6">&quot;wait for signal &quot; </span><span class="s5">+ </span><span class="s1">signalName</span><span class="s5">, </span><span class="s1">util</span><span class="s5">.</span><span class="s1">callerFile</span><span class="s5">(), </span><span class="s1">util</span><span class="s5">.</span><span class="s1">callerLine</span><span class="s5">()))</span>
            <span class="s2">throw new </span><span class="s1">Error</span><span class="s5">(</span><span class="s6">&quot;QtQuickTest::fail&quot;</span><span class="s5">)</span>
    <span class="s5">}</span>

    <span class="s4">// Internal implementation detail follows.</span>

    <span class="s1">TestResult </span><span class="s5">{ </span><span class="s1">id</span><span class="s5">: </span><span class="s1">qtest_results </span><span class="s5">}</span>

    <span class="s1">onTargetChanged</span><span class="s5">: {</span>
        <span class="s1">qtest_update</span><span class="s5">()</span>
    <span class="s5">}</span>
    <span class="s1">onSignalNameChanged</span><span class="s5">: {</span>
        <span class="s1">qtest_update</span><span class="s5">()</span>
    <span class="s5">}</span>

    <span class="s4">/*! \internal */</span>
    <span class="s1">property </span><span class="s2">var </span><span class="s1">qtest_prevTarget</span><span class="s5">: </span><span class="s2">null</span>
    <span class="s4">/*! \internal */</span>
    <span class="s1">property string qtest_prevSignalName</span><span class="s5">: </span><span class="s6">&quot;&quot;</span>
    <span class="s4">/*! \internal */</span>
    <span class="s1">property int qtest_expectedCount</span><span class="s5">: </span><span class="s3">0</span>
    <span class="s4">/*! \internal */</span>
    <span class="s1">property </span><span class="s2">var </span><span class="s1">qtest_signalArguments</span><span class="s5">:[]</span>
    <span class="s4">/*! \internal */</span>
    <span class="s1">property int qtest_count</span><span class="s5">: </span><span class="s3">0</span>
    <span class="s4">/*! \internal */</span>
    <span class="s1">property bool qtest_valid</span><span class="s5">:</span><span class="s2">false</span>
    <span class="s4">/*! \internal */</span>

    <span class="s4">/*! \internal */</span>
    <span class="s2">function </span><span class="s1">qtest_update</span><span class="s5">() {</span>
        <span class="s2">if </span><span class="s5">(</span><span class="s1">qtest_prevTarget </span><span class="s5">!= </span><span class="s2">null</span><span class="s5">) {</span>
            <span class="s2">var </span><span class="s1">prevHandlerName </span><span class="s5">= </span><span class="s1">qtest_signalHandlerName</span><span class="s5">(</span><span class="s1">qtest_prevSignalName</span><span class="s5">)</span>
            <span class="s2">var </span><span class="s1">prevFunc </span><span class="s5">= </span><span class="s1">qtest_prevTarget</span><span class="s5">[</span><span class="s1">prevHandlerName</span><span class="s5">]</span>
            <span class="s2">if </span><span class="s5">(</span><span class="s1">prevFunc</span><span class="s5">)</span>
                <span class="s1">prevFunc</span><span class="s5">.</span><span class="s1">disconnect</span><span class="s5">(</span><span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_activated</span><span class="s5">)</span>
            <span class="s1">qtest_prevTarget </span><span class="s5">= </span><span class="s2">null</span>
            <span class="s1">qtest_prevSignalName </span><span class="s5">= </span><span class="s6">&quot;&quot;</span>
        <span class="s5">}</span>
        <span class="s2">if </span><span class="s5">(</span><span class="s1">target </span><span class="s5">!= </span><span class="s2">null </span><span class="s5">&amp;&amp; </span><span class="s1">signalName </span><span class="s5">!= </span><span class="s6">&quot;&quot;</span><span class="s5">) {</span>
            <span class="s4">// Look for the signal name in the object</span>
            <span class="s2">var </span><span class="s1">func </span><span class="s5">= </span><span class="s1">target</span><span class="s5">[</span><span class="s1">signalName</span><span class="s5">]</span>
            <span class="s2">if </span><span class="s5">(</span><span class="s2">typeof </span><span class="s1">func </span><span class="s5">!== </span><span class="s6">&quot;function&quot;</span><span class="s5">) {</span>
                <span class="s4">// If it is not a function, try looking for signal handler</span>
                <span class="s4">// i.e. (onSignal) this is needed for cases where there is a property</span>
                <span class="s4">// and a signal with the same name, e.g. Mousearea.pressed</span>
                <span class="s1">func </span><span class="s5">= </span><span class="s1">target</span><span class="s5">[</span><span class="s1">qtest_signalHandlerName</span><span class="s5">(</span><span class="s1">signalName</span><span class="s5">)]</span>
            <span class="s5">}</span>
            <span class="s2">if </span><span class="s5">(</span><span class="s1">func </span><span class="s5">=== </span><span class="s1">undefined</span><span class="s5">) {</span>
                <span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_valid </span><span class="s5">= </span><span class="s2">false</span>
                <span class="s1">console</span><span class="s5">.</span><span class="s1">log</span><span class="s5">(</span><span class="s6">&quot;Signal '&quot; </span><span class="s5">+ </span><span class="s1">signalName </span><span class="s5">+ </span><span class="s6">&quot;' not found&quot;</span><span class="s5">)</span>
            <span class="s5">} </span><span class="s2">else </span><span class="s5">{</span>
                <span class="s1">qtest_prevTarget </span><span class="s5">= </span><span class="s1">target</span>
                <span class="s1">qtest_prevSignalName </span><span class="s5">= </span><span class="s1">signalName</span>
                <span class="s1">func</span><span class="s5">.</span><span class="s1">connect</span><span class="s5">(</span><span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_activated</span><span class="s5">)</span>
                <span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_valid </span><span class="s5">= </span><span class="s2">true</span>
                <span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_signalArguments </span><span class="s5">= []</span>
            <span class="s5">}</span>
        <span class="s5">} </span><span class="s2">else </span><span class="s5">{</span>
            <span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_valid </span><span class="s5">= </span><span class="s2">false</span>
        <span class="s5">}</span>
    <span class="s5">}</span>

    <span class="s4">/*! \internal */</span>
    <span class="s2">function </span><span class="s1">qtest_activated</span><span class="s5">() {</span>
        <span class="s5">++</span><span class="s1">qtest_count</span>
        <span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_signalArguments</span><span class="s5">[</span><span class="s1">spy</span><span class="s5">.</span><span class="s1">qtest_signalArguments</span><span class="s5">.</span><span class="s1">length</span><span class="s5">] = </span><span class="s1">arguments</span>
    <span class="s5">}</span>

    <span class="s4">/*! \internal */</span>
    <span class="s2">function </span><span class="s1">qtest_signalHandlerName</span><span class="s5">(</span><span class="s1">sn</span><span class="s5">) {</span>
        <span class="s2">if </span><span class="s5">(</span><span class="s1">sn</span><span class="s5">.</span><span class="s1">substr</span><span class="s5">(</span><span class="s3">0</span><span class="s5">, </span><span class="s3">2</span><span class="s5">) === </span><span class="s6">&quot;on&quot; </span><span class="s5">&amp;&amp; </span><span class="s1">sn</span><span class="s5">[</span><span class="s3">2</span><span class="s5">] === </span><span class="s1">sn</span><span class="s5">[</span><span class="s3">2</span><span class="s5">].</span><span class="s1">toUpperCase</span><span class="s5">())</span>
            <span class="s2">return </span><span class="s1">sn</span>
        <span class="s2">return </span><span class="s6">&quot;on&quot; </span><span class="s5">+ </span><span class="s1">sn</span><span class="s5">.</span><span class="s1">substr</span><span class="s5">(</span><span class="s3">0</span><span class="s5">, </span><span class="s3">1</span><span class="s5">).</span><span class="s1">toUpperCase</span><span class="s5">() + </span><span class="s1">sn</span><span class="s5">.</span><span class="s1">substr</span><span class="s5">(</span><span class="s3">1</span><span class="s5">)</span>
    <span class="s5">}</span>
<span class="s5">}</span>
</pre>
</body>
</html>