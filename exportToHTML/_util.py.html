<html>
<head>
<title>_util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_util.py</font>
</center></td></tr></table>
<pre><span class="s0"># Little utilities we use internally</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">signal</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">ABCMeta</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">update_wrapper</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">AsyncGeneratorType</span><span class="s3">, </span><span class="s1">TracebackType</span>

<span class="s2">from </span><span class="s1">sniffio </span><span class="s2">import </span><span class="s1">thread_local </span><span class="s2">as </span><span class="s1">sniffio_loop</span>

<span class="s2">import </span><span class="s1">trio</span>

<span class="s1">CallT </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;CallT&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">])</span>
<span class="s1">T </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;T&quot;</span><span class="s3">)</span>
<span class="s1">RetT </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;RetT&quot;</span><span class="s3">)</span>

<span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">ParamSpec</span><span class="s3">, </span><span class="s1">Self</span>

    <span class="s1">ArgsT </span><span class="s3">= </span><span class="s1">ParamSpec</span><span class="s3">(</span><span class="s4">&quot;ArgsT&quot;</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s0"># Don't type check the implementation below, pthread_kill does not exist on Windows.</span>
    <span class="s2">def </span><span class="s1">signal_raise</span><span class="s3">(</span><span class="s1">signum</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>


<span class="s0"># Equivalent to the C function raise(), which Python doesn't wrap</span>
<span class="s2">elif </span><span class="s1">os</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;nt&quot;</span><span class="s3">:</span>
    <span class="s0"># On Windows, os.kill exists but is really weird.</span>
    <span class="s0">#</span>
    <span class="s0"># If you give it CTRL_C_EVENT or CTRL_BREAK_EVENT, it tries to deliver</span>
    <span class="s0"># those using GenerateConsoleCtrlEvent. But I found that when I tried</span>
    <span class="s0"># to run my test normally, it would freeze waiting... unless I added</span>
    <span class="s0"># print statements, in which case the test suddenly worked. So I guess</span>
    <span class="s0"># these signals are only delivered if/when you access the console? I</span>
    <span class="s0"># don't really know what was going on there. From reading the</span>
    <span class="s0"># GenerateConsoleCtrlEvent docs I don't know how it worked at all.</span>
    <span class="s0">#</span>
    <span class="s0"># I later spent a bunch of time trying to make GenerateConsoleCtrlEvent</span>
    <span class="s0"># work for creating synthetic control-C events, and... failed</span>
    <span class="s0"># utterly. There are lots of details in the code and comments</span>
    <span class="s0"># removed/added at this commit:</span>
    <span class="s0">#     https://github.com/python-trio/trio/commit/95843654173e3e826c34d70a90b369ba6edf2c23</span>
    <span class="s0">#</span>
    <span class="s0"># OTOH, if you pass os.kill any *other* signal number... then CPython</span>
    <span class="s0"># just calls TerminateProcess (wtf).</span>
    <span class="s0">#</span>
    <span class="s0"># So, anyway, os.kill is not so useful for testing purposes. Instead,</span>
    <span class="s0"># we use raise():</span>
    <span class="s0">#</span>
    <span class="s0">#   https://msdn.microsoft.com/en-us/library/dwwzkt4c.aspx</span>
    <span class="s0">#</span>
    <span class="s0"># Have to import cffi inside the 'if os.name' block because we don't</span>
    <span class="s0"># depend on cffi on non-Windows platforms. (It would be easy to switch</span>
    <span class="s0"># this to ctypes though if we ever remove the cffi dependency.)</span>
    <span class="s0">#</span>
    <span class="s0"># Some more information:</span>
    <span class="s0">#   https://bugs.python.org/issue26350</span>
    <span class="s0">#</span>
    <span class="s0"># Anyway, we use this for two things:</span>
    <span class="s0"># - redelivering unhandled signals</span>
    <span class="s0"># - generating synthetic signals for tests</span>
    <span class="s0"># and for both of those purposes, 'raise' works fine.</span>
    <span class="s2">import </span><span class="s1">cffi</span>

    <span class="s1">_ffi </span><span class="s3">= </span><span class="s1">cffi</span><span class="s3">.</span><span class="s1">FFI</span><span class="s3">()</span>
    <span class="s1">_ffi</span><span class="s3">.</span><span class="s1">cdef</span><span class="s3">(</span><span class="s4">&quot;int raise(int);&quot;</span><span class="s3">)</span>
    <span class="s1">_lib </span><span class="s3">= </span><span class="s1">_ffi</span><span class="s3">.</span><span class="s1">dlopen</span><span class="s3">(</span><span class="s4">&quot;api-ms-win-crt-runtime-l1-1-0.dll&quot;</span><span class="s3">)</span>
    <span class="s1">signal_raise </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">_lib</span><span class="s3">, </span><span class="s4">&quot;raise&quot;</span><span class="s3">)</span>
<span class="s2">else</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">signal_raise</span><span class="s3">(</span><span class="s1">signum</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">signal</span><span class="s3">.</span><span class="s1">pthread_kill</span><span class="s3">(</span><span class="s1">threading</span><span class="s3">.</span><span class="s1">get_ident</span><span class="s3">(), </span><span class="s1">signum</span><span class="s3">)</span>


<span class="s0"># See: #461 as to why this is needed.</span>
<span class="s0"># The gist is that threading.main_thread() has the capability to lie to us</span>
<span class="s0"># if somebody else edits the threading ident cache to replace the main</span>
<span class="s0"># thread; causing threading.current_thread() to return a _DummyThread,</span>
<span class="s0"># causing the C-c check to fail, and so on.</span>
<span class="s0"># Trying to use signal out of the main thread will fail, so we can then</span>
<span class="s0"># reliably check if this is the main thread without relying on a</span>
<span class="s0"># potentially modified threading.</span>
<span class="s2">def </span><span class="s1">is_main_thread</span><span class="s3">() </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Attempt to reliably check if we are in the main thread.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">signal</span><span class="s3">.</span><span class="s1">signal</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">SIGINT</span><span class="s3">, </span><span class="s1">signal</span><span class="s3">.</span><span class="s1">getsignal</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">SIGINT</span><span class="s3">))</span>
        <span class="s2">return True</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s2">return False</span>


<span class="s0">######</span>
<span class="s0"># Call the function and get the coroutine object, while giving helpful</span>
<span class="s0"># errors for common mistakes. Returns coroutine object.</span>
<span class="s0">######</span>
<span class="s0"># TODO: Use TypeVarTuple here.</span>
<span class="s2">def </span><span class="s1">coroutine_or_error</span><span class="s3">(</span>
    <span class="s1">async_fn</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Awaitable</span><span class="s3">[</span><span class="s1">RetT</span><span class="s3">]], *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Any</span>
<span class="s3">) </span><span class="s1">-&gt; collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Coroutine</span><span class="s3">[</span><span class="s1">object</span><span class="s3">, </span><span class="s1">t</span><span class="s3">.</span><span class="s1">NoReturn</span><span class="s3">, </span><span class="s1">RetT</span><span class="s3">]:</span>
    <span class="s2">def </span><span class="s1">_return_value_looks_like_wrong_library</span><span class="s3">(</span><span class="s1">value</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0"># Returned by legacy @asyncio.coroutine functions, which includes</span>
        <span class="s0"># a surprising proportion of asyncio builtins.</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Generator</span><span class="s3">):</span>
            <span class="s2">return True</span>
        <span class="s0"># The protocol for detecting an asyncio Future-like object</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s4">&quot;_asyncio_future_blocking&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return True</span>
        <span class="s0"># This janky check catches tornado Futures and twisted Deferreds.</span>
        <span class="s0"># By the time we're calling this function, we already know</span>
        <span class="s0"># something has gone wrong, so a heuristic is pretty safe.</span>
        <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;Future&quot;</span><span class="s3">, </span><span class="s4">&quot;Deferred&quot;</span><span class="s3">):</span>
            <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s0"># Make sure a sync-fn-that-returns-coroutine still sees itself as being</span>
    <span class="s0"># in trio context</span>
    <span class="s1">prev_loop</span><span class="s3">, </span><span class="s1">sniffio_loop</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">sniffio_loop</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;trio&quot;</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">coro </span><span class="s3">= </span><span class="s1">async_fn</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s0"># Give good error for: nursery.start_soon(trio.sleep(1))</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">async_fn</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Coroutine</span><span class="s3">):</span>
            <span class="s0"># explicitly close coroutine to avoid RuntimeWarning</span>
            <span class="s1">async_fn</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">&quot;Trio was expecting an async function, but instead it got &quot;</span>
                <span class="s4">f&quot;a coroutine object </span><span class="s2">{</span><span class="s1">async_fn</span><span class="s2">!r}\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Probably you did something like:</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;  trio.run(</span><span class="s2">{</span><span class="s1">async_fn</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">(...))            # incorrect!</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;  nursery.start_soon(</span><span class="s2">{</span><span class="s1">async_fn</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">(...))  # incorrect!</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Instead, you want (notice the parentheses!):</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;  trio.run(</span><span class="s2">{</span><span class="s1">async_fn</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">, ...)            # correct!</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;  nursery.start_soon(</span><span class="s2">{</span><span class="s1">async_fn</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">, ...)  # correct!&quot;</span>
            <span class="s3">) </span><span class="s2">from None</span>

        <span class="s0"># Give good error for: nursery.start_soon(future)</span>
        <span class="s2">if </span><span class="s1">_return_value_looks_like_wrong_library</span><span class="s3">(</span><span class="s1">async_fn</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">&quot;Trio was expecting an async function, but instead it got &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">async_fn</span><span class="s2">!r} </span><span class="s4">– are you trying to use a library written for &quot;</span>
                <span class="s4">&quot;asyncio/twisted/tornado or similar? That won't work &quot;</span>
                <span class="s4">&quot;without some sort of compatibility shim.&quot;</span>
            <span class="s3">) </span><span class="s2">from None</span>

        <span class="s2">raise</span>

    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">sniffio_loop</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">prev_loop</span>

    <span class="s0"># We can't check iscoroutinefunction(async_fn), because that will fail</span>
    <span class="s0"># for things like functools.partial objects wrapping an async</span>
    <span class="s0"># function. So we have to just call it and then check whether the</span>
    <span class="s0"># return value is a coroutine object.</span>
    <span class="s0"># Note: will not be necessary on python&gt;=3.8, see https://bugs.python.org/issue34890</span>
    <span class="s0"># TODO: python3.7 support is now dropped, so the above can be addressed.</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Coroutine</span><span class="s3">):</span>
        <span class="s0"># Give good error for: nursery.start_soon(func_returning_future)</span>
        <span class="s2">if </span><span class="s1">_return_value_looks_like_wrong_library</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">f&quot;Trio got unexpected </span><span class="s2">{</span><span class="s1">coro</span><span class="s2">!r} </span><span class="s4">– are you trying to use a &quot;</span>
                <span class="s4">&quot;library written for asyncio/twisted/tornado or similar? &quot;</span>
                <span class="s4">&quot;That won't work without some sort of compatibility shim.&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isasyncgen</span><span class="s3">(</span><span class="s1">coro</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">&quot;start_soon expected an async function but got an async &quot;</span>
                <span class="s4">f&quot;generator </span><span class="s2">{</span><span class="s1">coro</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s0"># Give good error for: nursery.start_soon(some_sync_fn)</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s4">&quot;Trio expected an async function, but {!r} appears to be &quot;</span>
            <span class="s4">&quot;synchronous&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">async_fn</span><span class="s3">, </span><span class="s4">&quot;__qualname__&quot;</span><span class="s3">, </span><span class="s1">async_fn</span><span class="s3">))</span>
        <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">coro</span>


<span class="s2">class </span><span class="s1">ConflictDetector</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Detect when two tasks are about to perform operations that would 
    conflict. 
 
    Use as a synchronous context manager; if two tasks enter it at the same 
    time then the second one raises an error. You can use it when there are 
    two pieces of code that *would* collide and need a lock if they ever were 
    called at the same time, but that should never happen. 
 
    We use this in particular for things like, making sure that two different 
    tasks don't call sendall simultaneously on the same stream. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_msg </span><span class="s3">= </span><span class="s1">msg</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_held </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__enter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_held</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">BusyResourceError</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_msg</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_held </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__exit__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">exc_type</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">BaseException</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">exc_value</span><span class="s3">: </span><span class="s1">BaseException </span><span class="s3">| </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">traceback</span><span class="s3">: </span><span class="s1">TracebackType </span><span class="s3">| </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_held </span><span class="s3">= </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">async_wraps</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">object</span><span class="s3">],</span>
    <span class="s1">wrapped_cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">object</span><span class="s3">],</span>
    <span class="s1">attr_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">CallT</span><span class="s3">], </span><span class="s1">CallT</span><span class="s3">]:</span>
    <span class="s5">&quot;&quot;&quot;Similar to wraps, but for async wrappers of non-async functions.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">decorator</span><span class="s3">(</span><span class="s1">func</span><span class="s3">: </span><span class="s1">CallT</span><span class="s3">) </span><span class="s1">-&gt; CallT</span><span class="s3">:</span>
        <span class="s1">func</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">= </span><span class="s1">attr_name</span>
        <span class="s1">func</span><span class="s3">.</span><span class="s1">__qualname__ </span><span class="s3">= </span><span class="s4">&quot;.&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">((</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">))</span>

        <span class="s1">func</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s4">&quot;&quot;&quot;Like :meth:`~{}.{}.{}`, but async. 
 
        &quot;&quot;&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">wrapped_cls</span><span class="s3">.</span><span class="s1">__module__</span><span class="s3">, </span><span class="s1">wrapped_cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s3">, </span><span class="s1">attr_name</span>
        <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">func</span>

    <span class="s2">return </span><span class="s1">decorator</span>


<span class="s2">def </span><span class="s1">fixup_module_metadata</span><span class="s3">(</span>
    <span class="s1">module_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">namespace</span><span class="s3">: </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]</span>
<span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s1">seen_ids</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">int</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">fix_one</span><span class="s3">(</span><span class="s1">qualname</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0"># avoid infinite recursion (relevant when using</span>
        <span class="s0"># typing.Generic, for example)</span>
        <span class="s2">if </span><span class="s1">id</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">in </span><span class="s1">seen_ids</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">seen_ids</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>

        <span class="s1">mod </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s4">&quot;__module__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">mod </span><span class="s2">is not None and </span><span class="s1">mod</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;trio.&quot;</span><span class="s3">):</span>
            <span class="s1">obj</span><span class="s3">.</span><span class="s1">__module__ </span><span class="s3">= </span><span class="s1">module_name</span>
            <span class="s0"># Modules, unlike everything else in Python, put fully-qualified</span>
            <span class="s0"># names into their __name__ attribute. We check for &quot;.&quot; to avoid</span>
            <span class="s0"># rewriting these.</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s4">&quot;__name__&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s4">&quot;.&quot; </span><span class="s2">not in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">:</span>
                <span class="s1">obj</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">= </span><span class="s1">name</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s4">&quot;__qualname__&quot;</span><span class="s3">):</span>
                    <span class="s1">obj</span><span class="s3">.</span><span class="s1">__qualname__ </span><span class="s3">= </span><span class="s1">qualname</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">attr_value </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">fix_one</span><span class="s3">(</span><span class="s1">objname </span><span class="s3">+ </span><span class="s4">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">, </span><span class="s1">attr_value</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">objname</span><span class="s3">, </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">namespace</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if not </span><span class="s1">objname</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">):  </span><span class="s0"># ignore private attributes</span>
            <span class="s1">fix_one</span><span class="s3">(</span><span class="s1">objname</span><span class="s3">, </span><span class="s1">objname</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>


<span class="s0"># We need ParamSpec to type this &quot;properly&quot;, but that requires a runtime typing_extensions import</span>
<span class="s0"># to use as a class base. This is only used at runtime and isn't correct for type checkers anyway,</span>
<span class="s0"># so don't bother.</span>
<span class="s2">class </span><span class="s1">generic_function</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">Generic</span><span class="s3">[</span><span class="s1">RetT</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Decorator that makes a function indexable, to communicate 
    non-inferrable generic type parameters to a static type checker. 
 
    If you write:: 
 
        @generic_function 
        def open_memory_channel(max_buffer_size: int) -&gt; Tuple[ 
            SendChannel[T], ReceiveChannel[T] 
        ]: ... 
 
    it is valid at runtime to say ``open_memory_channel[bytes](5)``. 
    This behaves identically to ``open_memory_channel(5)`` at runtime, 
    and currently won't type-check without a mypy plugin or clever stubs, 
    but at least it becomes possible to write those. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">RetT</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">update_wrapper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fn </span><span class="s3">= </span><span class="s1">fn</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; RetT</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fn</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">subscript</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; Self</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_init_final_cls</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">object</span><span class="s3">]) </span><span class="s1">-&gt; t</span><span class="s3">.</span><span class="s1">NoReturn</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Raises an exception when a final class is subclassed.&quot;&quot;&quot;</span>
    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__module__</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s2">} </span><span class="s4">does not support subclassing&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_final_impl</span><span class="s3">(</span><span class="s1">decorated</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">T</span><span class="s3">]) </span><span class="s1">-&gt; type</span><span class="s3">[</span><span class="s1">T</span><span class="s3">]:</span>
    <span class="s5">&quot;&quot;&quot;Decorator that enforces a class to be final (i.e., subclass not allowed). 
 
    If a class uses this metaclass like this:: 
 
        @final 
        class SomeClass: 
            pass 
 
    The metaclass will ensure that no subclass can be created. 
 
    Raises 
    ------ 
    - TypeError if a subclass is created 
    &quot;&quot;&quot;</span>
    <span class="s0"># Override the method blindly. We're always going to raise, so it doesn't</span>
    <span class="s0"># matter what the original did (if anything).</span>
    <span class="s1">decorated</span><span class="s3">.</span><span class="s1">__init_subclass__ </span><span class="s3">= </span><span class="s1">classmethod</span><span class="s3">(</span><span class="s1">_init_final_cls</span><span class="s3">)  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s0"># Apply the typing decorator, in 3.11+ it adds a __final__ marker attribute.</span>
    <span class="s2">return </span><span class="s1">t</span><span class="s3">.</span><span class="s1">final</span><span class="s3">(</span><span class="s1">decorated</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">final </span><span class="s3">= </span><span class="s1">_final_impl</span>


<span class="s3">@</span><span class="s1">final  </span><span class="s0"># No subclassing of NoPublicConstructor itself.</span>
<span class="s2">class </span><span class="s1">NoPublicConstructor</span><span class="s3">(</span><span class="s1">ABCMeta</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Metaclass that ensures a private constructor. 
 
    If a class uses this metaclass like this:: 
 
        @final 
        class SomeClass(metaclass=NoPublicConstructor): 
            pass 
 
    The metaclass will ensure that no instance can be initialized. This should always be 
    used with @final. 
 
    If you try to instantiate your class (SomeClass()), a TypeError will be thrown. Use 
    _create() instead in the class's implementation. 
 
    Raises 
    ------ 
    - TypeError if an instance is created. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__module__</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__qualname__</span><span class="s2">} </span><span class="s4">has no public constructor&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_create</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">T</span><span class="s3">], *</span><span class="s1">args</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; T</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">__call__</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)  </span><span class="s0"># type: ignore</span>


<span class="s2">def </span><span class="s1">name_asyncgen</span><span class="s3">(</span><span class="s1">agen</span><span class="s3">: </span><span class="s1">AsyncGeneratorType</span><span class="s3">[</span><span class="s1">object</span><span class="s3">, </span><span class="s1">t</span><span class="s3">.</span><span class="s1">NoReturn</span><span class="s3">]) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Return the fully-qualified name of the async generator function 
    that produced the async generator iterator *agen*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">agen</span><span class="s3">, </span><span class="s4">&quot;ag_code&quot;</span><span class="s3">):  </span><span class="s0"># pragma: no cover</span>
        <span class="s2">return </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">agen</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s1">agen</span><span class="s3">.</span><span class="s1">ag_frame</span><span class="s3">.</span><span class="s1">f_globals</span><span class="s3">[</span><span class="s4">&quot;__name__&quot;</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">agen</span><span class="s3">.</span><span class="s1">ag_code</span><span class="s3">.</span><span class="s1">co_filename</span><span class="s2">}</span><span class="s4">&gt;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">qualname </span><span class="s3">= </span><span class="s1">agen</span><span class="s3">.</span><span class="s1">__qualname__</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s1">qualname </span><span class="s3">= </span><span class="s1">agen</span><span class="s3">.</span><span class="s1">ag_code</span><span class="s3">.</span><span class="s1">co_name</span>
    <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">module</span><span class="s2">}</span><span class="s4">.</span><span class="s2">{</span><span class="s1">qualname</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s0"># work around a pyright error</span>
<span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s1">Fn </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;Fn&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">object</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">wraps</span><span class="s3">(</span>
        <span class="s1">wrapped</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">object</span><span class="s3">],</span>
        <span class="s1">assigned</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = ...,</span>
        <span class="s1">updated</span><span class="s3">: </span><span class="s1">t</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; t</span><span class="s3">.</span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Fn</span><span class="s3">], </span><span class="s1">Fn</span><span class="s3">]:</span>
        <span class="s3">...</span>

<span class="s2">else</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps  </span><span class="s0"># noqa: F401  # this is re-exported</span>
</pre>
</body>
</html>