<html>
<head>
<title>api.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
api.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span><span class="s2">, </span><span class="s1">types</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">lock </span><span class="s0">import </span><span class="s1">allocate_lock</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">error </span><span class="s0">import </span><span class="s1">CDefError</span>
<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">model</span>

<span class="s0">try</span><span class="s2">:</span>
    <span class="s1">callable</span>
<span class="s0">except </span><span class="s1">NameError</span><span class="s2">:</span>
    <span class="s3"># Python 3.1</span>
    <span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">Callable</span>
    <span class="s1">callable </span><span class="s2">= </span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">)</span>

<span class="s0">try</span><span class="s2">:</span>
    <span class="s1">basestring</span>
<span class="s0">except </span><span class="s1">NameError</span><span class="s2">:</span>
    <span class="s3"># Python 3.x</span>
    <span class="s1">basestring </span><span class="s2">= </span><span class="s1">str</span>

<span class="s1">_unspecified </span><span class="s2">= </span><span class="s1">object</span><span class="s2">()</span>



<span class="s0">class </span><span class="s1">FFI</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">r''' 
    The main top-level class that you instantiate once, or once per module. 
 
    Example usage: 
 
        ffi = FFI() 
        ffi.cdef(&quot;&quot;&quot; 
            int printf(const char *, ...); 
        &quot;&quot;&quot;) 
 
        C = ffi.dlopen(None)   # standard library 
        -or- 
        C = ffi.verify()  # use a C compiler: verify the decl above is right 
 
        C.printf(&quot;hello, %s!\n&quot;, ffi.new(&quot;char[]&quot;, &quot;world&quot;)) 
    '''</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Create an FFI instance.  The 'backend' argument is used to 
        select a non-default backend, mostly for tests. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">backend </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s3"># You need PyPy (&gt;= 2.0 beta), or a CPython (&gt;= 2.6) with</span>
            <span class="s3"># _cffi_backend.so compiled.</span>
            <span class="s0">import </span><span class="s1">_cffi_backend </span><span class="s0">as </span><span class="s1">backend</span>
            <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">__version__</span>
            <span class="s0">if </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">__version__ </span><span class="s2">!= </span><span class="s1">__version__</span><span class="s2">:</span>
                <span class="s3"># bad version!  Try to be as explicit as possible.</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s5">'__file__'</span><span class="s2">):</span>
                    <span class="s3"># CPython</span>
                    <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s5">&quot;Version mismatch: this is the 'cffi' package version %s, located in %r.  When we import the top-level '_cffi_backend' extension module, we get version %s, located in %r.  The two versions should be equal; check your installation.&quot; </span><span class="s2">% (</span>
                        <span class="s1">__version__</span><span class="s2">, </span><span class="s1">__file__</span><span class="s2">,</span>
                        <span class="s1">backend</span><span class="s2">.</span><span class="s1">__version__</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">__file__</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s3"># PyPy</span>
                    <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s5">&quot;Version mismatch: this is the 'cffi' package version %s, located in %r.  This interpreter comes with a built-in '_cffi_backend' module, which is version %s.  The two versions should be equal; check your installation.&quot; </span><span class="s2">% (</span>
                        <span class="s1">__version__</span><span class="s2">, </span><span class="s1">__file__</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">__version__</span><span class="s2">))</span>
            <span class="s3"># (If you insist you can also try to pass the option</span>
            <span class="s3"># 'backend=backend_ctypes.CTypesBackend()', but don't</span>
            <span class="s3"># rely on it!  It's probably not going to work well.)</span>

        <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">cparser</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_backend </span><span class="s2">= </span><span class="s1">backend</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lock </span><span class="s2">= </span><span class="s1">allocate_lock</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_parser </span><span class="s2">= </span><span class="s1">cparser</span><span class="s2">.</span><span class="s1">Parser</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cached_btypes </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_types </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">(</span><span class="s5">'parsed_types'</span><span class="s2">).</span><span class="s1">__dict__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_new_types </span><span class="s2">= </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">(</span><span class="s5">'new_types'</span><span class="s2">).</span><span class="s1">__dict__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_function_caches </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_libraries </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdefsources </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_included_ffis </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_windows_unicode </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_init_once_cache </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdef_version </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_embedding </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_typecache </span><span class="s2">= </span><span class="s1">model</span><span class="s2">.</span><span class="s1">get_typecache</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s5">'set_ffi'</span><span class="s2">):</span>
            <span class="s1">backend</span><span class="s2">.</span><span class="s1">set_ffi</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">name</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'RTLD_'</span><span class="s2">):</span>
                <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s1">name</span><span class="s2">))</span>
        <span class="s3">#</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">BVoidP </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">voidp_type</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">BCharA </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">char_array_type</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">):</span>
            <span class="s3"># _cffi_backend: attach these constants to the class</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">FFI</span><span class="s2">, </span><span class="s5">'NULL'</span><span class="s2">):</span>
                <span class="s1">FFI</span><span class="s2">.</span><span class="s1">NULL </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">BVoidP</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
                <span class="s1">FFI</span><span class="s2">.</span><span class="s1">CData</span><span class="s2">, </span><span class="s1">FFI</span><span class="s2">.</span><span class="s1">CType </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">_get_types</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># ctypes backend: attach these constants to the instance</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">NULL </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">BVoidP</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">CData</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">CType </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">_get_types</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">buffer </span><span class="s2">= </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">buffer</span>

    <span class="s0">def </span><span class="s1">cdef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">csource</span><span class="s2">, </span><span class="s1">override</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">packed</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">pack</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Parse the given C source.  This registers all declared functions, 
        types, and global variables.  The functions and global variables can 
        then be accessed via either 'ffi.dlopen()' or 'ffi.verify()'. 
        The types can be used in 'ffi.new()' and other functions. 
        If 'packed' is specified as True, all structs declared inside this 
        cdef are packed, i.e. laid out without any field alignment at all. 
        Alternatively, 'pack' can be a small integer, and requests for 
        alignment greater than that are ignored (pack=1 is equivalent to 
        packed=True). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdef</span><span class="s2">(</span><span class="s1">csource</span><span class="s2">, </span><span class="s1">override</span><span class="s2">=</span><span class="s1">override</span><span class="s2">, </span><span class="s1">packed</span><span class="s2">=</span><span class="s1">packed</span><span class="s2">, </span><span class="s1">pack</span><span class="s2">=</span><span class="s1">pack</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">embedding_api</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">csource</span><span class="s2">, </span><span class="s1">packed</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">pack</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdef</span><span class="s2">(</span><span class="s1">csource</span><span class="s2">, </span><span class="s1">packed</span><span class="s2">=</span><span class="s1">packed</span><span class="s2">, </span><span class="s1">pack</span><span class="s2">=</span><span class="s1">pack</span><span class="s2">, </span><span class="s1">dllexport</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_embedding </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_embedding </span><span class="s2">= </span><span class="s5">''</span>

    <span class="s0">def </span><span class="s1">_cdef</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">csource</span><span class="s2">, </span><span class="s1">override</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">csource</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):    </span><span class="s3"># unicode, on Python 2</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">csource</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;cdef() argument must be a string&quot;</span><span class="s2">)</span>
            <span class="s1">csource </span><span class="s2">= </span><span class="s1">csource</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">(</span><span class="s5">'ascii'</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdef_version </span><span class="s2">= </span><span class="s1">object</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">parse</span><span class="s2">(</span><span class="s1">csource</span><span class="s2">, </span><span class="s1">override</span><span class="s2">=</span><span class="s1">override</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdefsources</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">csource</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">override</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">cache </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_function_caches</span><span class="s2">:</span>
                    <span class="s1">cache</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
            <span class="s1">finishlist </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_recomplete</span>
            <span class="s0">if </span><span class="s1">finishlist</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_recomplete </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">tp </span><span class="s0">in </span><span class="s1">finishlist</span><span class="s2">:</span>
                    <span class="s1">tp</span><span class="s2">.</span><span class="s1">finish_backend_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">finishlist</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">dlopen</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Load and return a dynamic library identified by 'name'. 
        The standard C library can be loaded by passing None. 
        Note that functions and types declared by 'ffi.cdef()' are not 
        linked to a particular library, just like C headers; in the 
        library we only look for the actual (untyped) symbols. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">) </span><span class="s0">or</span>
                <span class="s1">name </span><span class="s0">is None or</span>
                <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">CData</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;dlopen(name): name must be a file name, None, &quot;</span>
                            <span class="s5">&quot;or an already-opened 'void *' handle&quot;</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s1">lib</span><span class="s2">, </span><span class="s1">function_cache </span><span class="s2">= </span><span class="s1">_make_ffi_library</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_function_caches</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">function_cache</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_libraries</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">lib</span>

    <span class="s0">def </span><span class="s1">dlclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lib</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Close a library obtained with ffi.dlopen().  After this call, 
        access to functions or variables from the library will fail 
        (possibly with a segmentation fault). 
        &quot;&quot;&quot;</span>
        <span class="s1">type</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">).</span><span class="s1">__cffi_close__</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_typeof_locked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">):</span>
        <span class="s3"># call me with the lock!</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">cdecl</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_types</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_types</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
        <span class="s3">#</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):    </span><span class="s3"># unicode, on Python 2</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">cdecl</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">(</span><span class="s5">'ascii'</span><span class="s2">)</span>
        <span class="s3">#</span>
        <span class="s1">type </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">parse_type</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s1">really_a_function_type </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">is_raw_function</span>
        <span class="s0">if </span><span class="s1">really_a_function_type</span><span class="s2">:</span>
            <span class="s1">type </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">as_function_pointer</span><span class="s2">()</span>
        <span class="s1">btype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">type</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">btype</span><span class="s2">, </span><span class="s1">really_a_function_type</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_types</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">result</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">consider_function_as_funcptr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s3"># string -&gt; ctype object</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parsed_types</span><span class="s2">[</span><span class="s1">cdecl</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof_locked</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s3">#</span>
        <span class="s1">btype</span><span class="s2">, </span><span class="s1">really_a_function_type </span><span class="s2">= </span><span class="s1">result</span>
        <span class="s0">if </span><span class="s1">really_a_function_type </span><span class="s0">and not </span><span class="s1">consider_function_as_funcptr</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">CDefError</span><span class="s2">(</span><span class="s5">&quot;the type %r is a function type, not a &quot;</span>
                            <span class="s5">&quot;pointer-to-function type&quot; </span><span class="s2">% (</span><span class="s1">cdecl</span><span class="s2">,))</span>
        <span class="s0">return </span><span class="s1">btype</span>

    <span class="s0">def </span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Parse the C type given as a string and return the 
        corresponding &lt;ctype&gt; object. 
        It can also be used on 'cdata' instance to get its C type. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">CData</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">BuiltinFunctionType</span><span class="s2">):</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">_builtin_function_type</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">res </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">types</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s5">'_cffi_base_type'</span><span class="s2">)):</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">.</span><span class="s1">_cffi_base_type</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">sizeof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return the size in bytes of the argument.  It can be a 
        string naming a C type, or a 'cdata' instance. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">BType </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s1">BType</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">sizeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">alignof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return the natural alignment size in bytes of the C type 
        given as a string. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">alignof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">offsetof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, *</span><span class="s1">fields_or_indexes</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return the offset of the named field inside the given 
        structure or array, which must be given as a C type name. 
        You can give several field names in case of nested structures. 
        You can also give numeric values which correspond to array 
        items, in case of an array type. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeoffsetof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, *</span><span class="s1">fields_or_indexes</span><span class="s2">)[</span><span class="s6">1</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">new</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">init</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Allocate an instance according to the specified C type and 
        return a pointer to it.  The specified C type must be either a 
        pointer or an array: ``new('X *')`` allocates an X and returns 
        a pointer to it, whereas ``new('X[n]')`` allocates an array of 
        n X'es and returns an array referencing it (which works 
        mostly like a pointer, like in C).  You can also use 
        ``new('X[]', n)`` to allocate an array of a non-constant 
        length n. 
 
        The memory is initialized following the rules of declaring a 
        global variable in C: by default it is zero-initialized, but 
        an explicit initializer can be given which can be used to 
        fill all or part of the memory. 
 
        When the returned &lt;cdata&gt; object goes out of scope, the memory 
        is freed.  In other words the returned &lt;cdata&gt; object has 
        ownership of the value of type 'cdecl' that it points to.  This 
        means that the raw data can be used as long as this object is 
        kept alive, but must not be used for a longer time.  Be careful 
        about that when copying the pointer to the memory somewhere 
        else, e.g. into another structure. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">newp</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">init</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">new_allocator</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">alloc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">free</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                      <span class="s1">should_clear_after_alloc</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a new allocator, i.e. a function that behaves like ffi.new() 
        but uses the provided low-level 'alloc' and 'free' functions. 
 
        'alloc' is called with the size as argument.  If it returns NULL, a 
        MemoryError is raised.  'free' is called with the result of 'alloc' 
        as argument.  Both can be either Python function or directly C 
        functions.  If 'free' is None, then no free function is called. 
        If both 'alloc' and 'free' are None, the default is used. 
 
        If 'should_clear_after_alloc' is set to False, then the memory 
        returned by 'alloc' is assumed to be already cleared (or you are 
        fine with garbage); otherwise CFFI will clear it. 
        &quot;&quot;&quot;</span>
        <span class="s1">compiled_ffi </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">FFI</span><span class="s2">()</span>
        <span class="s1">allocator </span><span class="s2">= </span><span class="s1">compiled_ffi</span><span class="s2">.</span><span class="s1">new_allocator</span><span class="s2">(</span><span class="s1">alloc</span><span class="s2">, </span><span class="s1">free</span><span class="s2">,</span>
                                               <span class="s1">should_clear_after_alloc</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">allocate</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">init</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
                <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">allocator</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">init</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">allocate</span>

    <span class="s0">def </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">source</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Similar to a C cast: returns an instance of the named C 
        type initialized with the given 'source'.  The source is 
        casted between integers or pointers of any type. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">source</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">string</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">maxlen</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a Python string (or unicode string) from the 'cdata'. 
        If 'cdata' is a pointer or array of characters or bytes, returns 
        the null-terminated string.  The returned string extends until 
        the first null character, or at most 'maxlen' characters.  If 
        'cdata' is an array then 'maxlen' defaults to its length. 
 
        If 'cdata' is a pointer or array of wchar_t, returns a unicode 
        string following the same rules. 
 
        If 'cdata' is a single character or byte or a wchar_t, returns 
        it as a string or unicode string. 
 
        If 'cdata' is an enum, returns the value of the enumerator as a 
        string, or 'NUMBER' if the value is out of range. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">maxlen</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">unpack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">length</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Unpack an array of C data of the given length, 
        returning a Python string/unicode/list. 
 
        If 'cdata' is a pointer to 'char', returns a byte string. 
        It does not stop at the first null.  This is equivalent to: 
        ffi.buffer(cdata, length)[:] 
 
        If 'cdata' is a pointer to 'wchar_t', returns a unicode string. 
        'length' is measured in wchar_t's; it is not the size in bytes. 
 
        If 'cdata' is a pointer to anything else, returns a list of 
        'length' items.  This is a faster equivalent to: 
        [cdata[i] for i in range(length)] 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">length</span><span class="s2">)</span>

   <span class="s3">#def buffer(self, cdata, size=-1):</span>
   <span class="s3">#    &quot;&quot;&quot;Return a read-write buffer object that references the raw C data</span>
   <span class="s3">#    pointed to by the given 'cdata'.  The 'cdata' must be a pointer or</span>
   <span class="s3">#    an array.  Can be passed to functions expecting a buffer, or directly</span>
   <span class="s3">#    manipulated with:</span>
   <span class="s3">#</span>
   <span class="s3">#        buf[:]          get a copy of it in a regular string, or</span>
   <span class="s3">#        buf[idx]        as a single character</span>
   <span class="s3">#        buf[:] = ...</span>
   <span class="s3">#        buf[idx] = ...  change the content</span>
   <span class="s3">#    &quot;&quot;&quot;</span>
   <span class="s3">#    note that 'buffer' is a type, set on this instance by __init__</span>

    <span class="s0">def </span><span class="s1">from_buffer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">python_buffer</span><span class="s2">=</span><span class="s1">_unspecified</span><span class="s2">,</span>
                    <span class="s1">require_writable</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a cdata of the given type pointing to the data of the 
        given Python object, which must support the buffer interface. 
        Note that this is not meant to be used on the built-in types 
        str or unicode (you can build 'char[]' arrays explicitly) 
        but only on objects containing large quantities of raw data 
        in some other format, like 'array.array' or numpy arrays. 
 
        The first argument is optional and default to 'char[]'. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">python_buffer </span><span class="s0">is </span><span class="s1">_unspecified</span><span class="s2">:</span>
            <span class="s1">cdecl</span><span class="s2">, </span><span class="s1">python_buffer </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">BCharA</span><span class="s2">, </span><span class="s1">cdecl</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">from_buffer</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">python_buffer</span><span class="s2">,</span>
                                         <span class="s1">require_writable</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">memmove</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dest</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;ffi.memmove(dest, src, n) copies n bytes of memory from src to dest. 
 
        Like the C function memmove(), the memory areas may overlap; 
        apart from that it behaves like the C function memcpy(). 
 
        'src' can be any cdata ptr or array, or any Python buffer object. 
        'dest' can be any cdata ptr or array, or a writable Python buffer 
        object.  The size to copy, 'n', is always measured in bytes. 
 
        Unlike other methods, this one supports all Python buffer including 
        byte strings and bytearrays---but it still does not support 
        non-contiguous buffers. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">memmove</span><span class="s2">(</span><span class="s1">dest</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">callback</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">python_callable</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">error</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">onerror</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a callback object or a decorator making such a 
        callback object.  'cdecl' must name a C function pointer type. 
        The callback invokes the specified 'python_callable' (which may 
        be provided either directly or via a decorator).  Important: the 
        callback object must be manually kept alive for as long as the 
        callback may be invoked from the C level. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">callback_decorator_wrap</span><span class="s2">(</span><span class="s1">python_callable</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">python_callable</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;the 'python_callable' argument &quot;</span>
                                <span class="s5">&quot;is not callable&quot;</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">callback</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">python_callable</span><span class="s2">,</span>
                                          <span class="s1">error</span><span class="s2">, </span><span class="s1">onerror</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">consider_function_as_funcptr</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">python_callable </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">callback_decorator_wrap                </span><span class="s3"># decorator mode</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">callback_decorator_wrap</span><span class="s2">(</span><span class="s1">python_callable</span><span class="s2">)  </span><span class="s3"># direct mode</span>

    <span class="s0">def </span><span class="s1">getctype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">replace_with</span><span class="s2">=</span><span class="s5">''</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a string giving the C type 'cdecl', which may be itself 
        a string or a &lt;ctype&gt; object.  If 'replace_with' is given, it gives 
        extra text to append (or insert for more complicated C types), like 
        a variable name, or '*' to get actually the C type 'pointer-to-cdecl'. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s1">cdecl </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeof</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">)</span>
        <span class="s1">replace_with </span><span class="s2">= </span><span class="s1">replace_with</span><span class="s2">.</span><span class="s1">strip</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">replace_with</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'*'</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s5">'&amp;[' </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">getcname</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s5">'&amp;'</span><span class="s2">)):</span>
            <span class="s1">replace_with </span><span class="s2">= </span><span class="s5">'(%s)' </span><span class="s2">% </span><span class="s1">replace_with</span>
        <span class="s0">elif </span><span class="s1">replace_with </span><span class="s0">and not </span><span class="s1">replace_with</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">in </span><span class="s5">'[('</span><span class="s2">:</span>
            <span class="s1">replace_with </span><span class="s2">= </span><span class="s5">' ' </span><span class="s2">+ </span><span class="s1">replace_with</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">getcname</span><span class="s2">(</span><span class="s1">cdecl</span><span class="s2">, </span><span class="s1">replace_with</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">gc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">destructor</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a new cdata object that points to the same 
        data.  Later, when this new cdata object is garbage-collected, 
        'destructor(old_cdata_object)' will be called. 
 
        The optional 'size' gives an estimate of the size, used to 
        trigger the garbage collection more eagerly.  So far only used 
        on PyPy.  It tells the GC that the returned object keeps alive 
        roughly 'size' bytes of external memory. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">gcp</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">destructor</span><span class="s2">, </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">acquire</span><span class="s2">(</span><span class="s0">False</span><span class="s2">) </span><span class="s0">is False</span>
        <span class="s3"># call me with the lock!</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">BType </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cached_btypes</span><span class="s2">[</span><span class="s1">type</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">finishlist </span><span class="s2">= []</span>
            <span class="s1">BType </span><span class="s2">= </span><span class="s1">type</span><span class="s2">.</span><span class="s1">get_cached_btype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">finishlist</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">type </span><span class="s0">in </span><span class="s1">finishlist</span><span class="s2">:</span>
                <span class="s1">type</span><span class="s2">.</span><span class="s1">finish_backend_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">finishlist</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">BType</span>

    <span class="s0">def </span><span class="s1">verify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">source</span><span class="s2">=</span><span class="s5">''</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Verify that the current ffi signatures compile on this 
        machine, and return a dynamic library object.  The dynamic 
        library can be used to call functions and access global 
        variables declared in this 'ffi'.  The library is compiled 
        by the C compiler: it gives you C-level API compatibility 
        (including calling macros).  This is unlike 'ffi.dlopen()', 
        which requires binary compatibility in the signatures. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s2">.</span><span class="s1">verifier </span><span class="s0">import </span><span class="s1">Verifier</span><span class="s2">, </span><span class="s1">_caller_dir_pycache</span>
        <span class="s3">#</span>
        <span class="s3"># If set_unicode(True) was called, insert the UNICODE and</span>
        <span class="s3"># _UNICODE macro declarations</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_windows_unicode</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_apply_windows_unicode</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s3">#</span>
        <span class="s3"># Set the tmpdir here, and not in Verifier.__init__: it picks</span>
        <span class="s3"># up the caller's directory, which we want to be the caller of</span>
        <span class="s3"># ffi.verify(), as opposed to the caller of Veritier().</span>
        <span class="s1">tmpdir </span><span class="s2">= </span><span class="s1">tmpdir </span><span class="s0">or </span><span class="s1">_caller_dir_pycache</span><span class="s2">()</span>
        <span class="s3">#</span>
        <span class="s3"># Make a Verifier() and use it to load the library.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">verifier </span><span class="s2">= </span><span class="s1">Verifier</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">lib </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">verifier</span><span class="s2">.</span><span class="s1">load_library</span><span class="s2">()</span>
        <span class="s3">#</span>
        <span class="s3"># Save the loaded library for keep-alive purposes, even</span>
        <span class="s3"># if the caller doesn't keep it alive itself (it should).</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_libraries</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">lib</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">lib</span>

    <span class="s0">def </span><span class="s1">_get_errno</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">get_errno</span><span class="s2">()</span>
    <span class="s0">def </span><span class="s1">_set_errno</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">errno</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">set_errno</span><span class="s2">(</span><span class="s1">errno</span><span class="s2">)</span>
    <span class="s1">errno </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s1">_get_errno</span><span class="s2">, </span><span class="s1">_set_errno</span><span class="s2">, </span><span class="s0">None</span><span class="s2">,</span>
                     <span class="s5">&quot;the value of 'errno' from/to the C calls&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">getwinerror</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">getwinerror</span><span class="s2">(</span><span class="s1">code</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_pointer_to</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">model</span><span class="s2">.</span><span class="s1">pointer_cache</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">addressof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, *</span><span class="s1">fields_or_indexes</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return the address of a &lt;cdata 'struct-or-union'&gt;. 
        If 'fields_or_indexes' are given, returns the address of that 
        field or array item in the structure or array, recursively in 
        case of nested structures. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">ctype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">typeof</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s5">'__addressof__' </span><span class="s0">in </span><span class="s1">type</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">).</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">).</span><span class="s1">__addressof__</span><span class="s2">(</span><span class="s1">cdata</span><span class="s2">, *</span><span class="s1">fields_or_indexes</span><span class="s2">)</span>
            <span class="s0">raise</span>
        <span class="s0">if </span><span class="s1">fields_or_indexes</span><span class="s2">:</span>
            <span class="s1">ctype</span><span class="s2">, </span><span class="s1">offset </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_typeoffsetof</span><span class="s2">(</span><span class="s1">ctype</span><span class="s2">, *</span><span class="s1">fields_or_indexes</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">ctype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;pointer&quot;</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;addressof(pointer)&quot;</span><span class="s2">)</span>
            <span class="s1">offset </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">ctypeptr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pointer_to</span><span class="s2">(</span><span class="s1">ctype</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">rawaddressof</span><span class="s2">(</span><span class="s1">ctypeptr</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_typeoffsetof</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">field_or_index</span><span class="s2">, *</span><span class="s1">fields_or_indexes</span><span class="s2">):</span>
        <span class="s1">ctype</span><span class="s2">, </span><span class="s1">offset </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">typeoffsetof</span><span class="s2">(</span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">field_or_index</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">field1 </span><span class="s0">in </span><span class="s1">fields_or_indexes</span><span class="s2">:</span>
            <span class="s1">ctype</span><span class="s2">, </span><span class="s1">offset1 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">typeoffsetof</span><span class="s2">(</span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">field1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
            <span class="s1">offset </span><span class="s2">+= </span><span class="s1">offset1</span>
        <span class="s0">return </span><span class="s1">ctype</span><span class="s2">, </span><span class="s1">offset</span>

    <span class="s0">def </span><span class="s1">include</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ffi_to_include</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Includes the typedefs, structs, unions and enums defined 
        in another FFI instance.  Usage is similar to a #include in C, 
        where a part of the program might include types defined in 
        another part for its own usage.  Note that the include() 
        method has no effect on functions, constants and global 
        variables, which must anyway be accessed directly from the 
        lib object returned by the original FFI instance. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ffi_to_include</span><span class="s2">, </span><span class="s1">FFI</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;ffi.include() expects an argument that is also of&quot;</span>
                            <span class="s5">&quot; type cffi.FFI, not %r&quot; </span><span class="s2">% (</span>
                                <span class="s1">type</span><span class="s2">(</span><span class="s1">ffi_to_include</span><span class="s2">).</span><span class="s1">__name__</span><span class="s2">,))</span>
        <span class="s0">if </span><span class="s1">ffi_to_include </span><span class="s0">is </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;self.include(self)&quot;</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">ffi_to_include</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">include</span><span class="s2">(</span><span class="s1">ffi_to_include</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdefsources</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">'['</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdefsources</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">ffi_to_include</span><span class="s2">.</span><span class="s1">_cdefsources</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_cdefsources</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">']'</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_included_ffis</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ffi_to_include</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">new_handle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">newp_handle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">BVoidP</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">from_handle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">from_handle</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">release</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">release</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">set_unicode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">enabled_flag</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Windows: if 'enabled_flag' is True, enable the UNICODE and 
        _UNICODE defines in C, and declare the types like TCHAR and LPTCSTR 
        to be (pointers to) wchar_t.  If 'enabled_flag' is False, 
        declare these types to be (pointers to) plain 8-bit characters. 
        This is mostly for backward compatibility; you usually want True. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_windows_unicode </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;set_unicode() can only be called once&quot;</span><span class="s2">)</span>
        <span class="s1">enabled_flag </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">enabled_flag</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">enabled_flag</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cdef</span><span class="s2">(</span><span class="s5">&quot;typedef wchar_t TBYTE;&quot;</span>
                      <span class="s5">&quot;typedef wchar_t TCHAR;&quot;</span>
                      <span class="s5">&quot;typedef const wchar_t *LPCTSTR;&quot;</span>
                      <span class="s5">&quot;typedef const wchar_t *PCTSTR;&quot;</span>
                      <span class="s5">&quot;typedef wchar_t *LPTSTR;&quot;</span>
                      <span class="s5">&quot;typedef wchar_t *PTSTR;&quot;</span>
                      <span class="s5">&quot;typedef TBYTE *PTBYTE;&quot;</span>
                      <span class="s5">&quot;typedef TCHAR *PTCHAR;&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cdef</span><span class="s2">(</span><span class="s5">&quot;typedef char TBYTE;&quot;</span>
                      <span class="s5">&quot;typedef char TCHAR;&quot;</span>
                      <span class="s5">&quot;typedef const char *LPCTSTR;&quot;</span>
                      <span class="s5">&quot;typedef const char *PCTSTR;&quot;</span>
                      <span class="s5">&quot;typedef char *LPTSTR;&quot;</span>
                      <span class="s5">&quot;typedef char *PTSTR;&quot;</span>
                      <span class="s5">&quot;typedef TBYTE *PTBYTE;&quot;</span>
                      <span class="s5">&quot;typedef TCHAR *PTCHAR;&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_windows_unicode </span><span class="s2">= </span><span class="s1">enabled_flag</span>

    <span class="s0">def </span><span class="s1">_apply_windows_unicode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">kwds</span><span class="s2">):</span>
        <span class="s1">defmacros </span><span class="s2">= </span><span class="s1">kwds</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'define_macros'</span><span class="s2">, ())</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">defmacros</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;'define_macros' must be a list or tuple&quot;</span><span class="s2">)</span>
        <span class="s1">defmacros </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">defmacros</span><span class="s2">) + [(</span><span class="s5">'UNICODE'</span><span class="s2">, </span><span class="s5">'1'</span><span class="s2">),</span>
                                       <span class="s2">(</span><span class="s5">'_UNICODE'</span><span class="s2">, </span><span class="s5">'1'</span><span class="s2">)]</span>
        <span class="s1">kwds</span><span class="s2">[</span><span class="s5">'define_macros'</span><span class="s2">] = </span><span class="s1">defmacros</span>

    <span class="s0">def </span><span class="s1">_apply_embedding_fix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">kwds</span><span class="s2">):</span>
        <span class="s3"># must include an argument like &quot;-lpython2.7&quot; for the compiler</span>
        <span class="s0">def </span><span class="s1">ensure</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
            <span class="s1">lst </span><span class="s2">= </span><span class="s1">kwds</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, [])</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">not in </span><span class="s1">lst</span><span class="s2">:</span>
                <span class="s1">lst</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s3">#</span>
        <span class="s0">if </span><span class="s5">'__pypy__' </span><span class="s0">in </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">builtin_module_names</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">os</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s5">&quot;win32&quot;</span><span class="s2">:</span>
                <span class="s3"># we need 'libpypy-c.lib'.  Current distributions of</span>
                <span class="s3"># pypy (&gt;= 4.1) contain it as 'libs/python27.lib'.</span>
                <span class="s1">pythonlib </span><span class="s2">= </span><span class="s5">&quot;python{0[0]}{0[1]}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">, </span><span class="s5">'prefix'</span><span class="s2">):</span>
                    <span class="s1">ensure</span><span class="s2">(</span><span class="s5">'library_dirs'</span><span class="s2">, </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">prefix</span><span class="s2">, </span><span class="s5">'libs'</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># we need 'libpypy-c.{so,dylib}', which should be by</span>
                <span class="s3"># default located in 'sys.prefix/bin' for installed</span>
                <span class="s3"># systems.</span>
                <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s6">3</span><span class="s2">,):</span>
                    <span class="s1">pythonlib </span><span class="s2">= </span><span class="s5">&quot;pypy-c&quot;</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">pythonlib </span><span class="s2">= </span><span class="s5">&quot;pypy3-c&quot;</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">, </span><span class="s5">'prefix'</span><span class="s2">):</span>
                    <span class="s1">ensure</span><span class="s2">(</span><span class="s5">'library_dirs'</span><span class="s2">, </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">prefix</span><span class="s2">, </span><span class="s5">'bin'</span><span class="s2">))</span>
            <span class="s3"># On uninstalled pypy's, the libpypy-c is typically found in</span>
            <span class="s3"># .../pypy/goal/.</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">, </span><span class="s5">'prefix'</span><span class="s2">):</span>
                <span class="s1">ensure</span><span class="s2">(</span><span class="s5">'library_dirs'</span><span class="s2">, </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">prefix</span><span class="s2">, </span><span class="s5">'pypy'</span><span class="s2">, </span><span class="s5">'goal'</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s5">&quot;win32&quot;</span><span class="s2">:</span>
                <span class="s1">template </span><span class="s2">= </span><span class="s5">&quot;python%d%d&quot;</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">, </span><span class="s5">'gettotalrefcount'</span><span class="s2">):</span>
                    <span class="s1">template </span><span class="s2">+= </span><span class="s5">'_d'</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s0">import </span><span class="s1">sysconfig</span>
                <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:    </span><span class="s3"># 2.6</span>
                    <span class="s0">from </span><span class="s1">cffi</span><span class="s2">.</span><span class="s1">_shimmed_dist_utils </span><span class="s0">import </span><span class="s1">sysconfig</span>
                <span class="s1">template </span><span class="s2">= </span><span class="s5">&quot;python%d.%d&quot;</span>
                <span class="s0">if </span><span class="s1">sysconfig</span><span class="s2">.</span><span class="s1">get_config_var</span><span class="s2">(</span><span class="s5">'DEBUG_EXT'</span><span class="s2">):</span>
                    <span class="s1">template </span><span class="s2">+= </span><span class="s1">sysconfig</span><span class="s2">.</span><span class="s1">get_config_var</span><span class="s2">(</span><span class="s5">'DEBUG_EXT'</span><span class="s2">)</span>
            <span class="s1">pythonlib </span><span class="s2">= (</span><span class="s1">template </span><span class="s2">%</span>
                    <span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">hexversion </span><span class="s2">&gt;&gt; </span><span class="s6">24</span><span class="s2">, (</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">hexversion </span><span class="s2">&gt;&gt; </span><span class="s6">16</span><span class="s2">) &amp; </span><span class="s6">0xff</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">, </span><span class="s5">'abiflags'</span><span class="s2">):</span>
                <span class="s1">pythonlib </span><span class="s2">+= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">abiflags</span>
        <span class="s1">ensure</span><span class="s2">(</span><span class="s5">'libraries'</span><span class="s2">, </span><span class="s1">pythonlib</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s5">&quot;win32&quot;</span><span class="s2">:</span>
            <span class="s1">ensure</span><span class="s2">(</span><span class="s5">'extra_link_args'</span><span class="s2">, </span><span class="s5">'/MANIFEST'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">set_source</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">=</span><span class="s5">'.c'</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
        <span class="s0">import </span><span class="s1">os</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">'_assigned_source'</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;set_source() cannot be called several times &quot;</span>
                             <span class="s5">&quot;per ffi object&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;'module_name' must be a string&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">os</span><span class="s2">.</span><span class="s1">sep </span><span class="s0">in </span><span class="s1">module_name </span><span class="s0">or </span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">altsep </span><span class="s0">and </span><span class="s1">os</span><span class="s2">.</span><span class="s1">altsep </span><span class="s0">in </span><span class="s1">module_name</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;'module_name' must not contain '/': use a dotted &quot;</span>
                             <span class="s5">&quot;name to make a 'package.module' location&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_assigned_source </span><span class="s2">= (</span><span class="s1">str</span><span class="s2">(</span><span class="s1">module_name</span><span class="s2">), </span><span class="s1">source</span><span class="s2">,</span>
                                 <span class="s1">source_extension</span><span class="s2">, </span><span class="s1">kwds</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">set_source_pkgconfig</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">pkgconfig_libs</span><span class="s2">, </span><span class="s1">source</span><span class="s2">,</span>
                             <span class="s1">source_extension</span><span class="s2">=</span><span class="s5">'.c'</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">pkgconfig</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">pkgconfig_libs</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;the pkgconfig_libs argument must be a list &quot;</span>
                            <span class="s5">&quot;of package names&quot;</span><span class="s2">)</span>
        <span class="s1">kwds2 </span><span class="s2">= </span><span class="s1">pkgconfig</span><span class="s2">.</span><span class="s1">flags_from_pkgconfig</span><span class="s2">(</span><span class="s1">pkgconfig_libs</span><span class="s2">)</span>
        <span class="s1">pkgconfig</span><span class="s2">.</span><span class="s1">merge_flags</span><span class="s2">(</span><span class="s1">kwds</span><span class="s2">, </span><span class="s1">kwds2</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_source</span><span class="s2">(</span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">distutils_extension</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">=</span><span class="s5">'build'</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">cffi</span><span class="s2">.</span><span class="s1">_shimmed_dist_utils </span><span class="s0">import </span><span class="s1">mkpath</span>
        <span class="s0">from </span><span class="s2">.</span><span class="s1">recompiler </span><span class="s0">import </span><span class="s1">recompile</span>
        <span class="s3">#</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">'_assigned_source'</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">'verifier'</span><span class="s2">):     </span><span class="s3"># fallback, 'tmpdir' ignored</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">verifier</span><span class="s2">.</span><span class="s1">get_extension</span><span class="s2">()</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;set_source() must be called before&quot;</span>
                             <span class="s5">&quot; distutils_extension()&quot;</span><span class="s2">)</span>
        <span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">, </span><span class="s1">kwds </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_assigned_source</span>
        <span class="s0">if </span><span class="s1">source </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;distutils_extension() is only for C extension &quot;</span>
                            <span class="s5">&quot;modules, not for dlopen()-style pure Python &quot;</span>
                            <span class="s5">&quot;modules&quot;</span><span class="s2">)</span>
        <span class="s1">mkpath</span><span class="s2">(</span><span class="s1">tmpdir</span><span class="s2">)</span>
        <span class="s1">ext</span><span class="s2">, </span><span class="s1">updated </span><span class="s2">= </span><span class="s1">recompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">,</span>
                                 <span class="s1">source</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">=</span><span class="s1">tmpdir</span><span class="s2">, </span><span class="s1">extradir</span><span class="s2">=</span><span class="s1">tmpdir</span><span class="s2">,</span>
                                 <span class="s1">source_extension</span><span class="s2">=</span><span class="s1">source_extension</span><span class="s2">,</span>
                                 <span class="s1">call_c_compiler</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">verbose</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">updated</span><span class="s2">:</span>
                <span class="s1">sys</span><span class="s2">.</span><span class="s1">stderr</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s5">&quot;regenerated: %r</span><span class="s0">\n</span><span class="s5">&quot; </span><span class="s2">% (</span><span class="s1">ext</span><span class="s2">.</span><span class="s1">sources</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">sys</span><span class="s2">.</span><span class="s1">stderr</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s5">&quot;not modified: %r</span><span class="s0">\n</span><span class="s5">&quot; </span><span class="s2">% (</span><span class="s1">ext</span><span class="s2">.</span><span class="s1">sources</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],))</span>
        <span class="s0">return </span><span class="s1">ext</span>

    <span class="s0">def </span><span class="s1">emit_c_code</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s2">.</span><span class="s1">recompiler </span><span class="s0">import </span><span class="s1">recompile</span>
        <span class="s3">#</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">'_assigned_source'</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;set_source() must be called before emit_c_code()&quot;</span><span class="s2">)</span>
        <span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">, </span><span class="s1">kwds </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_assigned_source</span>
        <span class="s0">if </span><span class="s1">source </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;emit_c_code() is only for C extension modules, &quot;</span>
                            <span class="s5">&quot;not for dlopen()-style pure Python modules&quot;</span><span class="s2">)</span>
        <span class="s1">recompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">,</span>
                  <span class="s1">c_file</span><span class="s2">=</span><span class="s1">filename</span><span class="s2">, </span><span class="s1">call_c_compiler</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">emit_python_code</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s2">.</span><span class="s1">recompiler </span><span class="s0">import </span><span class="s1">recompile</span>
        <span class="s3">#</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">'_assigned_source'</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;set_source() must be called before emit_c_code()&quot;</span><span class="s2">)</span>
        <span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">, </span><span class="s1">kwds </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_assigned_source</span>
        <span class="s0">if </span><span class="s1">source </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;emit_python_code() is only for dlopen()-style &quot;</span>
                            <span class="s5">&quot;pure Python modules, not for C extension modules&quot;</span><span class="s2">)</span>
        <span class="s1">recompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">,</span>
                  <span class="s1">c_file</span><span class="s2">=</span><span class="s1">filename</span><span class="s2">, </span><span class="s1">call_c_compiler</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">=</span><span class="s5">'.'</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">target</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;The 'target' argument gives the final file name of the 
        compiled DLL.  Use '*' to force distutils' choice, suitable for 
        regular CPython C API modules.  Use a file name ending in '.*' 
        to ask for the system's default extension for dynamic libraries 
        (.so/.dll/.dylib). 
 
        The default is '*' when building a non-embedded C API extension, 
        and (module_name + '.*') when building an embedded library. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s2">.</span><span class="s1">recompiler </span><span class="s0">import </span><span class="s1">recompile</span>
        <span class="s3">#</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">'_assigned_source'</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;set_source() must be called before compile()&quot;</span><span class="s2">)</span>
        <span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">, </span><span class="s1">kwds </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_assigned_source</span>
        <span class="s0">return </span><span class="s1">recompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">module_name</span><span class="s2">, </span><span class="s1">source</span><span class="s2">, </span><span class="s1">tmpdir</span><span class="s2">=</span><span class="s1">tmpdir</span><span class="s2">,</span>
                         <span class="s1">target</span><span class="s2">=</span><span class="s1">target</span><span class="s2">, </span><span class="s1">source_extension</span><span class="s2">=</span><span class="s1">source_extension</span><span class="s2">,</span>
                         <span class="s1">compiler_verbose</span><span class="s2">=</span><span class="s1">verbose</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">=</span><span class="s1">debug</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">init_once</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">):</span>
        <span class="s3"># Read _init_once_cache[tag], which is either (False, lock) if</span>
        <span class="s3"># we're calling the function now in some thread, or (True, result).</span>
        <span class="s3"># Don't call setdefault() in most cases, to avoid allocating and</span>
        <span class="s3"># immediately freeing a lock; but still use setdefaut() to avoid</span>
        <span class="s3"># races.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_init_once_cache</span><span class="s2">[</span><span class="s1">tag</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_init_once_cache</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">tag</span><span class="s2">, (</span><span class="s0">False</span><span class="s2">, </span><span class="s1">allocate_lock</span><span class="s2">()))</span>
        <span class="s3"># Common case: we got (True, result), so we return the result.</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
            <span class="s0">return </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s3"># Else, it's a lock.  Acquire it to serialize the following tests.</span>
        <span class="s0">with </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]:</span>
            <span class="s3"># Read again from _init_once_cache the current status.</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_init_once_cache</span><span class="s2">[</span><span class="s1">tag</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
                <span class="s0">return </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s3"># Call the function and store the result back.</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">func</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_init_once_cache</span><span class="s2">[</span><span class="s1">tag</span><span class="s2">] = (</span><span class="s0">True</span><span class="s2">, </span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">embedding_init_code</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pysource</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_embedding</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;embedding_init_code() can only be called once&quot;</span><span class="s2">)</span>
        <span class="s3"># fix 'pysource' before it gets dumped into the C file:</span>
        <span class="s3"># - remove empty lines at the beginning, so it starts at &quot;line 1&quot;</span>
        <span class="s3"># - dedent, if all non-empty lines are indented</span>
        <span class="s3"># - check for SyntaxErrors</span>
        <span class="s0">import </span><span class="s1">re</span>
        <span class="s1">match </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s5">r'\s*\n'</span><span class="s2">, </span><span class="s1">pysource</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">match</span><span class="s2">:</span>
            <span class="s1">pysource </span><span class="s2">= </span><span class="s1">pysource</span><span class="s2">[</span><span class="s1">match</span><span class="s2">.</span><span class="s1">end</span><span class="s2">():]</span>
        <span class="s1">lines </span><span class="s2">= </span><span class="s1">pysource</span><span class="s2">.</span><span class="s1">splitlines</span><span class="s2">() </span><span class="s0">or </span><span class="s2">[</span><span class="s5">''</span><span class="s2">]</span>
        <span class="s1">prefix </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s5">r'\s*'</span><span class="s2">, </span><span class="s1">lines</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]).</span><span class="s1">group</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lines</span><span class="s2">)):</span>
            <span class="s1">line </span><span class="s2">= </span><span class="s1">lines</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">line</span><span class="s2">.</span><span class="s1">rstrip</span><span class="s2">():</span>
                <span class="s0">while not </span><span class="s1">line</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s1">prefix</span><span class="s2">):</span>
                    <span class="s1">prefix </span><span class="s2">= </span><span class="s1">prefix</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">prefix</span><span class="s2">)</span>
        <span class="s1">lines </span><span class="s2">= [</span><span class="s1">line</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:]+</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">' </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines</span><span class="s2">]</span>
        <span class="s1">pysource </span><span class="s2">= </span><span class="s5">''</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">lines</span><span class="s2">)</span>
        <span class="s3">#</span>
        <span class="s1">compile</span><span class="s2">(</span><span class="s1">pysource</span><span class="s2">, </span><span class="s5">&quot;cffi_init&quot;</span><span class="s2">, </span><span class="s5">&quot;exec&quot;</span><span class="s2">)</span>
        <span class="s3">#</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_embedding </span><span class="s2">= </span><span class="s1">pysource</span>

    <span class="s0">def </span><span class="s1">def_extern</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;ffi.def_extern() is only available on API-mode FFI &quot;</span>
                         <span class="s5">&quot;objects&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">list_types</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns the user type names known to this FFI instance. 
        This returns a tuple containing three lists of names: 
        (typedef_names, names_of_structs, names_of_unions) 
        &quot;&quot;&quot;</span>
        <span class="s1">typedefs </span><span class="s2">= []</span>
        <span class="s1">structs </span><span class="s2">= []</span>
        <span class="s1">unions </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_declarations</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">key</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'typedef '</span><span class="s2">):</span>
                <span class="s1">typedefs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">key</span><span class="s2">[</span><span class="s6">8</span><span class="s2">:])</span>
            <span class="s0">elif </span><span class="s1">key</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'struct '</span><span class="s2">):</span>
                <span class="s1">structs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">key</span><span class="s2">[</span><span class="s6">7</span><span class="s2">:])</span>
            <span class="s0">elif </span><span class="s1">key</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'union '</span><span class="s2">):</span>
                <span class="s1">unions</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">key</span><span class="s2">[</span><span class="s6">6</span><span class="s2">:])</span>
        <span class="s1">typedefs</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
        <span class="s1">structs</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
        <span class="s1">unions</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">typedefs</span><span class="s2">, </span><span class="s1">structs</span><span class="s2">, </span><span class="s1">unions</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_load_backend_lib</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">):</span>
    <span class="s0">import </span><span class="s1">os</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">!= </span><span class="s5">&quot;win32&quot; </span><span class="s0">or </span><span class="s1">name </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">load_library</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">)</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s5">&quot;c&quot;    </span><span class="s3"># Windows: load_library(None) fails, but this works</span>
                      <span class="s3"># on Python 2 (backward compatibility hack only)</span>
    <span class="s1">first_error </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s5">'.' </span><span class="s0">in </span><span class="s1">name </span><span class="s0">or </span><span class="s5">'/' </span><span class="s0">in </span><span class="s1">name </span><span class="s0">or </span><span class="s1">os</span><span class="s2">.</span><span class="s1">sep </span><span class="s0">in </span><span class="s1">name</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">load_library</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">OSError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s1">first_error </span><span class="s2">= </span><span class="s1">e</span>
    <span class="s0">import </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">util</span>
    <span class="s1">path </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">find_library</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">path </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s5">&quot;c&quot; </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">== </span><span class="s5">&quot;win32&quot; </span><span class="s0">and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s6">3</span><span class="s2">,):</span>
            <span class="s0">raise </span><span class="s1">OSError</span><span class="s2">(</span><span class="s5">&quot;dlopen(None) cannot work on Windows for Python 3 &quot;</span>
                          <span class="s5">&quot;(see http://bugs.python.org/issue23606)&quot;</span><span class="s2">)</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s5">&quot;ctypes.util.find_library() did not manage &quot;</span>
               <span class="s5">&quot;to locate a library called %r&quot; </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">,))</span>
        <span class="s0">if </span><span class="s1">first_error </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;%s.  Additionally, %s&quot; </span><span class="s2">% (</span><span class="s1">first_error</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">OSError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">load_library</span><span class="s2">(</span><span class="s1">path</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">)</span>

<span class="s0">def </span><span class="s1">_make_ffi_library</span><span class="s2">(</span><span class="s1">ffi</span><span class="s2">, </span><span class="s1">libname</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">):</span>
    <span class="s1">backend </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_backend</span>
    <span class="s1">backendlib </span><span class="s2">= </span><span class="s1">_load_backend_lib</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s1">libname</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">)</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">accessor_function</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s5">'function ' </span><span class="s2">+ </span><span class="s1">name</span>
        <span class="s1">tp</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_declarations</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
        <span class="s1">BType </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">backendlib</span><span class="s2">.</span><span class="s1">load_function</span><span class="s2">(</span><span class="s1">BType</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">value</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">accessor_variable</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s5">'variable ' </span><span class="s2">+ </span><span class="s1">name</span>
        <span class="s1">tp</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_declarations</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
        <span class="s1">BType </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">)</span>
        <span class="s1">read_variable </span><span class="s2">= </span><span class="s1">backendlib</span><span class="s2">.</span><span class="s1">read_variable</span>
        <span class="s1">write_variable </span><span class="s2">= </span><span class="s1">backendlib</span><span class="s2">.</span><span class="s1">write_variable</span>
        <span class="s1">setattr</span><span class="s2">(</span><span class="s1">FFILibrary</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">property</span><span class="s2">(</span>
            <span class="s0">lambda </span><span class="s1">self</span><span class="s2">: </span><span class="s1">read_variable</span><span class="s2">(</span><span class="s1">BType</span><span class="s2">, </span><span class="s1">name</span><span class="s2">),</span>
            <span class="s0">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">write_variable</span><span class="s2">(</span><span class="s1">BType</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)))</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">addressof_var</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">addr_variables</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">addr_variables</span><span class="s2">:</span>
                    <span class="s1">key </span><span class="s2">= </span><span class="s5">'variable ' </span><span class="s2">+ </span><span class="s1">name</span>
                    <span class="s1">tp</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_declarations</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
                    <span class="s1">BType </span><span class="s2">= </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">BType</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s5">'array'</span><span class="s2">:</span>
                        <span class="s1">BType </span><span class="s2">= </span><span class="s1">model</span><span class="s2">.</span><span class="s1">pointer_cache</span><span class="s2">(</span><span class="s1">ffi</span><span class="s2">, </span><span class="s1">BType</span><span class="s2">)</span>
                    <span class="s1">p </span><span class="s2">= </span><span class="s1">backendlib</span><span class="s2">.</span><span class="s1">load_function</span><span class="s2">(</span><span class="s1">BType</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
                    <span class="s1">addr_variables</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">p</span>
            <span class="s0">return </span><span class="s1">addr_variables</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">accessor_constant</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;non-integer constant '%s' cannot be &quot;</span>
                                  <span class="s5">&quot;accessed from a dlopen() library&quot; </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">,))</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">accessor_int_constant</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_int_constants</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
    <span class="s3">#</span>
    <span class="s1">accessors </span><span class="s2">= {}</span>
    <span class="s1">accessors_version </span><span class="s2">= [</span><span class="s0">False</span><span class="s2">]</span>
    <span class="s1">addr_variables </span><span class="s2">= {}</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">update_accessors</span><span class="s2">():</span>
        <span class="s0">if </span><span class="s1">accessors_version</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">is </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_cdef_version</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s3">#</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s2">, (</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">_</span><span class="s2">) </span><span class="s0">in </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_declarations</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">model</span><span class="s2">.</span><span class="s1">EnumType</span><span class="s2">):</span>
                <span class="s1">tag</span><span class="s2">, </span><span class="s1">name </span><span class="s2">= </span><span class="s1">key</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">' '</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">tag </span><span class="s2">== </span><span class="s5">'function'</span><span class="s2">:</span>
                    <span class="s1">accessors</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">accessor_function</span>
                <span class="s0">elif </span><span class="s1">tag </span><span class="s2">== </span><span class="s5">'variable'</span><span class="s2">:</span>
                    <span class="s1">accessors</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">accessor_variable</span>
                <span class="s0">elif </span><span class="s1">tag </span><span class="s2">== </span><span class="s5">'constant'</span><span class="s2">:</span>
                    <span class="s1">accessors</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">accessor_constant</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">enumname </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">.</span><span class="s1">enumerators</span><span class="s2">):</span>
                    <span class="s0">def </span><span class="s1">accessor_enum</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">=</span><span class="s1">tp</span><span class="s2">, </span><span class="s1">i</span><span class="s2">=</span><span class="s1">i</span><span class="s2">):</span>
                        <span class="s1">tp</span><span class="s2">.</span><span class="s1">check_not_partial</span><span class="s2">()</span>
                        <span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">tp</span><span class="s2">.</span><span class="s1">enumvalues</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                    <span class="s1">accessors</span><span class="s2">[</span><span class="s1">enumname</span><span class="s2">] = </span><span class="s1">accessor_enum</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_parser</span><span class="s2">.</span><span class="s1">_int_constants</span><span class="s2">:</span>
            <span class="s1">accessors</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">accessor_int_constant</span><span class="s2">)</span>
        <span class="s1">accessors_version</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] = </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_cdef_version</span>
    <span class="s3">#</span>
    <span class="s0">def </span><span class="s1">make_accessor</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__ </span><span class="s0">or </span><span class="s1">name </span><span class="s0">in </span><span class="s1">FFILibrary</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s0">return    </span><span class="s3"># added by another thread while waiting for the lock</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">accessors</span><span class="s2">:</span>
                <span class="s1">update_accessors</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">accessors</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">accessors</span><span class="s2">[</span><span class="s1">name</span><span class="s2">](</span><span class="s1">name</span><span class="s2">)</span>
    <span class="s3">#</span>
    <span class="s0">class </span><span class="s1">FFILibrary</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
            <span class="s1">make_accessor</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">__setattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">property </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
                <span class="s1">make_accessor</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
                <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">property</span><span class="s2">.</span><span class="s1">__set__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">__dir__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
                <span class="s1">update_accessors</span><span class="s2">()</span>
                <span class="s0">return </span><span class="s1">accessors</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
        <span class="s0">def </span><span class="s1">__addressof__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">FFILibrary</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">addressof_var</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">make_accessor</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">FFILibrary</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">addressof_var</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s5">&quot;cffi library has no function or &quot;</span>
                                 <span class="s5">&quot;global variable named '%s'&quot; </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">,))</span>
        <span class="s0">def </span><span class="s1">__cffi_close__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">backendlib</span><span class="s2">.</span><span class="s1">close_lib</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
    <span class="s3">#</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">libname</span><span class="s2">, </span><span class="s1">basestring</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">libname</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):    </span><span class="s3"># unicode, on Python 2</span>
                <span class="s1">libname </span><span class="s2">= </span><span class="s1">libname</span><span class="s2">.</span><span class="s1">encode</span><span class="s2">(</span><span class="s5">'utf-8'</span><span class="s2">)</span>
            <span class="s1">FFILibrary</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s5">'FFILibrary_%s' </span><span class="s2">% </span><span class="s1">libname</span>
        <span class="s0">except </span><span class="s1">UnicodeError</span><span class="s2">:</span>
            <span class="s0">pass</span>
    <span class="s1">library </span><span class="s2">= </span><span class="s1">FFILibrary</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">library</span><span class="s2">, </span><span class="s1">library</span><span class="s2">.</span><span class="s1">__dict__</span>

<span class="s0">def </span><span class="s1">_builtin_function_type</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
    <span class="s3"># a hack to make at least ffi.typeof(builtin_function) work,</span>
    <span class="s3"># if the builtin function was obtained by 'vengine_cpy'.</span>
    <span class="s0">import </span><span class="s1">sys</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">module </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">[</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__module__</span><span class="s2">]</span>
        <span class="s1">ffi </span><span class="s2">= </span><span class="s1">module</span><span class="s2">.</span><span class="s1">_cffi_original_ffi</span>
        <span class="s1">types_of_builtin_funcs </span><span class="s2">= </span><span class="s1">module</span><span class="s2">.</span><span class="s1">_cffi_types_of_builtin_funcs</span>
        <span class="s1">tp </span><span class="s2">= </span><span class="s1">types_of_builtin_funcs</span><span class="s2">[</span><span class="s1">func</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">, </span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s0">return None</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">ffi</span><span class="s2">.</span><span class="s1">_get_cached_btype</span><span class="s2">(</span><span class="s1">tp</span><span class="s2">)</span>
</pre>
</body>
</html>