<html>
<head>
<title>exceptions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
exceptions.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Exceptions and Warnings (:mod:`numpy.exceptions`) 
================================================= 
 
General exceptions used by NumPy.  Note that some exceptions may be module 
specific, such as linear algebra errors. 
 
.. versionadded:: NumPy 1.25 
 
    The exceptions module is new in NumPy 1.25.  Older exceptions remain 
    available through the main NumPy namespace for compatibility. 
 
.. currentmodule:: numpy.exceptions 
 
Warnings 
-------- 
.. autosummary:: 
   :toctree: generated/ 
 
   ComplexWarning             Given when converting complex to real. 
   VisibleDeprecationWarning  Same as a DeprecationWarning, but more visible. 
 
Exceptions 
---------- 
.. autosummary:: 
   :toctree: generated/ 
 
    AxisError          Given when an axis was invalid. 
    DTypePromotionError   Given when no common dtype could be found. 
    TooHardError       Error specific to `numpy.shares_memory`. 
 
&quot;&quot;&quot;</span>


<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s3">&quot;ComplexWarning&quot;</span><span class="s2">, </span><span class="s3">&quot;VisibleDeprecationWarning&quot;</span><span class="s2">, </span><span class="s3">&quot;ModuleDeprecationWarning&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;TooHardError&quot;</span><span class="s2">, </span><span class="s3">&quot;AxisError&quot;</span><span class="s2">, </span><span class="s3">&quot;DTypePromotionError&quot;</span><span class="s2">]</span>


<span class="s4"># Disallow reloading this module so as to preserve the identities of the</span>
<span class="s4"># classes defined here.</span>
<span class="s5">if </span><span class="s3">'_is_loaded' </span><span class="s5">in </span><span class="s1">globals</span><span class="s2">():</span>
    <span class="s5">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">'Reloading numpy._globals is not allowed'</span><span class="s2">)</span>
<span class="s1">_is_loaded </span><span class="s2">= </span><span class="s5">True</span>


<span class="s5">class </span><span class="s1">ComplexWarning</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The warning raised when casting a complex dtype to a real dtype. 
 
    As implemented, casting a complex number to a real discards its imaginary 
    part, but this behavior may not be what the user actually wants. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">pass</span>


<span class="s5">class </span><span class="s1">ModuleDeprecationWarning</span><span class="s2">(</span><span class="s1">DeprecationWarning</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Module deprecation warning. 
 
    .. warning:: 
 
        This warning should not be used, since nose testing is not relevant 
        anymore. 
 
    The nose tester turns ordinary Deprecation warnings into test failures. 
    That makes it hard to deprecate whole modules, because they get 
    imported by default. So this is a special Deprecation warning that the 
    nose tester will let pass without making tests fail. 
 
    &quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">VisibleDeprecationWarning</span><span class="s2">(</span><span class="s1">UserWarning</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Visible deprecation warning. 
 
    By default, python will not show deprecation warnings, so this class 
    can be used when a very visible warning is helpful, for example because 
    the usage is most likely a user bug. 
 
    &quot;&quot;&quot;</span>


<span class="s4"># Exception used in shares_memory()</span>
<span class="s5">class </span><span class="s1">TooHardError</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;max_work was exceeded. 
 
    This is raised whenever the maximum number of candidate solutions 
    to consider specified by the ``max_work`` parameter is exceeded. 
    Assigning a finite number to max_work may have caused the operation 
    to fail. 
 
    &quot;&quot;&quot;</span>

    <span class="s5">pass</span>


<span class="s5">class </span><span class="s1">AxisError</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">IndexError</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Axis supplied was invalid. 
 
    This is raised whenever an ``axis`` parameter is specified that is larger 
    than the number of array dimensions. 
    For compatibility with code written against older numpy versions, which 
    raised a mixture of `ValueError` and `IndexError` for this situation, this 
    exception subclasses both to ensure that ``except ValueError`` and 
    ``except IndexError`` statements continue to catch `AxisError`. 
 
    .. versionadded:: 1.13 
 
    Parameters 
    ---------- 
    axis : int or str 
        The out of bounds axis or a custom exception message. 
        If an axis is provided, then `ndim` should be specified as well. 
    ndim : int, optional 
        The number of array dimensions. 
    msg_prefix : str, optional 
        A prefix for the exception message. 
 
    Attributes 
    ---------- 
    axis : int, optional 
        The out of bounds axis or ``None`` if a custom exception 
        message was provided. This should be the axis as passed by 
        the user, before any normalization to resolve negative indices. 
 
        .. versionadded:: 1.22 
    ndim : int, optional 
        The number of array dimensions or ``None`` if a custom exception 
        message was provided. 
 
        .. versionadded:: 1.22 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; array_1d = np.arange(10) 
    &gt;&gt;&gt; np.cumsum(array_1d, axis=1) 
    Traceback (most recent call last): 
      ... 
    numpy.exceptions.AxisError: axis 1 is out of bounds for array of dimension 1 
 
    Negative axes are preserved: 
 
    &gt;&gt;&gt; np.cumsum(array_1d, axis=-2) 
    Traceback (most recent call last): 
      ... 
    numpy.exceptions.AxisError: axis -2 is out of bounds for array of dimension 1 
 
    The class constructor generally takes the axis and arrays' 
    dimensionality as arguments: 
 
    &gt;&gt;&gt; print(np.AxisError(2, 1, msg_prefix='error')) 
    error: axis 2 is out of bounds for array of dimension 1 
 
    Alternatively, a custom exception message can be passed: 
 
    &gt;&gt;&gt; print(np.AxisError('Custom error message')) 
    Custom error message 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= (</span><span class="s3">&quot;axis&quot;</span><span class="s2">, </span><span class="s3">&quot;ndim&quot;</span><span class="s2">, </span><span class="s3">&quot;_msg&quot;</span><span class="s2">)</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">None</span><span class="s2">, </span><span class="s1">msg_prefix</span><span class="s2">=</span><span class="s5">None</span><span class="s2">):</span>
        <span class="s5">if </span><span class="s1">ndim </span><span class="s5">is </span><span class="s1">msg_prefix </span><span class="s5">is None</span><span class="s2">:</span>
            <span class="s4"># single-argument form: directly set the error message</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_msg </span><span class="s2">= </span><span class="s1">axis</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s5">None</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">= </span><span class="s5">None</span>
        <span class="s5">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_msg </span><span class="s2">= </span><span class="s1">msg_prefix</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axis</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">= </span><span class="s1">ndim</span>

    <span class="s5">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>

        <span class="s5">if </span><span class="s1">axis </span><span class="s5">is </span><span class="s1">ndim </span><span class="s5">is None</span><span class="s2">:</span>
            <span class="s5">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_msg</span>
        <span class="s5">else</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">f&quot;axis </span><span class="s5">{</span><span class="s1">axis</span><span class="s5">} </span><span class="s3">is out of bounds for array of dimension </span><span class="s5">{</span><span class="s1">ndim</span><span class="s5">}</span><span class="s3">&quot;</span>
            <span class="s5">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_msg </span><span class="s5">is not None</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_msg</span><span class="s5">}</span><span class="s3">: </span><span class="s5">{</span><span class="s1">msg</span><span class="s5">}</span><span class="s3">&quot;</span>
            <span class="s5">return </span><span class="s1">msg</span>


<span class="s5">class </span><span class="s1">DTypePromotionError</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Multiple DTypes could not be converted to a common one. 
 
    This exception derives from ``TypeError`` and is raised whenever dtypes 
    cannot be converted to a single common one.  This can be because they 
    are of a different category/class or incompatible instances of the same 
    one (see Examples). 
 
    Notes 
    ----- 
    Many functions will use promotion to find the correct result and 
    implementation.  For these functions the error will typically be chained 
    with a more specific error indicating that no implementation was found 
    for the input dtypes. 
 
    Typically promotion should be considered &quot;invalid&quot; between the dtypes of 
    two arrays when `arr1 == arr2` can safely return all ``False`` because the 
    dtypes are fundamentally different. 
 
    Examples 
    -------- 
    Datetimes and complex numbers are incompatible classes and cannot be 
    promoted: 
 
    &gt;&gt;&gt; np.result_type(np.dtype(&quot;M8[s]&quot;), np.complex128) 
    DTypePromotionError: The DType &lt;class 'numpy.dtype[datetime64]'&gt; could not 
    be promoted by &lt;class 'numpy.dtype[complex128]'&gt;. This means that no common 
    DType exists for the given inputs. For example they cannot be stored in a 
    single array unless the dtype is `object`. The full list of DTypes is: 
    (&lt;class 'numpy.dtype[datetime64]'&gt;, &lt;class 'numpy.dtype[complex128]'&gt;) 
 
    For example for structured dtypes, the structure can mismatch and the 
    same ``DTypePromotionError`` is given when two structured dtypes with 
    a mismatch in their number of fields is given: 
 
    &gt;&gt;&gt; dtype1 = np.dtype([(&quot;field1&quot;, np.float64), (&quot;field2&quot;, np.int64)]) 
    &gt;&gt;&gt; dtype2 = np.dtype([(&quot;field1&quot;, np.float64)]) 
    &gt;&gt;&gt; np.promote_types(dtype1, dtype2) 
    DTypePromotionError: field names `('field1', 'field2')` and `('field1',)` 
    mismatch. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">pass</span>
</pre>
</body>
</html>