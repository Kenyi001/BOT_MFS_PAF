<html>
<head>
<title>linalg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
linalg.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_dtypes </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">_floating_dtypes</span><span class="s2">,</span>
    <span class="s1">_numeric_dtypes</span><span class="s2">,</span>
    <span class="s1">float32</span><span class="s2">,</span>
    <span class="s1">float64</span><span class="s2">,</span>
    <span class="s1">complex64</span><span class="s2">,</span>
    <span class="s1">complex128</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_manipulation_functions </span><span class="s0">import </span><span class="s1">reshape</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_array_object </span><span class="s0">import </span><span class="s1">Array</span>

<span class="s0">from </span><span class="s2">..</span><span class="s1">core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s0">import </span><span class="s1">normalize_axis_tuple</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s1">Literal</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">, </span><span class="s1">Union</span><span class="s2">, </span><span class="s1">Dtype</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NamedTuple</span>

<span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">linalg</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">class </span><span class="s1">EighResult</span><span class="s2">(</span><span class="s1">NamedTuple</span><span class="s2">):</span>
    <span class="s1">eigenvalues</span><span class="s2">: </span><span class="s1">Array</span>
    <span class="s1">eigenvectors</span><span class="s2">: </span><span class="s1">Array</span>

<span class="s0">class </span><span class="s1">QRResult</span><span class="s2">(</span><span class="s1">NamedTuple</span><span class="s2">):</span>
    <span class="s1">Q</span><span class="s2">: </span><span class="s1">Array</span>
    <span class="s1">R</span><span class="s2">: </span><span class="s1">Array</span>

<span class="s0">class </span><span class="s1">SlogdetResult</span><span class="s2">(</span><span class="s1">NamedTuple</span><span class="s2">):</span>
    <span class="s1">sign</span><span class="s2">: </span><span class="s1">Array</span>
    <span class="s1">logabsdet</span><span class="s2">: </span><span class="s1">Array</span>

<span class="s0">class </span><span class="s1">SVDResult</span><span class="s2">(</span><span class="s1">NamedTuple</span><span class="s2">):</span>
    <span class="s1">U</span><span class="s2">: </span><span class="s1">Array</span>
    <span class="s1">S</span><span class="s2">: </span><span class="s1">Array</span>
    <span class="s1">Vh</span><span class="s2">: </span><span class="s1">Array</span>

<span class="s3"># Note: the inclusion of the upper keyword is different from</span>
<span class="s3"># np.linalg.cholesky, which does not have it.</span>
<span class="s0">def </span><span class="s1">cholesky</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">upper</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.cholesky &lt;numpy.linalg.cholesky&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.cholesky.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in cholesky'</span><span class="s2">)</span>
    <span class="s1">L </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">cholesky</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">upper</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">L</span><span class="s2">).</span><span class="s1">mT</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">L</span><span class="s2">)</span>

<span class="s3"># Note: cross is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">cross</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= -</span><span class="s6">1</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.cross &lt;numpy.cross&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only numeric dtypes are allowed in cross'</span><span class="s2">)</span>
    <span class="s3"># Note: this is different from np.cross(), which broadcasts</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'x1 and x2 must have the same shape'</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'cross() requires arrays of dimension at least 1'</span><span class="s2">)</span>
    <span class="s3"># Note: this is different from np.cross(), which allows dimension 2</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] != </span><span class="s6">3</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'cross() dimension must equal 3'</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cross</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">))</span>

<span class="s0">def </span><span class="s1">det</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.det &lt;numpy.linalg.det&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.det.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in det'</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">det</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">))</span>

<span class="s3"># Note: diagonal is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">diagonal</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">offset</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.diagonal &lt;numpy.diagonal&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: diagonal always operates on the last two axes, whereas np.diagonal</span>
    <span class="s3"># operates on the first two axes by default</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diagonal</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">axis1</span><span class="s2">=-</span><span class="s6">2</span><span class="s2">, </span><span class="s1">axis2</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">eigh</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; EighResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.eigh &lt;numpy.linalg.eigh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.eigh.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in eigh'</span><span class="s2">)</span>

    <span class="s3"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s3"># np.eigh, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">EighResult</span><span class="s2">(*</span><span class="s1">map</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">eigh</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">)))</span>


<span class="s0">def </span><span class="s1">eigvalsh</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.eigvalsh &lt;numpy.linalg.eigvalsh&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.eigvalsh.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in eigvalsh'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">eigvalsh</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">))</span>

<span class="s0">def </span><span class="s1">inv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.inv &lt;numpy.linalg.inv&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.inv.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in inv'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">inv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">))</span>


<span class="s3"># Note: matmul is the numpy top-level namespace but not in np.linalg</span>
<span class="s0">def </span><span class="s1">matmul</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.matmul &lt;numpy.matmul&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to numeric dtypes only is different from</span>
    <span class="s3"># np.matmul.</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only numeric dtypes are allowed in matmul'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">matmul</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">))</span>


<span class="s3"># Note: the name here is different from norm(). The array API norm is split</span>
<span class="s3"># into matrix_norm and vector_norm().</span>

<span class="s3"># The type for ord should be Optional[Union[int, float, Literal[np.inf,</span>
<span class="s3"># -np.inf, 'fro', 'nuc']]], but Literal does not support floating-point</span>
<span class="s3"># literals.</span>
<span class="s0">def </span><span class="s1">matrix_norm</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">keepdims</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">'fro'</span><span class="s2">, </span><span class="s5">'nuc'</span><span class="s2">]]] = </span><span class="s5">'fro'</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.norm &lt;numpy.linalg.norm&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.norm.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in matrix_norm'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=(-</span><span class="s6">2</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">), </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s1">keepdims</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">ord</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">matrix_power</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">n</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.matrix_power &lt;numpy.matrix_power&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.matrix_power.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed for the first argument of matrix_power'</span><span class="s2">)</span>

    <span class="s3"># np.matrix_power already checks if n is an integer</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_power</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>

<span class="s3"># Note: the keyword argument name rtol is different from np.linalg.matrix_rank</span>
<span class="s0">def </span><span class="s1">matrix_rank</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">rtol</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">]] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.matrix_rank &lt;numpy.matrix_rank&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: this is different from np.linalg.matrix_rank, which supports 1</span>
    <span class="s3"># dimensional arrays.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s5">&quot;1-dimensional array given. Array must be at least two-dimensional&quot;</span><span class="s2">)</span>
    <span class="s1">S </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">svd</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">compute_uv</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">S</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) * </span><span class="s1">max</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">:]) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">S</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">eps</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">):</span>
            <span class="s1">rtol </span><span class="s2">= </span><span class="s1">rtol</span><span class="s2">.</span><span class="s1">_array</span>
        <span class="s3"># Note: this is different from np.linalg.matrix_rank, which does not multiply</span>
        <span class="s3"># the tolerance by the largest singular value.</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">S</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">rtol</span><span class="s2">)[..., </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">S </span><span class="s2">&gt; </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">))</span>


<span class="s3"># Note: this function is new in the array API spec. Unlike transpose, it only</span>
<span class="s3"># transposes the last two axes.</span>
<span class="s0">def </span><span class="s1">matrix_transpose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;x must be at least 2-dimensional for matrix_transpose&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">2</span><span class="s2">))</span>

<span class="s3"># Note: outer is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">outer</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.outer &lt;numpy.outer&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to numeric dtypes only is different from</span>
    <span class="s3"># np.outer.</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only numeric dtypes are allowed in outer'</span><span class="s2">)</span>

    <span class="s3"># Note: the restriction to only 1-dim arrays is different from np.outer</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'The input arrays to outer must be 1-dimensional'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">outer</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">))</span>

<span class="s3"># Note: the keyword argument name rtol is different from np.linalg.pinv</span>
<span class="s0">def </span><span class="s1">pinv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">rtol</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">float</span><span class="s2">, </span><span class="s1">Array</span><span class="s2">]] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.pinv &lt;numpy.linalg.pinv&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.pinv.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in pinv'</span><span class="s2">)</span>

    <span class="s3"># Note: this is different from np.linalg.pinv, which does not multiply the</span>
    <span class="s3"># default tolerance by max(M, N).</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">rtol </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">:]) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">eps</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">pinv</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">))</span>

<span class="s0">def </span><span class="s1">qr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">'reduced'</span><span class="s2">, </span><span class="s5">'complete'</span><span class="s2">] = </span><span class="s5">'reduced'</span><span class="s2">) </span><span class="s1">-&gt; QRResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.qr &lt;numpy.linalg.qr&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.qr.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in qr'</span><span class="s2">)</span>

    <span class="s3"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s3"># np.linalg.qr, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">QRResult</span><span class="s2">(*</span><span class="s1">map</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">qr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s1">mode</span><span class="s2">)))</span>

<span class="s0">def </span><span class="s1">slogdet</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; SlogdetResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.slogdet &lt;numpy.linalg.slogdet&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.slogdet.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in slogdet'</span><span class="s2">)</span>

    <span class="s3"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s3"># np.linalg.slogdet, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">SlogdetResult</span><span class="s2">(*</span><span class="s1">map</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">slogdet</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">)))</span>

<span class="s3"># Note: unlike np.linalg.solve, the array API solve() only accepts x2 as a</span>
<span class="s3"># vector when it is exactly 1-dimensional. All other cases treat x2 as a stack</span>
<span class="s3"># of matrices. The np.linalg.solve behavior of allowing stacks of both</span>
<span class="s3"># matrices and vectors is ambiguous c.f.</span>
<span class="s3"># https://github.com/numpy/numpy/issues/15349 and</span>
<span class="s3"># https://github.com/data-apis/array-api/issues/285.</span>

<span class="s3"># To workaround this, the below is the code from np.linalg.solve except</span>
<span class="s3"># only calling solve1 in the exactly 1D case.</span>
<span class="s0">def </span><span class="s1">_solve</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s2">..</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">linalg </span><span class="s0">import </span><span class="s2">(</span><span class="s1">_makearray</span><span class="s2">, </span><span class="s1">_assert_stacked_2d</span><span class="s2">,</span>
                                 <span class="s1">_assert_stacked_square</span><span class="s2">, </span><span class="s1">_commonType</span><span class="s2">,</span>
                                 <span class="s1">isComplexType</span><span class="s2">, </span><span class="s1">get_linalg_error_extobj</span><span class="s2">,</span>
                                 <span class="s1">_raise_linalgerror_singular</span><span class="s2">)</span>
    <span class="s0">from </span><span class="s2">..</span><span class="s1">linalg </span><span class="s0">import </span><span class="s1">_umath_linalg</span>

    <span class="s1">a</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_makearray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">_assert_stacked_2d</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">_assert_stacked_square</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">b</span><span class="s2">, </span><span class="s1">wrap </span><span class="s2">= </span><span class="s1">_makearray</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">t</span><span class="s2">, </span><span class="s1">result_t </span><span class="s2">= </span><span class="s1">_commonType</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s3"># This part is different from np.linalg.solve</span>
    <span class="s0">if </span><span class="s1">b</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">gufunc </span><span class="s2">= </span><span class="s1">_umath_linalg</span><span class="s2">.</span><span class="s1">solve1</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">gufunc </span><span class="s2">= </span><span class="s1">_umath_linalg</span><span class="s2">.</span><span class="s1">solve</span>

    <span class="s3"># This does nothing currently but is left in because it will be relevant</span>
    <span class="s3"># when complex dtype support is added to the spec in 2022.</span>
    <span class="s1">signature </span><span class="s2">= </span><span class="s5">'DD-&gt;D' </span><span class="s0">if </span><span class="s1">isComplexType</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) </span><span class="s0">else </span><span class="s5">'dd-&gt;d'</span>
    <span class="s1">extobj </span><span class="s2">= </span><span class="s1">get_linalg_error_extobj</span><span class="s2">(</span><span class="s1">_raise_linalgerror_singular</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">gufunc</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">signature</span><span class="s2">=</span><span class="s1">signature</span><span class="s2">, </span><span class="s1">extobj</span><span class="s2">=</span><span class="s1">extobj</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">result_t</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">))</span>

<span class="s0">def </span><span class="s1">solve</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.solve &lt;numpy.linalg.solve&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.solve.</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in solve'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">_solve</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">))</span>

<span class="s0">def </span><span class="s1">svd</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">full_matrices</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; SVDResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.svd &lt;numpy.linalg.svd&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.svd.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in svd'</span><span class="s2">)</span>

    <span class="s3"># Note: the return type here is a namedtuple, which is different from</span>
    <span class="s3"># np.svd, which only returns a tuple.</span>
    <span class="s0">return </span><span class="s1">SVDResult</span><span class="s2">(*</span><span class="s1">map</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">svd</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">full_matrices</span><span class="s2">=</span><span class="s1">full_matrices</span><span class="s2">)))</span>

<span class="s3"># Note: svdvals is not in NumPy (but it is in SciPy). It is equivalent to</span>
<span class="s3"># np.linalg.svd(compute_uv=False).</span>
<span class="s0">def </span><span class="s1">svdvals</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /) </span><span class="s1">-&gt; Union</span><span class="s2">[</span><span class="s1">Array</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Array</span><span class="s2">, ...]]:</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in svdvals'</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">svd</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">compute_uv</span><span class="s2">=</span><span class="s0">False</span><span class="s2">))</span>

<span class="s3"># Note: tensordot is the numpy top-level namespace but not in np.linalg</span>

<span class="s3"># Note: axes must be a tuple, unlike np.tensordot where it can be an array or array-like.</span>
<span class="s0">def </span><span class="s1">tensordot</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">axes</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">int</span><span class="s2">], </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">int</span><span class="s2">]]] = </span><span class="s6">2</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s3"># Note: the restriction to numeric dtypes only is different from</span>
    <span class="s3"># np.tensordot.</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only numeric dtypes are allowed in tensordot'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">tensordot</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s1">axes</span><span class="s2">))</span>

<span class="s3"># Note: trace is the numpy top-level namespace, not np.linalg</span>
<span class="s0">def </span><span class="s1">trace</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">offset</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Dtype</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.trace &lt;numpy.trace&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only numeric dtypes are allowed in trace'</span><span class="s2">)</span>

    <span class="s3"># Note: trace() works the same as sum() and prod() (see</span>
    <span class="s3"># _statistical_functions.py)</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">float32</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">float64</span>
        <span class="s0">elif </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">complex64</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">complex128</span>
    <span class="s3"># Note: trace always operates on the last two axes, whereas np.trace</span>
    <span class="s3"># operates on the first two axes by default</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">trace</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">axis1</span><span class="s2">=-</span><span class="s6">2</span><span class="s2">, </span><span class="s1">axis2</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)))</span>

<span class="s3"># Note: vecdot is not in NumPy</span>
<span class="s0">def </span><span class="s1">vecdot</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= -</span><span class="s6">1</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes </span><span class="s0">or </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_numeric_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only numeric dtypes are allowed in vecdot'</span><span class="s2">)</span>
    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
    <span class="s1">x1_shape </span><span class="s2">= (</span><span class="s6">1</span><span class="s2">,)*(</span><span class="s1">ndim </span><span class="s2">- </span><span class="s1">x1</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">) + </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">x2_shape </span><span class="s2">= (</span><span class="s6">1</span><span class="s2">,)*(</span><span class="s1">ndim </span><span class="s2">- </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">) + </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x1_shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] != </span><span class="s1">x2_shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;x1 and x2 must have the same size along the given axis&quot;</span><span class="s2">)</span>

    <span class="s1">x1_</span><span class="s2">, </span><span class="s1">x2_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">.</span><span class="s1">_array</span><span class="s2">)</span>
    <span class="s1">x1_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">x1_</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">x2_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">x2_</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">x1_</span><span class="s2">[..., </span><span class="s0">None</span><span class="s2">, :] @ </span><span class="s1">x2_</span><span class="s2">[..., </span><span class="s0">None</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">res</span><span class="s2">[..., </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">])</span>


<span class="s3"># Note: the name here is different from norm(). The array API norm is split</span>
<span class="s3"># into matrix_norm and vector_norm().</span>

<span class="s3"># The type for ord should be Optional[Union[int, float, Literal[np.inf,</span>
<span class="s3"># -np.inf]]] but Literal does not support floating-point literals.</span>
<span class="s0">def </span><span class="s1">vector_norm</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">Array</span><span class="s2">, /, *, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, ...]]] = </span><span class="s0">None</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">]] = </span><span class="s6">2</span><span class="s2">) </span><span class="s1">-&gt; Array</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Array API compatible wrapper for :py:func:`np.linalg.norm &lt;numpy.linalg.norm&gt;`. 
 
    See its docstring for more information. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Note: the restriction to floating-point dtypes only is different from</span>
    <span class="s3"># np.linalg.norm.</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">not in </span><span class="s1">_floating_dtypes</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">'Only floating-point dtypes are allowed in norm'</span><span class="s2">)</span>

    <span class="s3"># np.linalg.norm tries to do a matrix norm whenever axis is a 2-tuple or</span>
    <span class="s3"># when axis=None and the input is 2-D, so to force a vector norm, we make</span>
    <span class="s3"># it so the input is 1-D (for axis=None), or reshape so that norm is done</span>
    <span class="s3"># on a single dimension.</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">_array</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s3"># Note: np.linalg.norm() doesn't handle 0-D arrays</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s1">_axis </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s3"># Note: The axis argument supports any number of axes, whereas</span>
        <span class="s3"># np.linalg.norm() only supports a single axis for vector norm.</span>
        <span class="s1">normalized_axis </span><span class="s2">= </span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">rest </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">normalized_axis</span><span class="s2">)</span>
        <span class="s1">newshape </span><span class="s2">= </span><span class="s1">axis </span><span class="s2">+ </span><span class="s1">rest</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">newshape</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">([</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axis</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">), *[</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rest</span><span class="s2">]))</span>
        <span class="s1">_axis </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">_axis </span><span class="s2">= </span><span class="s1">axis</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">_new</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">_axis</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">ord</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">keepdims</span><span class="s2">:</span>
        <span class="s3"># We can't reuse np.linalg.norm(keepdims) because of the reshape hacks</span>
        <span class="s3"># above to avoid matrix norm logic.</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">_axis </span><span class="s2">= </span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">) </span><span class="s0">if </span><span class="s1">axis </span><span class="s0">is None else </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">_axis</span><span class="s2">:</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s6">1</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">))</span>

    <span class="s0">return </span><span class="s1">res</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s5">'cholesky'</span><span class="s2">, </span><span class="s5">'cross'</span><span class="s2">, </span><span class="s5">'det'</span><span class="s2">, </span><span class="s5">'diagonal'</span><span class="s2">, </span><span class="s5">'eigh'</span><span class="s2">, </span><span class="s5">'eigvalsh'</span><span class="s2">, </span><span class="s5">'inv'</span><span class="s2">, </span><span class="s5">'matmul'</span><span class="s2">, </span><span class="s5">'matrix_norm'</span><span class="s2">, </span><span class="s5">'matrix_power'</span><span class="s2">, </span><span class="s5">'matrix_rank'</span><span class="s2">, </span><span class="s5">'matrix_transpose'</span><span class="s2">, </span><span class="s5">'outer'</span><span class="s2">, </span><span class="s5">'pinv'</span><span class="s2">, </span><span class="s5">'qr'</span><span class="s2">, </span><span class="s5">'slogdet'</span><span class="s2">, </span><span class="s5">'solve'</span><span class="s2">, </span><span class="s5">'svd'</span><span class="s2">, </span><span class="s5">'svdvals'</span><span class="s2">, </span><span class="s5">'tensordot'</span><span class="s2">, </span><span class="s5">'trace'</span><span class="s2">, </span><span class="s5">'vecdot'</span><span class="s2">, </span><span class="s5">'vector_norm'</span><span class="s2">]</span>
</pre>
</body>
</html>