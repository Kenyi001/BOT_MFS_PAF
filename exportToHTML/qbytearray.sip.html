<html>
<head>
<title>qbytearray.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qbytearray.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qbytearray.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtCore Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">%ModuleCode</span>
<span class="s0">#include &lt;qbytearray.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">class QByteArray /TypeHintIn=&quot;Union[QByteArray, bytes, bytearray]&quot;/</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qbytearray.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">%TypeCode</span>
<span class="s0">// This is needed by __hash__().</span>
<span class="s0">#include &lt;qhash.h&gt;</span>


<span class="s0">// Convenience function for converting a QByteArray to a Python str object.</span>
<span class="s0">static PyObject *QByteArrayToPyStr(QByteArray *ba)</span>
<span class="s0">{</span>
    <span class="s0">char *data = ba-&gt;data();</span>

    <span class="s0">if (data)</span>
        <span class="s0">// QByteArrays may have embedded '\0's so set the size explicitly.    </span>
        <span class="s0">return SIPBytes_FromStringAndSize(data, ba-&gt;size());</span>

    <span class="s0">return SIPBytes_FromString(&quot;&quot;);</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">%ConvertToTypeCode</span>
<span class="s0">// We have to be very careful about what we allow to be converted to a</span>
<span class="s0">// QByteArray and to a QString as we need to take into account the v1 and v2</span>
<span class="s0">// APIs and Python v2.x and v3.x.</span>
<span class="s0">//</span>
<span class="s0">// QSvgRenderer() is a good example of what needs to work &quot;naturally&quot;.  This</span>
<span class="s0">// has a ctor that takes a QString argument that is the name of the SVG file.</span>
<span class="s0">// It has another ctor that takes a QByteArray argument that is the SVG data.</span>
<span class="s0">//</span>
<span class="s0">// In Python v2.x we want a str object to be interpreted as the name of the</span>
<span class="s0">// file (as that is the historical behaviour).  This has the following</span>
<span class="s0">// implications.</span>
<span class="s0">//</span>
<span class="s0">// - The QString version of the ctor must appear before the QByteArray version</span>
<span class="s0">//   in the .sip file.  This rule should be applied wherever a similar</span>
<span class="s0">//   situation arises.</span>
<span class="s0">// - A QString must not automatically convert a QByteArray.</span>
<span class="s0">// - QByteArray must also exist in the v2 API.</span>
<span class="s0">//</span>
<span class="s0">// In Python v3.x we want a bytes object to be used wherever a QByteArray is</span>
<span class="s0">// expected.  This means that a QString must not automatically convert a bytes</span>
<span class="s0">// object.</span>
<span class="s0">//</span>
<span class="s0">// In PyQt v5.4 and earlier a QByteArray could be created from a Latin-1</span>
<span class="s0">// encoded string.  This was a mistaken attempt to ease the porting of Python2</span>
<span class="s0">// code to Python3.</span>

<span class="s0">if (sipIsErr == NULL)</span>
    <span class="s0">return (PyByteArray_Check(sipPy) || SIPBytes_Check(sipPy) ||</span>
            <span class="s0">sipCanConvertToType(sipPy, sipType_QByteArray, SIP_NO_CONVERTORS));</span>

<span class="s0">if (PyByteArray_Check(sipPy))</span>
<span class="s0">{</span>
    <span class="s0">*sipCppPtr = new QByteArray(PyByteArray_AsString(sipPy),</span>
            <span class="s0">PyByteArray_Size(sipPy));</span>

    <span class="s0">return sipGetState(sipTransferObj);</span>
<span class="s0">}</span>

<span class="s0">if (SIPBytes_Check(sipPy))</span>
<span class="s0">{</span>
    <span class="s0">*sipCppPtr = new QByteArray(SIPBytes_AsString(sipPy),</span>
            <span class="s0">SIPBytes_Size(sipPy));</span>

    <span class="s0">return sipGetState(sipTransferObj);</span>
<span class="s0">}</span>

<span class="s0">*sipCppPtr = reinterpret_cast&lt;QByteArray *&gt;(sipConvertToType(sipPy,</span>
        <span class="s0">sipType_QByteArray, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));</span>

<span class="s0">return 0;</span>
<span class="s0">%End</span>

<span class="s0">%BIGetBufferCode</span>
    <span class="s0">#if defined(Py_LIMITED_API)</span>
        <span class="s0">Q_UNUSED(sipSelf);</span>
    
        <span class="s0">sipBuffer-&gt;bd_buffer = sipCpp-&gt;data();</span>
        <span class="s0">sipBuffer-&gt;bd_length = sipCpp-&gt;size();</span>
        <span class="s0">sipBuffer-&gt;bd_readonly = 0;</span>
        <span class="s0">sipRes = 0;</span>
    <span class="s0">#else</span>
        <span class="s0">sipRes = PyBuffer_FillInfo(sipBuffer, sipSelf, sipCpp-&gt;data(),</span>
                <span class="s0">sipCpp-&gt;size(), 0, sipFlags);</span>
    <span class="s0">#endif</span>
<span class="s0">%End</span>

<span class="s0">%BIGetReadBufferCode</span>
    <span class="s0">if (sipSegment != 0)</span>
    <span class="s0">{</span>
        <span class="s0">PyErr_SetString(PyExc_SystemError, &quot;accessing non-existent QByteArray segment&quot;);</span>
        <span class="s0">sipRes = -1;</span>
    <span class="s0">}</span>
    <span class="s0">else</span>
    <span class="s0">{</span>
        <span class="s0">*sipPtrPtr = (void *)sipCpp-&gt;data();</span>
        <span class="s0">sipRes = sipCpp-&gt;size();</span>
    <span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">%BIGetSegCountCode</span>
    <span class="s0">if (sipLenPtr)</span>
        <span class="s0">*sipLenPtr = sipCpp-&gt;size();</span>
    
    <span class="s0">sipRes = 1;</span>
<span class="s0">%End</span>

<span class="s0">%BIGetCharBufferCode</span>
    <span class="s0">if (sipSegment != 0)</span>
    <span class="s0">{</span>
        <span class="s0">PyErr_SetString(PyExc_SystemError, &quot;accessing non-existent QByteArray segment&quot;);</span>
        <span class="s0">sipRes = -1;</span>
    <span class="s0">}</span>
    <span class="s0">else</span>
    <span class="s0">{</span>
        <span class="s0">*sipPtrPtr = (void *)sipCpp-&gt;data();</span>
        <span class="s0">sipRes = sipCpp-&gt;size();</span>
    <span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">%PickleCode</span>
    <span class="s0">#if PY_MAJOR_VERSION &gt;= 3</span>
    <span class="s0">sipRes = Py_BuildValue((char *)&quot;(y#)&quot;, sipCpp-&gt;data(), static_cast&lt;Py_ssize_t&gt;(sipCpp-&gt;size()));</span>
    <span class="s0">#else</span>
    <span class="s0">sipRes = Py_BuildValue((char *)&quot;(s#)&quot;, sipCpp-&gt;data(), static_cast&lt;Py_ssize_t&gt;(sipCpp-&gt;size()));</span>
    <span class="s0">#endif</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QByteArray();</span>
    <span class="s0">QByteArray(int size, char c);</span>
    <span class="s0">QByteArray(const QByteArray &amp;a);</span>
    <span class="s0">~QByteArray();</span>
    <span class="s0">void resize(int size);</span>
    <span class="s0">QByteArray &amp;fill(char ch, int size = -1);</span>
    <span class="s0">void clear();</span>
    <span class="s0">int indexOf(const QByteArray &amp;ba, int from = 0) const;</span>
    <span class="s0">int indexOf(const QString &amp;str, int from = 0) const;</span>
    <span class="s0">int lastIndexOf(const QByteArray &amp;ba, int from = -1) const;</span>
    <span class="s0">int lastIndexOf(const QString &amp;str, int from = -1) const;</span>
    <span class="s0">int count(const QByteArray &amp;a) const;</span>
    <span class="s0">QByteArray left(int len) const;</span>
    <span class="s0">QByteArray right(int len) const;</span>
    <span class="s0">QByteArray mid(int pos, int length = -1) const;</span>
    <span class="s0">bool startsWith(const QByteArray &amp;a) const;</span>
    <span class="s0">bool endsWith(const QByteArray &amp;a) const;</span>
    <span class="s0">void truncate(int pos);</span>
    <span class="s0">void chop(int n);</span>
    <span class="s0">QByteArray toLower() const;</span>
    <span class="s0">QByteArray toUpper() const;</span>
    <span class="s0">QByteArray trimmed() const;</span>
    <span class="s0">QByteArray simplified() const;</span>
    <span class="s0">QByteArray leftJustified(int width, char fill = ' ', bool truncate = false) const;</span>
    <span class="s0">QByteArray rightJustified(int width, char fill = ' ', bool truncate = false) const;</span>
    <span class="s0">QByteArray &amp;prepend(const QByteArray &amp;a);</span>
    <span class="s0">QByteArray &amp;append(const QByteArray &amp;a);</span>
    <span class="s0">QByteArray &amp;append(const QString &amp;s);</span>
    <span class="s0">QByteArray &amp;insert(int i, const QByteArray &amp;a);</span>
    <span class="s0">QByteArray &amp;insert(int i, const QString &amp;s);</span>
    <span class="s0">QByteArray &amp;remove(int index, int len);</span>
    <span class="s0">QByteArray &amp;replace(int index, int len, const QByteArray &amp;s);</span>
    <span class="s0">QByteArray &amp;replace(const QByteArray &amp;before, const QByteArray &amp;after);</span>
    <span class="s0">QByteArray &amp;replace(const QString &amp;before, const QByteArray &amp;after);</span>
    <span class="s0">QList&lt;QByteArray&gt; split(char sep) const;</span>
    <span class="s0">QByteArray &amp;operator+=(const QByteArray &amp;a);</span>
    <span class="s0">QByteArray &amp;operator+=(const QString &amp;s);</span>
    <span class="s0">bool operator==(const QString &amp;s2) const;</span>
    <span class="s0">bool operator!=(const QString &amp;s2) const;</span>
    <span class="s0">bool operator&lt;(const QString &amp;s2) const;</span>
    <span class="s0">bool operator&gt;(const QString &amp;s2) const;</span>
    <span class="s0">bool operator&lt;=(const QString &amp;s2) const;</span>
    <span class="s0">bool operator&gt;=(const QString &amp;s2) const;</span>
    <span class="s0">short toShort(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">ushort toUShort(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">int toInt(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">uint toUInt(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">long toLong(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">ulong toULong(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">qlonglong toLongLong(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">qulonglong toULongLong(bool *ok = 0, int base = 10) const;</span>
    <span class="s0">float toFloat(bool *ok = 0) const;</span>
    <span class="s0">double toDouble(bool *ok = 0) const;</span>
    <span class="s0">QByteArray toBase64() const;</span>
    <span class="s0">QByteArray &amp;setNum(double n /Constrained/, char format = 'g', int precision = 6);</span>
    <span class="s0">QByteArray &amp;setNum(SIP_PYOBJECT n /TypeHint=&quot;int&quot;/, int base = 10);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">#if PY_MAJOR_VERSION &lt; 3</span>
        <span class="s0">if (PyInt_Check(a0))</span>
        <span class="s0">{</span>
            <span class="s0">qlonglong val = PyInt_AsLong(a0);</span>
        
            <span class="s0">sipRes = &amp;sipCpp-&gt;setNum(val, a1);</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
        <span class="s0">#endif</span>
        <span class="s0">{</span>
            <span class="s0">qlonglong val = sipLong_AsLongLong(a0);</span>
        
            <span class="s0">if (!PyErr_Occurred())</span>
            <span class="s0">{</span>
                <span class="s0">sipRes = &amp;sipCpp-&gt;setNum(val, a1);</span>
            <span class="s0">}</span>
            <span class="s0">else</span>
            <span class="s0">{</span>
                <span class="s0">// If it is positive then it might fit an unsigned long long.</span>
        
                <span class="s0">qulonglong uval = sipLong_AsUnsignedLongLong(a0);</span>
        
                <span class="s0">if (!PyErr_Occurred())</span>
                <span class="s0">{</span>
                    <span class="s0">sipRes = &amp;sipCpp-&gt;setNum(uval, a1);</span>
                <span class="s0">}</span>
                <span class="s0">else</span>
                <span class="s0">{</span>
                    <span class="s0">sipError = (PyErr_ExceptionMatches(PyExc_OverflowError)</span>
                            <span class="s0">? sipErrorFail : sipErrorContinue);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">static QByteArray number(double n /Constrained/, char format = 'g', int precision = 6);</span>
    <span class="s0">static QByteArray number(SIP_PYOBJECT n /TypeHint=&quot;int&quot;/, int base = 10);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">#if PY_MAJOR_VERSION &lt; 3</span>
        <span class="s0">if (PyInt_Check(a0))</span>
        <span class="s0">{</span>
            <span class="s0">qlonglong val = PyInt_AsLong(a0);</span>
        
            <span class="s0">sipRes = new QByteArray(QByteArray::number(val, a1));</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
        <span class="s0">#endif</span>
        <span class="s0">{</span>
            <span class="s0">qlonglong val = sipLong_AsLongLong(a0);</span>
        
            <span class="s0">if (!PyErr_Occurred())</span>
            <span class="s0">{</span>
                <span class="s0">sipRes = new QByteArray(QByteArray::number(val, a1));</span>
            <span class="s0">}</span>
            <span class="s0">else</span>
            <span class="s0">{</span>
                <span class="s0">// If it is positive then it might fit an unsigned long long.</span>
        
                <span class="s0">qulonglong uval = sipLong_AsUnsignedLongLong(a0);</span>
        
                <span class="s0">if (!PyErr_Occurred())</span>
                <span class="s0">{</span>
                    <span class="s0">sipRes = new QByteArray(QByteArray::number(uval, a1));</span>
                <span class="s0">}</span>
                <span class="s0">else</span>
                <span class="s0">{</span>
                    <span class="s0">sipError = (PyErr_ExceptionMatches(PyExc_OverflowError)</span>
                            <span class="s0">? sipErrorFail : sipErrorContinue);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">static QByteArray fromBase64(const QByteArray &amp;base64);</span>
    <span class="s0">static QByteArray fromRawData(const char * /Array/, int size /ArraySize/);</span>
    <span class="s0">static QByteArray fromHex(const QByteArray &amp;hexEncoded);</span>
    <span class="s0">int count() const /__len__/;</span>
    <span class="s0">int length() const;</span>
    <span class="s0">bool isNull() const;</span>
    <span class="s0">int size() const;</span>
    <span class="s0">char at(int i) const /Encoding=&quot;None&quot;/;</span>
    <span class="s0">char operator[](int i) const /Encoding=&quot;None&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">Py_ssize_t idx = sipConvertFromSequenceIndex(a0, sipCpp-&gt;count());</span>
        
        <span class="s0">if (idx &lt; 0)</span>
            <span class="s0">sipIsErr = 1;</span>
        <span class="s0">else</span>
            <span class="s0">sipRes = sipCpp-&gt;operator[]((int)idx);</span>
<span class="s0">%End</span>

    <span class="s0">QByteArray operator[](SIP_PYSLICE slice) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">Py_ssize_t start, stop, step, slicelength;</span>
        
        <span class="s0">if (sipConvertFromSliceObject(a0, sipCpp-&gt;length(), &amp;start, &amp;stop, &amp;step, &amp;slicelength) &lt; 0)</span>
        <span class="s0">{</span>
            <span class="s0">sipIsErr = 1;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
        <span class="s0">{</span>
            <span class="s0">sipRes = new QByteArray();</span>
        
            <span class="s0">for (Py_ssize_t i = 0; i &lt; slicelength; ++i)</span>
            <span class="s0">{</span>
                <span class="s0">sipRes -&gt; append(sipCpp-&gt;at(start));</span>
                <span class="s0">start += step;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">int __contains__(const QByteArray &amp;a) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// It looks like you can't assign QBool to int.</span>
        <span class="s0">sipRes = bool(sipCpp-&gt;contains(*a0));</span>
<span class="s0">%End</span>

    <span class="s0">long __hash__() const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qHash(*sipCpp);</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYOBJECT __str__() const /TypeHint=&quot;str&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = QByteArrayToPyStr(sipCpp);</span>
        
        <span class="s0">#if PY_MAJOR_VERSION &gt;= 3</span>
        <span class="s0">PyObject *repr = PyObject_Repr(sipRes);</span>
        
        <span class="s0">if (repr)</span>
        <span class="s0">{</span>
            <span class="s0">Py_DECREF(sipRes);</span>
            <span class="s0">sipRes = repr;</span>
        <span class="s0">}</span>
        <span class="s0">#endif</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYOBJECT __repr__() const /TypeHint=&quot;str&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">if (sipCpp-&gt;isNull())</span>
        <span class="s0">{</span>
        <span class="s0">#if PY_MAJOR_VERSION &gt;= 3</span>
            <span class="s0">sipRes = PyUnicode_FromString(&quot;PyQt5.QtCore.QByteArray()&quot;);</span>
        <span class="s0">#else</span>
            <span class="s0">sipRes = PyString_FromString(&quot;PyQt5.QtCore.QByteArray()&quot;);</span>
        <span class="s0">#endif</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
        <span class="s0">{</span>
            <span class="s0">PyObject *str = QByteArrayToPyStr(sipCpp);</span>
        
            <span class="s0">if (str)</span>
            <span class="s0">{</span>
        <span class="s0">#if PY_MAJOR_VERSION &gt;= 3</span>
                <span class="s0">sipRes = PyUnicode_FromFormat(&quot;PyQt5.QtCore.QByteArray(%R)&quot;, str);</span>
        <span class="s0">#else</span>
                <span class="s0">sipRes = PyString_FromString(&quot;PyQt5.QtCore.QByteArray(&quot;);</span>
                <span class="s0">PyString_ConcatAndDel(&amp;sipRes, PyObject_Repr(str));</span>
                <span class="s0">PyString_ConcatAndDel(&amp;sipRes, PyString_FromString(&quot;)&quot;));</span>
        <span class="s0">#endif</span>
        
                <span class="s0">Py_DECREF(str);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">QByteArray operator*(int m) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = new QByteArray();</span>
        
        <span class="s0">while (a0-- &gt; 0)</span>
            <span class="s0">*sipRes += *sipCpp;</span>
<span class="s0">%End</span>

    <span class="s0">QByteArray &amp;operator*=(int m);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QByteArray orig(*sipCpp);</span>
        
        <span class="s0">sipCpp-&gt;clear();</span>
        
        <span class="s0">while (a0-- &gt; 0)</span>
            <span class="s0">*sipCpp += orig;</span>
<span class="s0">%End</span>

    <span class="s0">bool isEmpty() const;</span>
    <span class="s0">SIP_PYOBJECT data() /TypeHint=&quot;Py_v3:bytes;str&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// QByteArrays may contain embedded '\0's so set the size explicitly.</span>
        
        <span class="s0">char *res = sipCpp-&gt;data();</span>
        <span class="s0">int len = sipCpp-&gt;size();</span>
        
        <span class="s0">if (res)</span>
        <span class="s0">{</span>
            <span class="s0">if ((sipRes = SIPBytes_FromStringAndSize(res, len)) == NULL)</span>
                <span class="s0">sipIsErr = 1;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
        <span class="s0">{</span>
            <span class="s0">Py_INCREF(Py_None);</span>
            <span class="s0">sipRes = Py_None;</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">int capacity() const;</span>
    <span class="s0">void reserve(int size);</span>
    <span class="s0">void squeeze();</span>
    <span class="s0">void push_back(const QByteArray &amp;a);</span>
    <span class="s0">void push_front(const QByteArray &amp;a);</span>
    <span class="s0">bool contains(const QByteArray &amp;a) const;</span>
    <span class="s0">QByteArray toHex() const;</span>
    <span class="s0">QByteArray toPercentEncoding(const QByteArray &amp;exclude = QByteArray(), const QByteArray &amp;include = QByteArray(), char percent = '%') const;</span>
    <span class="s0">static QByteArray fromPercentEncoding(const QByteArray &amp;input, char percent = '%');</span>
    <span class="s0">QByteArray repeated(int times) const;</span>
    <span class="s0">void swap(QByteArray &amp;other /Constrained/);</span>
<span class="s0">%If (Qt_5_2_0 -)</span>

    <span class="s0">enum Base64Option</span>
    <span class="s0">{</span>
        <span class="s0">Base64Encoding,</span>
        <span class="s0">Base64UrlEncoding,</span>
        <span class="s0">KeepTrailingEquals,</span>
        <span class="s0">OmitTrailingEquals,</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
        <span class="s0">IgnoreBase64DecodingErrors,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
        <span class="s0">AbortOnBase64DecodingErrors,</span>
<span class="s0">%End</span>
    <span class="s0">};</span>

<span class="s0">%End</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
    <span class="s0">typedef QFlags&lt;QByteArray::Base64Option&gt; Base64Options;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
    <span class="s0">QByteArray toBase64(QByteArray::Base64Options options) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
    <span class="s0">static QByteArray fromBase64(const QByteArray &amp;base64, QByteArray::Base64Options options);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_7_0 -)</span>
    <span class="s0">QByteArray &amp;prepend(int count, char c /Encoding=&quot;None&quot;/);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_7_0 -)</span>
    <span class="s0">QByteArray &amp;append(int count, char c /Encoding=&quot;None&quot;/);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_7_0 -)</span>
    <span class="s0">QByteArray &amp;insert(int i, int count, char c /Encoding=&quot;None&quot;/);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">QByteArray toHex(char separator) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_10_0 -)</span>
    <span class="s0">QByteArray chopped(int len) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
    <span class="s0">int compare(const QByteArray &amp;a, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
    <span class="s0">bool isUpper() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
    <span class="s0">bool isLower() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>

    <span class="s0">enum class Base64DecodingStatus</span>
    <span class="s0">{</span>
        <span class="s0">Ok,</span>
        <span class="s0">IllegalInputLength,</span>
        <span class="s0">IllegalCharacter,</span>
        <span class="s0">IllegalPadding,</span>
    <span class="s0">};</span>

<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
    <span class="s0">static QByteArray::FromBase64Result fromBase64Encoding(const QByteArray &amp;base64, QByteArray::Base64Options options = QByteArray::Base64Encoding);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>

    <span class="s0">class FromBase64Result</span>
    <span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qbytearray.h&gt;</span>
<span class="s0">%End</span>

    <span class="s0">public:</span>
        <span class="s0">QByteArray decoded;</span>
        <span class="s0">QByteArray::Base64DecodingStatus decodingStatus;</span>
        <span class="s0">void swap(QByteArray::FromBase64Result &amp;other /Constrained/);</span>
        <span class="s0">operator bool() const;</span>
<span class="s0">%MethodCode</span>
            <span class="s0">// This is required because SIP doesn't handle operator bool() properly.</span>
            <span class="s0">sipRes = sipCpp-&gt;operator bool();</span>
<span class="s0">%End</span>

        <span class="s0">long __hash__() const;</span>
<span class="s0">%MethodCode</span>
            <span class="s0">sipRes = qHash(*sipCpp);</span>
<span class="s0">%End</span>
    <span class="s0">};</span>

<span class="s0">%End</span>
<span class="s0">};</span>

<span class="s0">bool operator==(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">bool operator!=(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">bool operator&lt;(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">bool operator&lt;=(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">bool operator&gt;(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">bool operator&gt;=(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">const QByteArray operator+(const QByteArray &amp;a1, const QByteArray &amp;a2);</span>
<span class="s0">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;, const QByteArray &amp; /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;, QByteArray &amp; /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QByteArray qCompress(const QByteArray &amp;data, int compressionLevel = -1);</span>
<span class="s0">QByteArray qUncompress(const QByteArray &amp;data);</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
<span class="s0">QFlags&lt;QByteArray::Base64Option&gt; operator|(QByteArray::Base64Option f1, QFlags&lt;QByteArray::Base64Option&gt; f2);</span>
<span class="s0">%End</span>
<span class="s0">quint16 qChecksum(const char *s /Array/, uint len /ArraySize/);</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
<span class="s0">quint16 qChecksum(const char *s /Array/, uint len /ArraySize/, Qt::ChecksumType standard);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
<span class="s0">bool operator==(const QByteArray::FromBase64Result &amp;lhs, const QByteArray::FromBase64Result &amp;rhs);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
<span class="s0">bool operator!=(const QByteArray::FromBase64Result &amp;lhs, const QByteArray::FromBase64Result &amp;rhs);</span>
<span class="s0">%End</span>
</pre>
</body>
</html>