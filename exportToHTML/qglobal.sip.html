<html>
<head>
<title>qglobal.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qglobal.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qglobal.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtCore Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">%ModuleCode</span>
<span class="s0">#include &lt;qglobal.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">// PyQt version information.</span>
<span class="s0">int PYQT_VERSION;</span>
<span class="s0">const char *PYQT_VERSION_STR;</span>

<span class="s0">%ModuleCode</span>
<span class="s0">static int PYQT_VERSION = 0x050f0a;</span>
<span class="s0">static const char *PYQT_VERSION_STR = &quot;5.15.10&quot;;</span>
<span class="s0">%End</span>
<span class="s0">const int QT_VERSION;</span>
<span class="s0">const char *QT_VERSION_STR;</span>
<span class="s0">typedef signed char qint8 /PyInt/;</span>
<span class="s0">typedef unsigned char quint8 /PyInt/;</span>
<span class="s0">typedef short qint16;</span>
<span class="s0">typedef unsigned short quint16;</span>
<span class="s0">typedef int qint32;</span>
<span class="s0">typedef unsigned int quint32;</span>
<span class="s0">typedef long long qint64;</span>
<span class="s0">typedef unsigned long long quint64;</span>
<span class="s0">typedef qint64 qlonglong;</span>
<span class="s0">typedef quint64 qulonglong;</span>
<span class="s0">%If (PyQt_qreal_double)</span>
<span class="s0">typedef double qreal;</span>
<span class="s0">%End</span>
<span class="s0">%If (!PyQt_qreal_double)</span>
<span class="s0">typedef float qreal;</span>
<span class="s0">%End</span>
<span class="s0">typedef unsigned char uchar;</span>
<span class="s0">typedef unsigned short ushort;</span>
<span class="s0">typedef unsigned int uint;</span>
<span class="s0">typedef unsigned long ulong;</span>
<span class="s0">double qAbs(const double &amp;t);</span>
<span class="s0">int qRound(qreal d);</span>
<span class="s0">qint64 qRound64(qreal d);</span>
<span class="s0">const char *qVersion();</span>
<span class="s0">bool qSharedBuild();</span>
<span class="s0">// Template definition for QFlags.</span>
<span class="s0">template&lt;ENUM&gt;</span>
<span class="s0">class QFlags /NoDefaultCtors, PyQtFlagsEnums=&quot;ENUM&quot;, TypeHintIn=&quot;Union[QFlags, ENUM]&quot;/</span>
<span class="s0">{</span>
<span class="s0">public:</span>
    <span class="s0">// QFlags is supposed to be a more type safe version of an int (even though</span>
    <span class="s0">// Qt has cases where it expects multiple flag types to be or-ed together).</span>
    <span class="s0">// Because of the C++ int() operator and because type(ENUM) is a sub-type</span>
    <span class="s0">// of int, most of this is lost.  Therefore we only implement logical</span>
    <span class="s0">// operators that take int arguments.</span>
    <span class="s0">QFlags();</span>
    <span class="s0">QFlags(int f /TypeHint=&quot;QFlags&quot;/);</span>

    <span class="s0">// This will never be called because the above ctor will be invoked first.</span>
    <span class="s0">// However it's required for sip to generate assignment helpers.</span>
    <span class="s0">QFlags(const QFlags &amp;) /NoTypeHint/;</span>

    <span class="s0">operator int() const;</span>

    <span class="s0">// This is required for Python v3.8 and later.</span>
    <span class="s0">int __index__() const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = sipCpp-&gt;operator QFlags::Int();</span>
<span class="s0">%End</span>

    <span class="s0">QFlags operator~() const;</span>

    <span class="s0">QFlags operator&amp;(int f /TypeHint=&quot;QFlags&quot;/) const;</span>
    <span class="s0">QFlags &amp;operator&amp;=(int f /TypeHint=&quot;QFlags&quot;/);</span>

    <span class="s0">QFlags operator|(int f /TypeHint=&quot;QFlags&quot;/) const;</span>
    <span class="s0">QFlags &amp;operator|=(int f /TypeHint=&quot;QFlags&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">*sipCpp = QFlags(*sipCpp | a0);</span>
<span class="s0">%End</span>

    <span class="s0">QFlags operator^(int f /TypeHint=&quot;QFlags&quot;/) const;</span>
    <span class="s0">QFlags &amp;operator^=(int f /TypeHint=&quot;QFlags&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">*sipCpp = QFlags(*sipCpp ^ a0);</span>
<span class="s0">%End</span>

    <span class="s0">// These are necessary to prevent Python comparing object IDs.</span>
    <span class="s0">bool operator==(const QFlags &amp;f) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = (sipCpp-&gt;operator QFlags::Int() == a0-&gt;operator QFlags::Int());</span>
<span class="s0">%End</span>

    <span class="s0">bool operator!=(const QFlags &amp;f) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = (sipCpp-&gt;operator QFlags::Int() != a0-&gt;operator QFlags::Int());</span>
<span class="s0">%End</span>

    <span class="s0">int __bool__() const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = (sipCpp-&gt;operator QFlags::Int() != 0);</span>
<span class="s0">%End</span>

    <span class="s0">long __hash__() const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = sipCpp-&gt;operator QFlags::Int();</span>
<span class="s0">%End</span>


<span class="s0">%ConvertToTypeCode</span>
<span class="s0">// Allow an instance of the base enum whenever a QFlags is expected.</span>

<span class="s0">if (sipIsErr == NULL)</span>
    <span class="s0">return (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_ENUM)) ||</span>
            <span class="s0">sipCanConvertToType(sipPy, sipType_QFlags, SIP_NO_CONVERTORS));</span>

<span class="s0">if (PyObject_TypeCheck(sipPy, sipTypeAsPyTypeObject(sipType_ENUM)))</span>
<span class="s0">{</span>
    <span class="s0">*sipCppPtr = new QFlags(int(SIPLong_AsLong(sipPy)));</span>

    <span class="s0">return sipGetState(sipTransferObj);</span>
<span class="s0">}</span>

<span class="s0">*sipCppPtr = reinterpret_cast&lt;QFlags *&gt;(sipConvertToType(sipPy, sipType_QFlags, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));</span>

<span class="s0">return 0;</span>
<span class="s0">%End</span>
<span class="s0">};</span>
<span class="s0">// Hook's into Qt's resource system.</span>
<span class="s0">%ModuleCode</span>
<span class="s0">QT_BEGIN_NAMESPACE</span>
<span class="s0">extern bool qRegisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);</span>
<span class="s0">extern bool qUnregisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);</span>
<span class="s0">QT_END_NAMESPACE</span>
<span class="s0">%End</span>

<span class="s0">bool qRegisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);</span>
<span class="s0">bool qUnregisterResourceData(int, const unsigned char *, const unsigned char *, const unsigned char *);</span>
<span class="s0">bool qFuzzyCompare(double p1, double p2);</span>
<span class="s0">bool qIsNull(double d);</span>
<span class="s0">void qsrand(uint seed);</span>
<span class="s0">int qrand();</span>
<span class="s0">typedef void *QFunctionPointer;</span>
<span class="s0">// Mapped type for qintptr.</span>
<span class="s0">// Map qintptr onto sip.voidptr.  This means either an address (on Windows) or</span>
<span class="s0">// an integer file descriptor (on everything else) can be used.</span>
<span class="s0">%MappedType qintptr /TypeHint=&quot;PyQt5.sip.voidptr&quot;/</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;QtGlobal&gt;</span>
<span class="s0">%End</span>

<span class="s0">%ConvertToTypeCode</span>
    <span class="s0">qintptr ptr = (qintptr)sipConvertToVoidPtr(sipPy);</span>

    <span class="s0">if (!sipIsErr)</span>
        <span class="s0">return !PyErr_Occurred();</span>

    <span class="s0">// Mapped types deal with pointers, so create one on the heap.</span>
    <span class="s0">qintptr *heap = new qintptr;</span>
    <span class="s0">*heap = ptr;</span>

    <span class="s0">*sipCppPtr = heap;</span>

    <span class="s0">// Make sure the pointer doesn't leak.</span>
    <span class="s0">return SIP_TEMPORARY;</span>
<span class="s0">%End</span>

<span class="s0">%ConvertFromTypeCode</span>
    <span class="s0">return sipConvertFromVoidPtr((void *)*sipCpp);</span>
<span class="s0">%End</span>
<span class="s0">};</span>
<span class="s0">// Mapped type for quintptr.</span>
<span class="s0">// Map quintptr onto sip.voidptr.  This means either an address (on Windows) or</span>
<span class="s0">// an integer file descriptor (on everything else) can be used.</span>
<span class="s0">%MappedType quintptr /TypeHint=&quot;PyQt5.sip.voidptr&quot;/</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;QtGlobal&gt;</span>
<span class="s0">%End</span>

<span class="s0">%ConvertToTypeCode</span>
    <span class="s0">quintptr ptr = (quintptr)sipConvertToVoidPtr(sipPy);</span>

    <span class="s0">if (!sipIsErr)</span>
        <span class="s0">return !PyErr_Occurred();</span>

    <span class="s0">// Mapped types deal with pointers, so create one on the heap.</span>
    <span class="s0">quintptr *heap = new quintptr;</span>
    <span class="s0">*heap = ptr;</span>

    <span class="s0">*sipCppPtr = heap;</span>

    <span class="s0">// Make sure the pointer doesn't leak.</span>
    <span class="s0">return SIP_TEMPORARY;</span>
<span class="s0">%End</span>

<span class="s0">%ConvertFromTypeCode</span>
    <span class="s0">return sipConvertFromVoidPtr((void *)*sipCpp);</span>
<span class="s0">%End</span>
<span class="s0">};</span>
<span class="s0">// Implementations of pyqt[Set]PickleProtocol().</span>
<span class="s0">void pyqtSetPickleProtocol(SIP_PYOBJECT /TypeHint=&quot;Optional[int]&quot;/);</span>
<span class="s0">%MethodCode</span>
    <span class="s0">Py_XDECREF(qpycore_pickle_protocol);</span>
    <span class="s0">qpycore_pickle_protocol = a0;</span>
    <span class="s0">Py_INCREF(qpycore_pickle_protocol);</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT pyqtPickleProtocol() /TypeHint=&quot;Optional[int]&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">sipRes = qpycore_pickle_protocol;</span>
    <span class="s0">if (!sipRes)</span>
        <span class="s0">sipRes = Py_None;</span>
    
    <span class="s0">Py_INCREF(sipRes);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_10_0 -)</span>
<span class="s0">QString qEnvironmentVariable(const char *varName);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_10_0 -)</span>
<span class="s0">QString qEnvironmentVariable(const char *varName, const QString &amp;defaultValue);</span>
<span class="s0">%End</span>
</pre>
</body>
</html>