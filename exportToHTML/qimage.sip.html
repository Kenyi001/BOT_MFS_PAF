<html>
<head>
<title>qimage.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qimage.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qimage.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtGui Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">class QImage : QPaintDevice</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qimage.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">enum InvertMode</span>
    <span class="s0">{</span>
        <span class="s0">InvertRgb,</span>
        <span class="s0">InvertRgba,</span>
    <span class="s0">};</span>

    <span class="s0">enum Format</span>
    <span class="s0">{</span>
        <span class="s0">Format_Invalid,</span>
        <span class="s0">Format_Mono,</span>
        <span class="s0">Format_MonoLSB,</span>
        <span class="s0">Format_Indexed8,</span>
        <span class="s0">Format_RGB32,</span>
        <span class="s0">Format_ARGB32,</span>
        <span class="s0">Format_ARGB32_Premultiplied,</span>
        <span class="s0">Format_RGB16,</span>
        <span class="s0">Format_ARGB8565_Premultiplied,</span>
        <span class="s0">Format_RGB666,</span>
        <span class="s0">Format_ARGB6666_Premultiplied,</span>
        <span class="s0">Format_RGB555,</span>
        <span class="s0">Format_ARGB8555_Premultiplied,</span>
        <span class="s0">Format_RGB888,</span>
        <span class="s0">Format_RGB444,</span>
        <span class="s0">Format_ARGB4444_Premultiplied,</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
        <span class="s0">Format_RGBX8888,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
        <span class="s0">Format_RGBA8888,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_2_0 -)</span>
        <span class="s0">Format_RGBA8888_Premultiplied,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
        <span class="s0">Format_BGR30,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
        <span class="s0">Format_A2BGR30_Premultiplied,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
        <span class="s0">Format_RGB30,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
        <span class="s0">Format_A2RGB30_Premultiplied,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_5_0 -)</span>
        <span class="s0">Format_Alpha8,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_5_0 -)</span>
        <span class="s0">Format_Grayscale8,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
        <span class="s0">Format_RGBX64,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
        <span class="s0">Format_RGBA64,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
        <span class="s0">Format_RGBA64_Premultiplied,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_13_0 -)</span>
        <span class="s0">Format_Grayscale16,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_14_0 -)</span>
        <span class="s0">Format_BGR888,</span>
<span class="s0">%End</span>
    <span class="s0">};</span>

    <span class="s0">QImage();</span>
    <span class="s0">QImage(const QSize &amp;size, QImage::Format format);</span>
    <span class="s0">QImage(int width, int height, QImage::Format format);</span>
    <span class="s0">QImage(const uchar *data /KeepReference/, int width, int height, QImage::Format format);</span>
    <span class="s0">QImage(void *data, int width, int height, QImage::Format format) [(uchar *data, int width, int height, QImage::Format format)];</span>
    <span class="s0">QImage(const uchar *data /KeepReference/, int width, int height, int bytesPerLine, QImage::Format format);</span>
    <span class="s0">QImage(void *data, int width, int height, int bytesPerLine, QImage::Format format) [(uchar *data, int width, int height, int bytesPerLine, QImage::Format format)];</span>
    <span class="s0">explicit QImage(SIP_PYLIST xpm /TypeHint=&quot;List[str]&quot;/) [(const char **xpm)];</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// The Python interface is a list of strings that make up the image.</span>
        
        <span class="s0">const char **str = QtGui_ListToArray(a0);</span>
        
        <span class="s0">if (str)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp = new sipQImage(str);</span>
            <span class="s0">QtGui_DeleteArray(str);</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">QImage(const QString &amp;fileName, const char *format = 0) /ReleaseGIL/;</span>
    <span class="s0">QImage(const QImage &amp;);</span>
    <span class="s0">QImage(const QVariant &amp;variant /GetWrapper/) /NoDerived/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">if (a0-&gt;canConvert&lt;QImage&gt;())</span>
            <span class="s0">sipCpp = new sipQImage(a0-&gt;value&lt;QImage&gt;());</span>
        <span class="s0">else</span>
            <span class="s0">sipError = sipBadCallableArg(0, a0Wrapper);</span>
<span class="s0">%End</span>

    <span class="s0">virtual ~QImage();</span>
    <span class="s0">bool isNull() const;</span>
    <span class="s0">virtual int devType() const;</span>
    <span class="s0">bool operator==(const QImage &amp;) const;</span>
    <span class="s0">bool operator!=(const QImage &amp;) const;</span>
    <span class="s0">void detach();</span>
    <span class="s0">bool isDetached() const;</span>
    <span class="s0">QImage copy(const QRect &amp;rect = QRect()) const;</span>
    <span class="s0">QImage copy(int x, int y, int w, int h) const;</span>
    <span class="s0">QImage::Format format() const;</span>
    <span class="s0">QImage convertToFormat(QImage::Format f, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor) const;</span>
    <span class="s0">QImage convertToFormat(QImage::Format f, const QVector&lt;unsigned int&gt; &amp;colorTable, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor) const;</span>
    <span class="s0">int width() const;</span>
    <span class="s0">int height() const;</span>
    <span class="s0">QSize size() const;</span>
    <span class="s0">QRect rect() const;</span>
    <span class="s0">int depth() const;</span>
    <span class="s0">QRgb color(int i) const;</span>
    <span class="s0">void setColor(int i, QRgb c);</span>
    <span class="s0">bool allGray() const;</span>
    <span class="s0">bool isGrayscale() const;</span>
    <span class="s0">void *bits() [uchar * ()];</span>
    <span class="s0">const void *constBits() const [const uchar * ()];</span>
    <span class="s0">void *scanLine(int) [uchar * (int)];</span>
    <span class="s0">const void *constScanLine(int) const [const uchar * (int)];</span>
    <span class="s0">int bytesPerLine() const;</span>
    <span class="s0">bool valid(const QPoint &amp;pt) const;</span>
    <span class="s0">bool valid(int x, int y) const;</span>
    <span class="s0">int pixelIndex(const QPoint &amp;pt) const;</span>
    <span class="s0">int pixelIndex(int x, int y) const;</span>
    <span class="s0">QRgb pixel(const QPoint &amp;pt) const;</span>
    <span class="s0">QRgb pixel(int x, int y) const;</span>
    <span class="s0">void setPixel(const QPoint &amp;pt, uint index_or_rgb);</span>
    <span class="s0">void setPixel(int x, int y, uint index_or_rgb);</span>
    <span class="s0">QVector&lt;unsigned int&gt; colorTable() const;</span>
    <span class="s0">void setColorTable(const QVector&lt;unsigned int&gt; colors);</span>
    <span class="s0">void fill(Qt::GlobalColor color /Constrained/);</span>
    <span class="s0">void fill(const QColor &amp;color);</span>
    <span class="s0">void fill(uint pixel);</span>
    <span class="s0">bool hasAlphaChannel() const;</span>
    <span class="s0">void setAlphaChannel(const QImage &amp;alphaChannel);</span>
    <span class="s0">QImage createAlphaMask(Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor) const;</span>
    <span class="s0">QImage createHeuristicMask(bool clipTight = true) const;</span>
    <span class="s0">QImage scaled(int width, int height, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const;</span>
    <span class="s0">QImage scaled(const QSize &amp;size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) const;</span>
    <span class="s0">QImage scaledToWidth(int width, Qt::TransformationMode mode = Qt::FastTransformation) const;</span>
    <span class="s0">QImage scaledToHeight(int height, Qt::TransformationMode mode = Qt::FastTransformation) const;</span>
    <span class="s0">QImage mirrored(bool horizontal = false, bool vertical = true) const;</span>
    <span class="s0">QImage rgbSwapped() const;</span>
    <span class="s0">void invertPixels(QImage::InvertMode mode = QImage::InvertRgb);</span>
    <span class="s0">bool load(QIODevice *device, const char *format) /ReleaseGIL/;</span>
    <span class="s0">bool load(const QString &amp;fileName, const char *format = 0) /ReleaseGIL/;</span>
    <span class="s0">bool loadFromData(const uchar *data /Array/, int len /ArraySize/, const char *format = 0);</span>
    <span class="s0">bool loadFromData(const QByteArray &amp;data, const char *format = 0);</span>
    <span class="s0">bool save(const QString &amp;fileName, const char *format = 0, int quality = -1) const /ReleaseGIL/;</span>
    <span class="s0">bool save(QIODevice *device, const char *format = 0, int quality = -1) const /ReleaseGIL/;</span>
    <span class="s0">static QImage fromData(const uchar *data /Array/, int size /ArraySize/, const char *format = 0);</span>
    <span class="s0">static QImage fromData(const QByteArray &amp;data, const char *format = 0);</span>
    <span class="s0">virtual QPaintEngine *paintEngine() const;</span>
    <span class="s0">int dotsPerMeterX() const;</span>
    <span class="s0">int dotsPerMeterY() const;</span>
    <span class="s0">void setDotsPerMeterX(int);</span>
    <span class="s0">void setDotsPerMeterY(int);</span>
    <span class="s0">QPoint offset() const;</span>
    <span class="s0">void setOffset(const QPoint &amp;);</span>
    <span class="s0">QStringList textKeys() const;</span>
    <span class="s0">QString text(const QString &amp;key = QString()) const;</span>
    <span class="s0">void setText(const QString &amp;key, const QString &amp;value);</span>

<span class="s0">protected:</span>
    <span class="s0">virtual int metric(QPaintDevice::PaintDeviceMetric metric) const;</span>
<span class="s0">%If (Qt_5_5_0 -)</span>
    <span class="s0">QImage smoothScaled(int w, int h) const;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QImage createMaskFromColor(QRgb color, Qt::MaskMode mode = Qt::MaskInColor) const;</span>
    <span class="s0">QImage transformed(const QTransform &amp;matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;</span>
    <span class="s0">static QTransform trueMatrix(const QTransform &amp;, int w, int h);</span>
    <span class="s0">qint64 cacheKey() const;</span>
    <span class="s0">int colorCount() const;</span>
    <span class="s0">void setColorCount(int);</span>
    <span class="s0">int byteCount() const;</span>
    <span class="s0">int bitPlaneCount() const;</span>
    <span class="s0">void swap(QImage &amp;other /Constrained/);</span>
    <span class="s0">qreal devicePixelRatio() const;</span>
    <span class="s0">void setDevicePixelRatio(qreal scaleFactor);</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
    <span class="s0">QPixelFormat pixelFormat() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
    <span class="s0">static QPixelFormat toPixelFormat(QImage::Format format);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
    <span class="s0">static QImage::Format toImageFormat(QPixelFormat format);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_6_0 -)</span>
    <span class="s0">QColor pixelColor(int x, int y) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_6_0 -)</span>
    <span class="s0">QColor pixelColor(const QPoint &amp;pt) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_6_0 -)</span>
    <span class="s0">void setPixelColor(int x, int y, const QColor &amp;c);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_6_0 -)</span>
    <span class="s0">void setPixelColor(const QPoint &amp;pt, const QColor &amp;c);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">bool reinterpretAsFormat(QImage::Format f);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_10_0 -)</span>
    <span class="s0">Py_ssize_t sizeInBytes() const [qsizetype ()];</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_13_0 -)</span>
    <span class="s0">void convertTo(QImage::Format f, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_14_0 -)</span>
    <span class="s0">QColorSpace colorSpace() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_14_0 -)</span>
    <span class="s0">QImage convertedToColorSpace(const QColorSpace &amp;) const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_14_0 -)</span>
    <span class="s0">void convertToColorSpace(const QColorSpace &amp;);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_14_0 -)</span>
    <span class="s0">void setColorSpace(const QColorSpace &amp;);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_14_0 -)</span>
    <span class="s0">void applyColorTransform(const QColorTransform &amp;transform);</span>
<span class="s0">%End</span>
<span class="s0">};</span>

<span class="s0">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;, const QImage &amp; /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;, QImage &amp; /Constrained/) /ReleaseGIL/;</span>

<span class="s0">%ModuleHeaderCode</span>
<span class="s0">const char **QtGui_ListToArray(PyObject *lst);</span>
<span class="s0">void QtGui_DeleteArray(const char **arr);</span>
<span class="s0">%End</span>

<span class="s0">%ModuleCode</span>
<span class="s0">// Convert a list of strings to an array of ASCII strings on the heap.  Used by</span>
<span class="s0">// QImage and QPixmap.</span>
<span class="s0">const char **QtGui_ListToArray(PyObject *lst)</span>
<span class="s0">{</span>
    <span class="s0">Py_ssize_t nstr = PyList_Size(lst);</span>
    <span class="s0">const char **arr = new const char *[nstr + 1];</span>

    <span class="s0">for (Py_ssize_t i = 0; i &lt; nstr; ++i)</span>
    <span class="s0">{</span>
        <span class="s0">PyObject *ascii_obj = PyList_GetItem(lst, i);</span>
        <span class="s0">const char *ascii = sipString_AsASCIIString(&amp;ascii_obj);</span>

        <span class="s0">if (!ascii)</span>
        <span class="s0">{</span>
            <span class="s0">while (i-- &gt; 0)</span>
                <span class="s0">delete[] arr[i];</span>

            <span class="s0">delete[] arr;</span>

            <span class="s0">return 0;</span>
        <span class="s0">}</span>

        <span class="s0">// Copy the string.</span>
        <span class="s0">arr[i] = qstrdup(ascii);</span>

        <span class="s0">Py_DECREF(ascii_obj);</span>
    <span class="s0">}</span>

    <span class="s0">// The sentinal.</span>
    <span class="s0">arr[nstr] = 0;</span>

    <span class="s0">return arr;</span>
<span class="s0">}</span>


<span class="s0">// Return a string array created by QtGui_ListToArray() to the heap.</span>
<span class="s0">void QtGui_DeleteArray(const char **arr)</span>
<span class="s0">{</span>
    <span class="s0">for (Py_ssize_t i = 0; arr[i]; ++i)</span>
        <span class="s0">delete[] arr[i];</span>

    <span class="s0">delete[] arr;</span>
<span class="s0">}</span>
<span class="s0">%End</span>
</pre>
</body>
</html>