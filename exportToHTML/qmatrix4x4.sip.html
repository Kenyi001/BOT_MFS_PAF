<html>
<head>
<title>qmatrix4x4.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qmatrix4x4.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qmatrix4x4.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtGui Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">%ModuleCode</span>
<span class="s0">#include &lt;qmatrix4x4.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">class QMatrix4x4</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qmatrix4x4.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">%PickleCode</span>
    <span class="s0">PYQT_FLOAT data[16];</span>
    
    <span class="s0">// We want the data in row-major order.</span>
    <span class="s0">sipCpp-&gt;copyDataTo(data);</span>
    
    <span class="s0">sipRes = Py_BuildValue((char *)&quot;dddddddddddddddd&quot;,</span>
            <span class="s0">(double)data[0], (double)data[1], (double)data[2], (double)data[3],</span>
            <span class="s0">(double)data[4], (double)data[5], (double)data[6], (double)data[7],</span>
            <span class="s0">(double)data[8], (double)data[9], (double)data[10], (double)data[11],</span>
            <span class="s0">(double)data[12], (double)data[13], (double)data[14], (double)data[15]);</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QMatrix4x4();</span>
    <span class="s0">explicit QMatrix4x4(SIP_PYOBJECT values /TypeHint=&quot;Sequence[float]&quot;/) [(const float *values)];</span>
<span class="s0">%MethodCode</span>
        <span class="s0">float values[16];</span>
        
        <span class="s0">if ((sipError = qtgui_matrixDataFromSequence(a0, 16, values)) == sipErrorNone)</span>
            <span class="s0">sipCpp = new QMatrix4x4(values);</span>
<span class="s0">%End</span>

    <span class="s0">QMatrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);</span>
    <span class="s0">QMatrix4x4(const QTransform &amp;transform);</span>
    <span class="s0">SIP_PYOBJECT __repr__() const /TypeHint=&quot;str&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">bool bad = false;</span>
        <span class="s0">int i;</span>
        <span class="s0">PyObject *m[16];</span>
        <span class="s0">PYQT_FLOAT data[16];</span>
        
        <span class="s0">// The raw data is in column-major order but we want row-major order.</span>
        <span class="s0">sipCpp-&gt;copyDataTo(data);</span>
        
        <span class="s0">for (i = 0; i &lt; 16; ++i)</span>
        <span class="s0">{</span>
            <span class="s0">m[i] = PyFloat_FromDouble(data[i]);</span>
        
            <span class="s0">if (!m[i])</span>
                <span class="s0">bad = true;</span>
        <span class="s0">}</span>
        
        <span class="s0">if (!bad)</span>
        <span class="s0">{</span>
        <span class="s0">#if PY_MAJOR_VERSION &gt;= 3</span>
            <span class="s0">sipRes = PyUnicode_FromFormat(&quot;PyQt5.QtGui.QMatrix4x4(&quot;</span>
                    <span class="s0">&quot;%R, %R, %R, %R, &quot;</span>
                    <span class="s0">&quot;%R, %R, %R, %R, &quot;</span>
                    <span class="s0">&quot;%R, %R, %R, %R, &quot;</span>
                    <span class="s0">&quot;%R, %R, %R, %R)&quot;,</span>
                    <span class="s0">m[0], m[1], m[2], m[3],</span>
                    <span class="s0">m[4], m[5], m[6], m[7],</span>
                    <span class="s0">m[8], m[9], m[10], m[11],</span>
                    <span class="s0">m[12], m[13], m[14], m[15]);</span>
        <span class="s0">#else</span>
            <span class="s0">sipRes = PyString_FromString(&quot;PyQt5.QtGui.QMatrix4x4(&quot;);</span>
        
            <span class="s0">for (i = 0; i &lt; 16; ++i)</span>
            <span class="s0">{</span>
                <span class="s0">if (i != 0)</span>
                    <span class="s0">PyString_ConcatAndDel(&amp;sipRes, PyString_FromString(&quot;, &quot;));</span>
        
                <span class="s0">PyString_ConcatAndDel(&amp;sipRes, PyObject_Repr(m[i]));</span>
            <span class="s0">}</span>
        
            <span class="s0">PyString_ConcatAndDel(&amp;sipRes, PyString_FromString(&quot;)&quot;));</span>
        <span class="s0">#endif</span>
        <span class="s0">}</span>
        
        <span class="s0">for (i = 0; i &lt; 16; ++i)</span>
            <span class="s0">Py_XDECREF(m[i]);</span>
<span class="s0">%End</span>

    <span class="s0">double determinant() const;</span>
    <span class="s0">QMatrix4x4 inverted(bool *invertible = 0) const;</span>
    <span class="s0">QMatrix4x4 transposed() const;</span>
    <span class="s0">QMatrix3x3 normalMatrix() const;</span>
    <span class="s0">void scale(const QVector3D &amp;vector);</span>
    <span class="s0">void scale(float x, float y);</span>
    <span class="s0">void scale(float x, float y, float z);</span>
    <span class="s0">void scale(float factor);</span>
    <span class="s0">void translate(const QVector3D &amp;vector);</span>
    <span class="s0">void translate(float x, float y);</span>
    <span class="s0">void translate(float x, float y, float z);</span>
    <span class="s0">void rotate(float angle, const QVector3D &amp;vector);</span>
    <span class="s0">void rotate(float angle, float x, float y, float z = 0.F);</span>
    <span class="s0">void rotate(const QQuaternion &amp;quaternion);</span>
    <span class="s0">void ortho(const QRect &amp;rect);</span>
    <span class="s0">void ortho(const QRectF &amp;rect);</span>
    <span class="s0">void ortho(float left, float right, float bottom, float top, float nearPlane, float farPlane);</span>
    <span class="s0">void frustum(float left, float right, float bottom, float top, float nearPlane, float farPlane);</span>
    <span class="s0">void perspective(float angle, float aspect, float nearPlane, float farPlane);</span>
    <span class="s0">void lookAt(const QVector3D &amp;eye, const QVector3D &amp;center, const QVector3D &amp;up);</span>
    <span class="s0">SIP_PYLIST copyDataTo() const /TypeHint=&quot;List[float]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">float values[16];</span>
        
        <span class="s0">sipCpp-&gt;copyDataTo(values);</span>
        <span class="s0">sipError = qtgui_matrixDataAsList(16, values, &amp;sipRes);</span>
<span class="s0">%End</span>

    <span class="s0">QTransform toTransform() const;</span>
    <span class="s0">QTransform toTransform(float distanceToPlane) const;</span>
    <span class="s0">QRect mapRect(const QRect &amp;rect) const;</span>
    <span class="s0">QRectF mapRect(const QRectF &amp;rect) const;</span>
    <span class="s0">SIP_PYLIST data() /TypeHint=&quot;List[float]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipError = qtgui_matrixDataAsList(16, sipCpp-&gt;constData(), &amp;sipRes);</span>
<span class="s0">%End</span>

    <span class="s0">void optimize();</span>
    <span class="s0">SIP_PYOBJECT __getitem__(SIP_PYOBJECT) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">int row, column;</span>
        
        <span class="s0">if ((sipError = qtgui_matrixParseIndex(a0, 4, 4, &amp;row, &amp;column)) == sipErrorNone)</span>
        <span class="s0">{</span>
            <span class="s0">sipRes = PyFloat_FromDouble(sipCpp-&gt;operator()(row, column));</span>
        
            <span class="s0">if (!sipRes)</span>
                <span class="s0">sipError = sipErrorFail;</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">void __setitem__(SIP_PYOBJECT, qreal);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">int row, column;</span>
        
        <span class="s0">if ((sipError = qtgui_matrixParseIndex(a0, 4, 4, &amp;row, &amp;column)) == sipErrorNone)</span>
            <span class="s0">sipCpp-&gt;operator()(row, column) = a1;</span>
<span class="s0">%End</span>

    <span class="s0">QVector4D column(int index) const;</span>
    <span class="s0">void setColumn(int index, const QVector4D &amp;value);</span>
    <span class="s0">QVector4D row(int index) const;</span>
    <span class="s0">void setRow(int index, const QVector4D &amp;value);</span>
    <span class="s0">bool isIdentity() const;</span>
    <span class="s0">void setToIdentity();</span>
    <span class="s0">void fill(float value);</span>
    <span class="s0">QMatrix4x4 &amp;operator+=(const QMatrix4x4 &amp;other);</span>
    <span class="s0">QMatrix4x4 &amp;operator-=(const QMatrix4x4 &amp;other);</span>
    <span class="s0">QMatrix4x4 &amp;operator*=(const QMatrix4x4 &amp;other) /__imatmul__/;</span>
    <span class="s0">QMatrix4x4 &amp;operator*=(float factor);</span>
    <span class="s0">QMatrix4x4 &amp;operator/=(float divisor);</span>
    <span class="s0">bool operator==(const QMatrix4x4 &amp;other) const;</span>
    <span class="s0">bool operator!=(const QMatrix4x4 &amp;other) const;</span>
    <span class="s0">QPoint map(const QPoint &amp;point) const;</span>
    <span class="s0">QPointF map(const QPointF &amp;point) const;</span>
    <span class="s0">QVector3D map(const QVector3D &amp;point) const;</span>
    <span class="s0">QVector3D mapVector(const QVector3D &amp;vector) const;</span>
    <span class="s0">QVector4D map(const QVector4D &amp;point) const;</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
    <span class="s0">void viewport(float left, float bottom, float width, float height, float nearPlane = 0.F, float farPlane = 1.F);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_4_0 -)</span>
    <span class="s0">void viewport(const QRectF &amp;rect);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_5_0 -)</span>
    <span class="s0">bool isAffine() const;</span>
<span class="s0">%End</span>
<span class="s0">};</span>

<span class="s0">QMatrix4x4 operator/(const QMatrix4x4 &amp;matrix, float divisor);</span>
<span class="s0">QMatrix4x4 operator+(const QMatrix4x4 &amp;m1, const QMatrix4x4 &amp;m2);</span>
<span class="s0">QMatrix4x4 operator-(const QMatrix4x4 &amp;m1, const QMatrix4x4 &amp;m2);</span>
<span class="s0">QMatrix4x4 operator*(const QMatrix4x4 &amp;m1, const QMatrix4x4 &amp;m2) /__matmul__/;</span>
<span class="s0">QVector3D operator*(const QVector3D &amp;vector, const QMatrix4x4 &amp;matrix);</span>
<span class="s0">QVector3D operator*(const QMatrix4x4 &amp;matrix, const QVector3D &amp;vector);</span>
<span class="s0">QVector4D operator*(const QVector4D &amp;vector, const QMatrix4x4 &amp;matrix);</span>
<span class="s0">QVector4D operator*(const QMatrix4x4 &amp;matrix, const QVector4D &amp;vector);</span>
<span class="s0">QPoint operator*(const QPoint &amp;point, const QMatrix4x4 &amp;matrix);</span>
<span class="s0">QPointF operator*(const QPointF &amp;point, const QMatrix4x4 &amp;matrix);</span>
<span class="s0">QPoint operator*(const QMatrix4x4 &amp;matrix, const QPoint &amp;point);</span>
<span class="s0">QPointF operator*(const QMatrix4x4 &amp;matrix, const QPointF &amp;point);</span>
<span class="s0">QMatrix4x4 operator-(const QMatrix4x4 &amp;matrix);</span>
<span class="s0">QMatrix4x4 operator*(float factor, const QMatrix4x4 &amp;matrix);</span>
<span class="s0">QMatrix4x4 operator*(const QMatrix4x4 &amp;matrix, float factor);</span>
<span class="s0">bool qFuzzyCompare(const QMatrix4x4 &amp;m1, const QMatrix4x4 &amp;m2);</span>
<span class="s0">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;, const QMatrix4x4 &amp; /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;, QMatrix4x4 &amp; /Constrained/) /ReleaseGIL/;</span>

<span class="s0">%ModuleHeaderCode</span>
<span class="s0">// Helpers for the matrix classes.</span>
<span class="s0">typedef float PYQT_FLOAT;</span>

<span class="s0">sipErrorState qtgui_matrixParseIndex(PyObject *tup, int nr_rows,</span>
        <span class="s0">int nr_columns, int *row, int *column);</span>
<span class="s0">sipErrorState qtgui_matrixDataFromSequence(PyObject *seq, int nr_values,</span>
        <span class="s0">PYQT_FLOAT *values);</span>
<span class="s0">sipErrorState qtgui_matrixDataAsList(int nr_values, const PYQT_FLOAT *values,</span>
        <span class="s0">PyObject **list);</span>
<span class="s0">%End</span>

<span class="s0">%ModuleCode</span>
<span class="s0">// Convert a Python object to a row and column.</span>
<span class="s0">sipErrorState qtgui_matrixParseIndex(PyObject *tup, int nr_rows,</span>
        <span class="s0">int nr_columns, int *row, int *column)</span>
<span class="s0">{</span>
    <span class="s0">sipErrorState es = sipErrorContinue;</span>

    <span class="s0">if (PyTuple_Check(tup) &amp;&amp; PyArg_ParseTuple(tup, &quot;ii&quot;, row, column))</span>
        <span class="s0">if (*row &gt;= 0 &amp;&amp; *row &lt; nr_rows &amp;&amp; *column &gt;= 0 &amp;&amp; *column &lt; nr_columns)</span>
            <span class="s0">es = sipErrorNone;</span>

    <span class="s0">if (es == sipErrorContinue)</span>
        <span class="s0">PyErr_Format(PyExc_IndexError, &quot;an index must be a row in the range 0 to %d and a column in the range 0 to %d&quot;, nr_rows - 1, nr_columns - 1);</span>

    <span class="s0">return es;</span>
<span class="s0">}</span>


<span class="s0">// Convert a Python object to an array of qreals.</span>
<span class="s0">sipErrorState qtgui_matrixDataFromSequence(PyObject *seq, int nr_values,</span>
        <span class="s0">PYQT_FLOAT *values)</span>
<span class="s0">{</span>
    <span class="s0">sipErrorState es;</span>

    <span class="s0">if (PySequence_Size(seq) == nr_values)</span>
    <span class="s0">{</span>
        <span class="s0">es = sipErrorNone;</span>

        <span class="s0">for (int i = 0; i &lt; nr_values; ++i)</span>
        <span class="s0">{</span>
            <span class="s0">PyObject *value = PySequence_GetItem(seq, i);</span>

            <span class="s0">if (!value)</span>
            <span class="s0">{</span>
                <span class="s0">es = sipErrorFail;</span>
                <span class="s0">break;</span>
            <span class="s0">}</span>

            <span class="s0">PyErr_Clear();</span>

            <span class="s0">double d = PyFloat_AsDouble(value);</span>

            <span class="s0">if (PyErr_Occurred())</span>
            <span class="s0">{</span>
                <span class="s0">Py_DECREF(value);</span>
                <span class="s0">es = sipErrorContinue;</span>
                <span class="s0">break;</span>
            <span class="s0">}</span>

            <span class="s0">Py_DECREF(value);</span>

            <span class="s0">*values++ = d;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">else</span>
    <span class="s0">{</span>
        <span class="s0">es = sipErrorContinue;</span>
    <span class="s0">}</span>

    <span class="s0">if (es == sipErrorContinue)</span>
        <span class="s0">PyErr_Format(PyExc_TypeError, &quot;a sequence of %d floats is expected&quot;,</span>
                <span class="s0">nr_values);</span>

    <span class="s0">return es;</span>
<span class="s0">}</span>


<span class="s0">// Convert an array of qreals to a Python list.</span>
<span class="s0">sipErrorState qtgui_matrixDataAsList(int nr_values, const PYQT_FLOAT *values,</span>
        <span class="s0">PyObject **list)</span>
<span class="s0">{</span>
    <span class="s0">PyObject *l = PyList_New(nr_values);</span>

    <span class="s0">if (!l)</span>
        <span class="s0">return sipErrorFail;</span>

    <span class="s0">for (int i = 0; i &lt; nr_values; ++i)</span>
    <span class="s0">{</span>
        <span class="s0">PyObject *value = PyFloat_FromDouble(*values++);</span>

        <span class="s0">if (!value)</span>
        <span class="s0">{</span>
            <span class="s0">Py_DECREF(l);</span>
            <span class="s0">return sipErrorFail;</span>
        <span class="s0">}</span>

        <span class="s0">PyList_SetItem(l, i, value);</span>
    <span class="s0">}</span>

    <span class="s0">*list = l;</span>

    <span class="s0">return sipErrorNone;</span>
<span class="s0">}</span>
<span class="s0">%End</span>
</pre>
</body>
</html>