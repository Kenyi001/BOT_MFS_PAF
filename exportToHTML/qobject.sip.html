<html>
<head>
<title>qobject.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qobject.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qobject.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtCore Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">typedef QList&lt;QObject *&gt; QObjectList;</span>

<span class="s0">class QObject /Supertype=sip.wrapper/</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qobject.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">%TypeCode</span>
<span class="s0">// This is needed by the tr() handwritten implementation.</span>
<span class="s0">#include &lt;qcoreapplication.h&gt;</span>


<span class="s0">// These are the helper functions for QObject::findChild() and</span>
<span class="s0">// QObject::findChildren.</span>

<span class="s0">// Wrap the given type in a 1-tuple.</span>
<span class="s0">static PyObject *qtcore_type_to_tuple(PyObject *type)</span>
<span class="s0">{</span>
    <span class="s0">PyObject *tuple = PyTuple_New(1);</span>

    <span class="s0">if (tuple)</span>
    <span class="s0">{</span>
        <span class="s0">Py_INCREF(type);</span>
        <span class="s0">PyTuple_SetItem(tuple, 0, type);</span>
    <span class="s0">}</span>

    <span class="s0">return tuple;</span>
<span class="s0">}</span>


<span class="s0">// Check all elements of a given tuple are type objects and return a new</span>
<span class="s0">// reference to the tuple if so.</span>
<span class="s0">static PyObject *qtcore_check_tuple_types(PyObject *types)</span>
<span class="s0">{</span>
    <span class="s0">for (Py_ssize_t i = 0; i &lt; PyTuple_Size(types); ++i)</span>
        <span class="s0">if (!PyObject_TypeCheck(PyTuple_GetItem(types, i), &amp;PyType_Type))</span>
        <span class="s0">{</span>
            <span class="s0">PyErr_SetString(PyExc_TypeError,</span>
                    <span class="s0">&quot;all elements of the types argument must be type objects&quot;);</span>
            <span class="s0">return 0;</span>
        <span class="s0">}</span>

    <span class="s0">Py_INCREF(types);</span>
    <span class="s0">return types;</span>
<span class="s0">}</span>


<span class="s0">// Do the main work of finding a child.</span>
<span class="s0">static PyObject *qtcore_do_find_child(const QObject *parent, PyObject *types, const QString &amp;name, Qt::FindChildOptions options)</span>
<span class="s0">{</span>
    <span class="s0">const QObjectList &amp;children = parent-&gt;children();</span>
    <span class="s0">int i;</span>

    <span class="s0">for (i = 0; i &lt; children.size(); ++i)</span>
    <span class="s0">{</span>
        <span class="s0">QObject *obj = children.at(i);</span>
        <span class="s0">PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);</span>

        <span class="s0">if (!pyo)</span>
            <span class="s0">return 0;</span>

        <span class="s0">// Allow for proxies.</span>
        <span class="s0">QObject *resolved = reinterpret_cast&lt;QObject *&gt;(sipGetAddress((sipSimpleWrapper *)pyo));</span>

        <span class="s0">if (name.isNull() || resolved-&gt;objectName() == name)</span>
            <span class="s0">for (Py_ssize_t t = 0; t &lt; PyTuple_Size(types); ++t)</span>
                <span class="s0">if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))</span>
                    <span class="s0">return pyo;</span>

        <span class="s0">Py_DECREF(pyo);</span>
    <span class="s0">}</span>

    <span class="s0">if (options == Qt::FindChildrenRecursively)</span>
        <span class="s0">for (i = 0; i &lt; children.size(); ++i)</span>
        <span class="s0">{</span>
            <span class="s0">PyObject *pyo = qtcore_do_find_child(children.at(i), types, name, options);</span>

            <span class="s0">if (pyo != Py_None)</span>
                <span class="s0">return pyo;</span>

            <span class="s0">Py_DECREF(pyo);</span>
        <span class="s0">}</span>

    <span class="s0">Py_INCREF(Py_None);</span>
    <span class="s0">return Py_None;</span>
<span class="s0">}</span>


<span class="s0">// Find a child that is one of a number of types and with an optional name.</span>
<span class="s0">static PyObject *qtcore_FindChild(const QObject *parent, PyObject *types, const QString &amp;name, Qt::FindChildOptions options)</span>
<span class="s0">{</span>
    <span class="s0">// Check that the types checking was successful.</span>
    <span class="s0">if (!types)</span>
        <span class="s0">return 0;</span>

    <span class="s0">PyObject *child = qtcore_do_find_child(parent, types, name, options);</span>

    <span class="s0">Py_DECREF(types);</span>

    <span class="s0">return child;</span>
<span class="s0">}</span>


<span class="s0">// Do the main work of finding the children with a string name.</span>
<span class="s0">static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QString &amp;name, Qt::FindChildOptions options, PyObject *list)</span>
<span class="s0">{</span>
    <span class="s0">const QObjectList &amp;children = parent-&gt;children();</span>
    <span class="s0">int i;</span>

    <span class="s0">for (i = 0; i &lt; children.size(); ++i)</span>
    <span class="s0">{</span>
        <span class="s0">QObject *obj = children.at(i);</span>
        <span class="s0">PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);</span>

        <span class="s0">if (!pyo)</span>
            <span class="s0">return false;</span>

        <span class="s0">// Allow for proxies.</span>
        <span class="s0">QObject *resolved = reinterpret_cast&lt;QObject *&gt;(sipGetAddress((sipSimpleWrapper *)pyo));</span>

        <span class="s0">if (name.isNull() || resolved-&gt;objectName() == name)</span>
            <span class="s0">for (Py_ssize_t t = 0; t &lt; PyTuple_Size(types); ++t)</span>
                <span class="s0">if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))</span>
                    <span class="s0">if (PyList_Append(list, pyo) &lt; 0)</span>
                    <span class="s0">{</span>
                        <span class="s0">Py_DECREF(pyo);</span>
                        <span class="s0">return false;</span>
                    <span class="s0">}</span>

        <span class="s0">Py_DECREF(pyo);</span>

        <span class="s0">if (options == Qt::FindChildrenRecursively)</span>
        <span class="s0">{</span>
            <span class="s0">bool ok = qtcore_do_find_children(obj, types, name, options, list);</span>

            <span class="s0">if (!ok)</span>
                <span class="s0">return false;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return true;</span>
<span class="s0">}</span>


<span class="s0">// Find a child that is one of a number of types and with an optional string</span>
<span class="s0">// name.</span>
<span class="s0">static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QString &amp;name, Qt::FindChildOptions options)</span>
<span class="s0">{</span>
    <span class="s0">// Check that the types checking was successful.</span>
    <span class="s0">if (!types)</span>
        <span class="s0">return 0;</span>

    <span class="s0">PyObject *list = PyList_New(0);</span>

    <span class="s0">if (list)</span>
        <span class="s0">if (!qtcore_do_find_children(parent, types, name, options, list))</span>
            <span class="s0">Py_DECREF(list);</span>

    <span class="s0">Py_DECREF(types);</span>

    <span class="s0">return list;</span>
<span class="s0">}</span>


<span class="s0">// Do the main work of finding the children with a QRegExp name.</span>
<span class="s0">static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegExp &amp;re, Qt::FindChildOptions options, PyObject *list)</span>
<span class="s0">{</span>
    <span class="s0">const QObjectList &amp;children = parent-&gt;children();</span>
    <span class="s0">int i;</span>

    <span class="s0">for (i = 0; i &lt; children.size(); ++i)</span>
    <span class="s0">{</span>
        <span class="s0">QObject *obj = children.at(i);</span>
        <span class="s0">PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);</span>

        <span class="s0">if (!pyo)</span>
            <span class="s0">return false;</span>

        <span class="s0">if (re.indexIn(obj-&gt;objectName()) &gt;= 0)</span>
            <span class="s0">for (Py_ssize_t t = 0; t &lt; PyTuple_Size(types); ++t)</span>
                <span class="s0">if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))</span>
                    <span class="s0">if (PyList_Append(list, pyo) &lt; 0)</span>
                    <span class="s0">{</span>
                        <span class="s0">Py_DECREF(pyo);</span>
                        <span class="s0">return false;</span>
                    <span class="s0">}</span>

        <span class="s0">Py_DECREF(pyo);</span>

        <span class="s0">if (options == Qt::FindChildrenRecursively)</span>
        <span class="s0">{</span>
            <span class="s0">bool ok = qtcore_do_find_children(obj, types, re, options, list);</span>

            <span class="s0">if (!ok)</span>
                <span class="s0">return false;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return true;</span>
<span class="s0">}</span>


<span class="s0">// Find a child that is one of a number of types and with an optional QRegExp</span>
<span class="s0">// name.</span>
<span class="s0">static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegExp &amp;re, Qt::FindChildOptions options)</span>
<span class="s0">{</span>
    <span class="s0">// Check that the types checking was successful.</span>
    <span class="s0">if (!types)</span>
        <span class="s0">return 0;</span>

    <span class="s0">PyObject *list = PyList_New(0);</span>

    <span class="s0">if (list)</span>
        <span class="s0">if (!qtcore_do_find_children(parent, types, re, options, list))</span>
            <span class="s0">Py_DECREF(list);</span>

    <span class="s0">Py_DECREF(types);</span>

    <span class="s0">return list;</span>
<span class="s0">}</span>


<span class="s0">// Do the main work of finding the children with a QRegularExpression name.</span>
<span class="s0">static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegularExpression &amp;re, Qt::FindChildOptions options, PyObject *list)</span>
<span class="s0">{</span>
    <span class="s0">const QObjectList &amp;children = parent-&gt;children();</span>
    <span class="s0">int i;</span>

    <span class="s0">for (i = 0; i &lt; children.size(); ++i)</span>
    <span class="s0">{</span>
        <span class="s0">QObject *obj = children.at(i);</span>
        <span class="s0">PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);</span>

        <span class="s0">if (!pyo)</span>
            <span class="s0">return false;</span>

        <span class="s0">QRegularExpressionMatch m = re.match(obj-&gt;objectName());</span>
        
        <span class="s0">if (m.hasMatch())</span>
            <span class="s0">for (Py_ssize_t t = 0; t &lt; PyTuple_Size(types); ++t)</span>
                <span class="s0">if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))</span>
                    <span class="s0">if (PyList_Append(list, pyo) &lt; 0)</span>
                    <span class="s0">{</span>
                        <span class="s0">Py_DECREF(pyo);</span>
                        <span class="s0">return false;</span>
                    <span class="s0">}</span>

        <span class="s0">Py_DECREF(pyo);</span>

        <span class="s0">if (options == Qt::FindChildrenRecursively)</span>
        <span class="s0">{</span>
            <span class="s0">bool ok = qtcore_do_find_children(obj, types, re, options, list);</span>

            <span class="s0">if (!ok)</span>
                <span class="s0">return false;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">return true;</span>
<span class="s0">}</span>


<span class="s0">// Find a child that is one of a number of types and with an optional</span>
<span class="s0">// QRegularExpression name.</span>
<span class="s0">static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegularExpression &amp;re, Qt::FindChildOptions options)</span>
<span class="s0">{</span>
    <span class="s0">// Check that the types checking was successful.</span>
    <span class="s0">if (!types)</span>
        <span class="s0">return 0;</span>

    <span class="s0">PyObject *list = PyList_New(0);</span>

    <span class="s0">if (list)</span>
        <span class="s0">if (!qtcore_do_find_children(parent, types, re, options, list))</span>
            <span class="s0">Py_DECREF(list);</span>

    <span class="s0">Py_DECREF(types);</span>

    <span class="s0">return list;</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">%FinalisationCode</span>
    <span class="s0">return qpycore_qobject_finalisation(sipSelf, sipCpp, sipKwds, sipUnused);</span>
<span class="s0">%End</span>

<span class="s0">%ConvertToSubClassCode</span>
    <span class="s0">static struct class_graph {</span>
        <span class="s0">const char *name;</span>
        <span class="s0">sipTypeDef **type;</span>
        <span class="s0">int yes, no;</span>
    <span class="s0">} graph[] = {</span>
        <span class="s0">{sipName_QAbstractAnimation, &amp;sipType_QAbstractAnimation, 25, 1},</span>
        <span class="s0">{sipName_QAbstractEventDispatcher, &amp;sipType_QAbstractEventDispatcher, -1, 2},</span>
        <span class="s0">{sipName_QAbstractItemModel, &amp;sipType_QAbstractItemModel, 31, 3},</span>
        <span class="s0">{sipName_QAbstractState, &amp;sipType_QAbstractState, 39, 4},</span>
        <span class="s0">{sipName_QAbstractTransition, &amp;sipType_QAbstractTransition, 43, 5},</span>
        <span class="s0">{sipName_QIODevice, &amp;sipType_QIODevice, 45, 6},</span>
        <span class="s0">{sipName_QCoreApplication, &amp;sipType_QCoreApplication, -1, 7},</span>
        <span class="s0">{sipName_QEventLoop, &amp;sipType_QEventLoop, -1, 8},</span>
    <span class="s0">#if QT_VERSION &gt;= 0x050200</span>
        <span class="s0">{sipName_QFileSelector, &amp;sipType_QFileSelector, -1, 9},</span>
    <span class="s0">#else</span>
        <span class="s0">{0, 0, -1, 9},</span>
    <span class="s0">#endif</span>
        <span class="s0">{sipName_QFileSystemWatcher, &amp;sipType_QFileSystemWatcher, -1, 10},</span>
        <span class="s0">{sipName_QItemSelectionModel, &amp;sipType_QItemSelectionModel, -1, 11},</span>
        <span class="s0">{sipName_QLibrary, &amp;sipType_QLibrary, -1, 12},</span>
        <span class="s0">{sipName_QMimeData, &amp;sipType_QMimeData, -1, 13},</span>
        <span class="s0">{sipName_QObjectCleanupHandler, &amp;sipType_QObjectCleanupHandler, -1, 14},</span>
        <span class="s0">{sipName_QPluginLoader, &amp;sipType_QPluginLoader, -1, 15},</span>
        <span class="s0">{sipName_QSettings, &amp;sipType_QSettings, -1, 16},</span>
        <span class="s0">{sipName_QSharedMemory, &amp;sipType_QSharedMemory, -1, 17},</span>
        <span class="s0">{sipName_QSignalMapper, &amp;sipType_QSignalMapper, -1, 18},</span>
        <span class="s0">{sipName_QSocketNotifier, &amp;sipType_QSocketNotifier, -1, 19},</span>
        <span class="s0">{sipName_QThread, &amp;sipType_QThread, -1, 20},</span>
        <span class="s0">{sipName_QThreadPool, &amp;sipType_QThreadPool, -1, 21},</span>
        <span class="s0">{sipName_QTimeLine, &amp;sipType_QTimeLine, -1, 22},</span>
        <span class="s0">{sipName_QTimer, &amp;sipType_QTimer, -1, 23},</span>
        <span class="s0">{sipName_QTranslator, &amp;sipType_QTranslator, -1, 24},</span>
    <span class="s0">#if defined(Q_OS_WIN)</span>
        <span class="s0">{sipName_QWinEventNotifier, &amp;sipType_QWinEventNotifier, -1, -1},</span>
    <span class="s0">#else</span>
        <span class="s0">{0, 0, -1, -1},</span>
    <span class="s0">#endif</span>
        <span class="s0">{sipName_QAnimationGroup, &amp;sipType_QAnimationGroup, 28, 26},</span>
        <span class="s0">{sipName_QPauseAnimation, &amp;sipType_QPauseAnimation, -1, 27},</span>
        <span class="s0">{sipName_QVariantAnimation, &amp;sipType_QVariantAnimation, 30, -1},</span>
        <span class="s0">{sipName_QParallelAnimationGroup, &amp;sipType_QParallelAnimationGroup, -1, 29},</span>
        <span class="s0">{sipName_QSequentialAnimationGroup, &amp;sipType_QSequentialAnimationGroup, -1, -1},</span>
        <span class="s0">{sipName_QPropertyAnimation, &amp;sipType_QPropertyAnimation, -1, -1},</span>
        <span class="s0">{sipName_QAbstractListModel, &amp;sipType_QAbstractListModel, 35, 32},</span>
        <span class="s0">{sipName_QAbstractProxyModel, &amp;sipType_QAbstractProxyModel, 36, 33},</span>
        <span class="s0">{sipName_QAbstractTableModel, &amp;sipType_QAbstractTableModel, -1, 34},</span>
    <span class="s0">#if QT_VERSION &gt;= 0x050d00</span>
        <span class="s0">{sipName_QConcatenateTablesProxyModel, &amp;sipType_QConcatenateTablesProxyModel, -1, -1},</span>
    <span class="s0">#else</span>
        <span class="s0">{0, 0, -1, -1},</span>
    <span class="s0">#endif</span>
        <span class="s0">{sipName_QStringListModel, &amp;sipType_QStringListModel, -1, -1},</span>
        <span class="s0">{sipName_QIdentityProxyModel, &amp;sipType_QIdentityProxyModel, -1, 37},</span>
        <span class="s0">{sipName_QSortFilterProxyModel, &amp;sipType_QSortFilterProxyModel, -1, 38},</span>
    <span class="s0">#if QT_VERSION &gt;= 0x050d00</span>
        <span class="s0">{sipName_QTransposeProxyModel, &amp;sipType_QTransposeProxyModel, -1, -1},</span>
    <span class="s0">#else</span>
        <span class="s0">{0, 0, -1, -1},</span>
    <span class="s0">#endif</span>
        <span class="s0">{sipName_QFinalState, &amp;sipType_QFinalState, -1, 40},</span>
        <span class="s0">{sipName_QHistoryState, &amp;sipType_QHistoryState, -1, 41},</span>
        <span class="s0">{sipName_QState, &amp;sipType_QState, 42, -1},</span>
        <span class="s0">{sipName_QStateMachine, &amp;sipType_QStateMachine, -1, -1},</span>
        <span class="s0">{sipName_QEventTransition, &amp;sipType_QEventTransition, -1, 44},</span>
        <span class="s0">{sipName_QSignalTransition, &amp;sipType_QSignalTransition, -1, -1},</span>
        <span class="s0">{sipName_QBuffer, &amp;sipType_QBuffer, -1, 46},</span>
        <span class="s0">{sipName_QFileDevice, &amp;sipType_QFileDevice, 48, 47},</span>
    <span class="s0">#if !defined(QT_NO_PROCESS)</span>
        <span class="s0">{sipName_QProcess, &amp;sipType_QProcess, -1, -1},</span>
    <span class="s0">#else</span>
        <span class="s0">{0, 0, -1, -1},</span>
    <span class="s0">#endif</span>
        <span class="s0">{sipName_QFile, &amp;sipType_QFile, 50, 49},</span>
    <span class="s0">#if QT_VERSION &gt;= 0x050100</span>
        <span class="s0">{sipName_QSaveFile, &amp;sipType_QSaveFile, -1, -1},</span>
    <span class="s0">#else</span>
        <span class="s0">{0, 0, -1, -1},</span>
    <span class="s0">#endif</span>
        <span class="s0">{sipName_QTemporaryFile, &amp;sipType_QTemporaryFile, -1, -1},</span>
    <span class="s0">};</span>
    
    <span class="s0">int i = 0;</span>
    
    <span class="s0">sipType = NULL;</span>
    
    <span class="s0">do</span>
    <span class="s0">{</span>
        <span class="s0">struct class_graph *cg = &amp;graph[i];</span>
    
        <span class="s0">if (cg-&gt;name != NULL &amp;&amp; sipCpp-&gt;inherits(cg-&gt;name))</span>
        <span class="s0">{</span>
            <span class="s0">sipType = *cg-&gt;type;</span>
            <span class="s0">i = cg-&gt;yes;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">i = cg-&gt;no;</span>
    <span class="s0">}</span>
    <span class="s0">while (i &gt;= 0);</span>
<span class="s0">%End</span>

<span class="s0">%GCTraverseCode</span>
    <span class="s0">// Traverse any saved slots we might be connected to.</span>
    <span class="s0">sipRes = qpycore_visitSlotProxies(sipCpp, sipVisit, sipArg);</span>
<span class="s0">%End</span>

<span class="s0">%GCClearCode</span>
    <span class="s0">// Clear any saved slots we might be connected to.</span>
    <span class="s0">sipRes = qpycore_clearSlotProxies(sipCpp);</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">static const QMetaObject staticMetaObject {</span>
<span class="s0">%GetCode</span>
        <span class="s0">sipPy = qpycore_qobject_staticmetaobject(sipPyType);</span>
<span class="s0">%End</span>

    <span class="s0">};</span>
    <span class="s0">const QMetaObject *metaObject() const;</span>
    <span class="s0">explicit QObject(QObject *parent /TransferThis/ = 0);</span>
    <span class="s0">virtual ~QObject();</span>
    <span class="s0">void pyqtConfigure(SIP_PYOBJECT) /NoArgParser/;</span>
<span class="s0">%Docstring</span>
<span class="s0">QObject.pyqtConfigure(...)</span>

<span class="s0">Each keyword argument is either the name of a Qt property or a Qt signal.</span>
<span class="s0">For properties the property is set to the given value which should be of an</span>
<span class="s0">appropriate type.</span>
<span class="s0">For signals the signal is connected to the given value which should be a</span>
<span class="s0">callable.</span>
<span class="s0">%End</span>

<span class="s0">%MethodCode</span>
        <span class="s0">return qpycore_pyqtconfigure(sipSelf, sipArgs, sipKwds);</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYOBJECT __getattr__(const char *name /Encoding=&quot;UTF-8&quot;/) const /NoTypeHint/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qpycore_qobject_getattr(sipCpp, sipSelf, a0);</span>
<span class="s0">%End</span>

    <span class="s0">virtual bool event(QEvent *);</span>
    <span class="s0">virtual bool eventFilter(QObject *, QEvent *);</span>
    <span class="s0">QString tr(const char *sourceText /Encoding=&quot;UTF-8&quot;/, const char *disambiguation = 0, int n = -1) const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// Note that tr() is really a static method.  We pretend it isn't so we can use</span>
        <span class="s0">// self to get hold of the class name.</span>
        
        <span class="s0">sipRes = new QString(QCoreApplication::translate(sipPyTypeName(Py_TYPE(sipSelf)), a0, a1, a2));</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYOBJECT findChild(SIP_PYTYPE type /TypeHint=&quot;Type[QObjectT]&quot;/, const QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;QObjectT&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChild(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYOBJECT findChild(SIP_PYTUPLE types /TypeHint=&quot;Tuple[Type[QObjectT], ...]&quot;, TypeHintValue=&quot;()&quot;/, const QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;QObjectT&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChild(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYLIST findChildren(SIP_PYTYPE type /TypeHint=&quot;Type[QObjectT]&quot;/, const QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;List[QObjectT]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYLIST findChildren(SIP_PYTUPLE types /TypeHint=&quot;Tuple[Type[QObjectT], ...]&quot;, TypeHintValue=&quot;()&quot;/, const QString &amp;name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;List[QObjectT]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYLIST findChildren(SIP_PYTYPE type /TypeHint=&quot;Type[QObjectT]&quot;/, const QRegExp &amp;regExp, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;List[QObjectT]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYLIST findChildren(SIP_PYTUPLE types /TypeHint=&quot;Tuple[Type[QObjectT], ...]&quot;, TypeHintValue=&quot;()&quot;/, const QRegExp &amp;regExp, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;List[QObjectT]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYLIST findChildren(SIP_PYTYPE type /TypeHint=&quot;Type[QObjectT]&quot;/, const QRegularExpression &amp;re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;List[QObjectT]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">SIP_PYLIST findChildren(SIP_PYTUPLE types /TypeHint=&quot;Tuple[Type[QObjectT], ...]&quot;, TypeHintValue=&quot;()&quot;/, const QRegularExpression &amp;re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const /TypeHint=&quot;List[QObjectT]&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);</span>
        
        <span class="s0">if (!sipRes)</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">QString objectName() const;</span>
    <span class="s0">void setObjectName(const QString &amp;name);</span>
    <span class="s0">bool isWidgetType() const;</span>
    <span class="s0">bool isWindowType() const;</span>
    <span class="s0">bool signalsBlocked() const;</span>
    <span class="s0">bool blockSignals(bool b);</span>
    <span class="s0">QThread *thread() const;</span>
    <span class="s0">void moveToThread(QThread *thread);</span>
    <span class="s0">int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);</span>
    <span class="s0">void killTimer(int id);</span>
    <span class="s0">const QObjectList &amp;children() const;</span>
    <span class="s0">void setParent(QObject * /TransferThis/);</span>
    <span class="s0">void installEventFilter(QObject *);</span>
    <span class="s0">void removeEventFilter(QObject *);</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">void dumpObjectInfo() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (- Qt_5_9_0)</span>
    <span class="s0">void dumpObjectInfo();</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">void dumpObjectTree() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (- Qt_5_9_0)</span>
    <span class="s0">void dumpObjectTree();</span>
<span class="s0">%End</span>
    <span class="s0">QList&lt;QByteArray&gt; dynamicPropertyNames() const;</span>
    <span class="s0">bool setProperty(const char *name, const QVariant &amp;value);</span>
    <span class="s0">QVariant property(const char *name) const;</span>

<span class="s0">signals:</span>
    <span class="s0">void destroyed(QObject *object = 0);</span>
    <span class="s0">void objectNameChanged(const QString &amp;objectName);</span>

<span class="s0">public:</span>
    <span class="s0">QObject *parent() const;</span>
    <span class="s0">bool inherits(const char *classname) const;</span>

<span class="s0">public slots:</span>
    <span class="s0">void deleteLater() /TransferThis/;</span>

<span class="s0">protected:</span>
    <span class="s0">QObject *sender() const /ReleaseGIL/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// sender() must be called without the GIL to avoid possible deadlocks between</span>
        <span class="s0">// the GIL and Qt's internal thread data mutex.</span>
        
        <span class="s0">Py_BEGIN_ALLOW_THREADS</span>
        
        <span class="s0">#if defined(SIP_PROTECTED_IS_PUBLIC)</span>
        <span class="s0">sipRes = sipCpp-&gt;sender();</span>
        <span class="s0">#else</span>
        <span class="s0">sipRes = sipCpp-&gt;sipProtect_sender();</span>
        <span class="s0">#endif</span>
        
        <span class="s0">Py_END_ALLOW_THREADS</span>
        
        <span class="s0">if (!sipRes)</span>
        <span class="s0">{</span>
            <span class="s0">typedef QObject *(*qtcore_qobject_sender_t)();</span>
        
            <span class="s0">static qtcore_qobject_sender_t qtcore_qobject_sender = 0;</span>
        
            <span class="s0">if (!qtcore_qobject_sender)</span>
            <span class="s0">{</span>
                <span class="s0">qtcore_qobject_sender = (qtcore_qobject_sender_t)sipImportSymbol(&quot;qtcore_qobject_sender&quot;);</span>
                <span class="s0">Q_ASSERT(qtcore_qobject_sender);</span>
            <span class="s0">}</span>
        
            <span class="s0">sipRes = qtcore_qobject_sender();</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">int receivers(SIP_PYOBJECT signal /TypeHint=&quot;PYQT_SIGNAL&quot;/) const [int (const char *signal)];</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// We need to handle the signal object.  Import the helper if it hasn't already</span>
        <span class="s0">// been done.</span>
        <span class="s0">typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &amp;);</span>
        
        <span class="s0">static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;</span>
        
        <span class="s0">if (!pyqt5_get_signal_signature)</span>
        <span class="s0">{</span>
            <span class="s0">pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol(&quot;pyqt5_get_signal_signature&quot;);</span>
            <span class="s0">Q_ASSERT(pyqt5_get_signal_signature);</span>
        <span class="s0">}</span>
        
        <span class="s0">QByteArray signal_signature;</span>
            
        <span class="s0">#if defined(SIP_PROTECTED_IS_PUBLIC)</span>
        <span class="s0">if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)</span>
        <span class="s0">{</span>
            <span class="s0">sipRes = sipCpp-&gt;receivers(signal_signature.constData());</span>
        <span class="s0">}</span>
        <span class="s0">#else</span>
        <span class="s0">if ((sipError = pyqt5_get_signal_signature(a0, static_cast&lt;const QObject *&gt;(sipCpp), signal_signature)) == sipErrorNone)</span>
        <span class="s0">{</span>
            <span class="s0">sipRes = sipCpp-&gt;sipProtect_receivers(signal_signature.constData());</span>
        <span class="s0">}</span>
        <span class="s0">#endif</span>
        <span class="s0">else if (sipError == sipErrorContinue)</span>
        <span class="s0">{</span>
            <span class="s0">sipError = sipBadCallableArg(0, a0);</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">virtual void timerEvent(QTimerEvent *);</span>
    <span class="s0">virtual void childEvent(QChildEvent *);</span>
    <span class="s0">virtual void customEvent(QEvent *);</span>
    <span class="s0">virtual void connectNotify(const QMetaMethod &amp;signal);</span>
    <span class="s0">virtual void disconnectNotify(const QMetaMethod &amp;signal);</span>
    <span class="s0">int senderSignalIndex() const;</span>
    <span class="s0">bool isSignalConnected(const QMetaMethod &amp;signal) const;</span>

<span class="s0">public:</span>
    <span class="s0">static bool disconnect(const QMetaObject::Connection &amp;);</span>
    <span class="s0">SIP_PYOBJECT disconnect() const /TypeHint=&quot;&quot;/;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qpycore_qobject_disconnect(sipCpp);</span>
<span class="s0">%End</span>

<span class="s0">private:</span>
    <span class="s0">QObject(const QObject &amp;);</span>
<span class="s0">};</span>

<span class="s0">SIP_PYOBJECT Q_CLASSINFO(const char *name, const char *value) /TypeHint=&quot;&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">sipRes = qpycore_ClassInfo(a0, a1);</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT Q_ENUM(SIP_PYOBJECT /TypeHint=&quot;Union[type, enum.Enum]&quot;/) /TypeHint=&quot;&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">sipRes = qpycore_Enum(a0);</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT Q_ENUMS(...) /TypeHint=&quot;&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">sipRes = qpycore_Enums(a0);</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT Q_FLAG(SIP_PYOBJECT /TypeHint=&quot;Union[type, enum.Enum]&quot;/) /TypeHint=&quot;&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">sipRes = qpycore_Flag(a0);</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT Q_FLAGS(...) /TypeHint=&quot;&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">sipRes = qpycore_Flags(a0);</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT QT_TR_NOOP(SIP_PYOBJECT /TypeHint=&quot;str&quot;/) /TypeHint=&quot;str&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">Py_INCREF(a0);</span>
    <span class="s0">sipRes = a0;</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT QT_TR_NOOP_UTF8(SIP_PYOBJECT /TypeHint=&quot;str&quot;/) /TypeHint=&quot;str&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">Py_INCREF(a0);</span>
    <span class="s0">sipRes = a0;</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT QT_TRANSLATE_NOOP(SIP_PYOBJECT /TypeHint=&quot;str&quot;/, SIP_PYOBJECT /TypeHint=&quot;str&quot;/) /TypeHint=&quot;str&quot;/;</span>
<span class="s0">%MethodCode</span>
    <span class="s0">Py_INCREF(a1);</span>
    <span class="s0">sipRes = a1;</span>
<span class="s0">%End</span>

<span class="s0">SIP_PYOBJECT pyqtSlot(... types, const char *name = 0, const char *result = 0) /NoArgParser, NoTypeHint/;</span>
<span class="s0">%Docstring</span>
<span class="s0">@pyqtSlot(*types, name: Optional[str], result: Optional[str])</span>

<span class="s0">This is a decorator applied to Python methods of a QObject that marks them</span>
<span class="s0">as Qt slots.</span>
<span class="s0">The non-keyword arguments are the types of the slot arguments and each may</span>
<span class="s0">be a Python type object or a string specifying a C++ type.</span>
<span class="s0">name is the name of the slot and defaults to the name of the method.</span>
<span class="s0">result is type of the value returned by the slot.</span>
<span class="s0">%End</span>

<span class="s0">%MethodCode</span>
    <span class="s0">return qpycore_pyqtslot(sipArgs, sipKwds);</span>
<span class="s0">%End</span>

<span class="s0">%If (Qt_5_3_0 -)</span>

<span class="s0">class QSignalBlocker</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qobject.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">explicit QSignalBlocker(QObject *o);</span>
    <span class="s0">~QSignalBlocker();</span>
    <span class="s0">void reblock();</span>
    <span class="s0">void unblock();</span>
    <span class="s0">SIP_PYOBJECT __enter__();</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// Just return a reference to self.</span>
        <span class="s0">sipRes = sipSelf;</span>
        <span class="s0">Py_INCREF(sipRes);</span>
<span class="s0">%End</span>

    <span class="s0">void __exit__(SIP_PYOBJECT type, SIP_PYOBJECT value, SIP_PYOBJECT traceback);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipCpp-&gt;unblock();</span>
<span class="s0">%End</span>

<span class="s0">private:</span>
    <span class="s0">QSignalBlocker(const QSignalBlocker &amp;);</span>
<span class="s0">};</span>

<span class="s0">%End</span>

<span class="s0">%ModuleHeaderCode</span>
<span class="s0">#include &quot;qpycore_api.h&quot;</span>
<span class="s0">%End</span>

<span class="s0">%ModuleCode</span>
<span class="s0">// Disable the (supposedly) compulsory parts of the Qt support API.</span>
<span class="s0">#define sipQtCreateUniversalSlot    0</span>
<span class="s0">#define sipQtDestroyUniversalSlot   0</span>
<span class="s0">#define sipQtFindSlot               0</span>
<span class="s0">#define sipQtConnect                0</span>
<span class="s0">#define sipQtDisconnect             0</span>
<span class="s0">#define sipQtSameSignalSlotName     0</span>
<span class="s0">#define sipQtFindSipslot            0</span>
<span class="s0">%End</span>

<span class="s0">%PreInitialisationCode</span>
<span class="s0">#if defined(Q_OS_DARWIN)</span>
    <span class="s0">// This works around a problem (possibly a clash between Qt and Python)</span>
    <span class="s0">// began with Qt v5.11 that causes missed paint events.  Only set the</span>
    <span class="s0">// variable if it hasn't already been given a value.</span>
    <span class="s0">if (qgetenv(&quot;QT_MAC_WANTS_LAYER&quot;).isNull())</span>
        <span class="s0">qputenv(&quot;QT_MAC_WANTS_LAYER&quot;, &quot;1&quot;);</span>
<span class="s0">#endif</span>
<span class="s0">%End</span>

<span class="s0">%InitialisationCode</span>
<span class="s0">qpycore_init();</span>
<span class="s0">%End</span>

<span class="s0">%PostInitialisationCode</span>
<span class="s0">qpycore_post_init(sipModuleDict);</span>
<span class="s0">%End</span>
</pre>
</body>
</html>