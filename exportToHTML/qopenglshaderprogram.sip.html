<html>
<head>
<title>qopenglshaderprogram.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qopenglshaderprogram.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qopenglshaderprogram.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtGui Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">%If (PyQt_OpenGL)</span>

<span class="s0">class QOpenGLShader : QObject</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qopenglshaderprogram.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">enum ShaderTypeBit</span>
    <span class="s0">{</span>
        <span class="s0">Vertex,</span>
        <span class="s0">Fragment,</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
        <span class="s0">Geometry,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
        <span class="s0">TessellationControl,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
        <span class="s0">TessellationEvaluation,</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
        <span class="s0">Compute,</span>
<span class="s0">%End</span>
    <span class="s0">};</span>

    <span class="s0">typedef QFlags&lt;QOpenGLShader::ShaderTypeBit&gt; ShaderType;</span>
    <span class="s0">QOpenGLShader(QOpenGLShader::ShaderType type, QObject *parent /TransferThis/ = 0);</span>
    <span class="s0">virtual ~QOpenGLShader();</span>
    <span class="s0">QOpenGLShader::ShaderType shaderType() const;</span>
    <span class="s0">bool compileSourceCode(const QByteArray &amp;source);</span>
    <span class="s0">bool compileSourceCode(const QString &amp;source);</span>
    <span class="s0">bool compileSourceFile(const QString &amp;fileName);</span>
    <span class="s0">QByteArray sourceCode() const;</span>
    <span class="s0">bool isCompiled() const;</span>
    <span class="s0">QString log() const;</span>
    <span class="s0">GLuint shaderId() const;</span>
    <span class="s0">static bool hasOpenGLShaders(QOpenGLShader::ShaderType type, QOpenGLContext *context = 0);</span>
<span class="s0">};</span>

<span class="s0">%End</span>
<span class="s0">%If (PyQt_OpenGL)</span>
<span class="s0">QFlags&lt;QOpenGLShader::ShaderTypeBit&gt; operator|(QOpenGLShader::ShaderTypeBit f1, QFlags&lt;QOpenGLShader::ShaderTypeBit&gt; f2);</span>
<span class="s0">%End</span>
<span class="s0">%If (PyQt_OpenGL)</span>

<span class="s0">class QOpenGLShaderProgram : QObject</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qopenglshaderprogram.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">explicit QOpenGLShaderProgram(QObject *parent /TransferThis/ = 0);</span>
    <span class="s0">virtual ~QOpenGLShaderProgram();</span>
    <span class="s0">bool addShader(QOpenGLShader *shader);</span>
    <span class="s0">void removeShader(QOpenGLShader *shader);</span>
    <span class="s0">QList&lt;QOpenGLShader *&gt; shaders() const;</span>
    <span class="s0">bool addShaderFromSourceCode(QOpenGLShader::ShaderType type, const QByteArray &amp;source);</span>
    <span class="s0">bool addShaderFromSourceCode(QOpenGLShader::ShaderType type, const QString &amp;source);</span>
    <span class="s0">bool addShaderFromSourceFile(QOpenGLShader::ShaderType type, const QString &amp;fileName);</span>
    <span class="s0">void removeAllShaders();</span>
    <span class="s0">virtual bool link();</span>
    <span class="s0">bool isLinked() const;</span>
    <span class="s0">QString log() const;</span>
    <span class="s0">bool bind();</span>
    <span class="s0">void release();</span>
    <span class="s0">GLuint programId() const;</span>
    <span class="s0">void bindAttributeLocation(const QByteArray &amp;name, int location);</span>
    <span class="s0">void bindAttributeLocation(const QString &amp;name, int location);</span>
    <span class="s0">int attributeLocation(const QByteArray &amp;name) const;</span>
    <span class="s0">int attributeLocation(const QString &amp;name) const;</span>
    <span class="s0">void setAttributeValue(int location, GLfloat value);</span>
    <span class="s0">void setAttributeValue(int location, GLfloat x, GLfloat y);</span>
    <span class="s0">void setAttributeValue(int location, GLfloat x, GLfloat y, GLfloat z);</span>
    <span class="s0">void setAttributeValue(int location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</span>
    <span class="s0">void setAttributeValue(int location, const QVector2D &amp;value);</span>
    <span class="s0">void setAttributeValue(int location, const QVector3D &amp;value);</span>
    <span class="s0">void setAttributeValue(int location, const QVector4D &amp;value);</span>
    <span class="s0">void setAttributeValue(int location, const QColor &amp;value);</span>
    <span class="s0">void setAttributeValue(const char *name, GLfloat value);</span>
    <span class="s0">void setAttributeValue(const char *name, GLfloat x, GLfloat y);</span>
    <span class="s0">void setAttributeValue(const char *name, GLfloat x, GLfloat y, GLfloat z);</span>
    <span class="s0">void setAttributeValue(const char *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</span>
    <span class="s0">void setAttributeValue(const char *name, const QVector2D &amp;value);</span>
    <span class="s0">void setAttributeValue(const char *name, const QVector3D &amp;value);</span>
    <span class="s0">void setAttributeValue(const char *name, const QVector4D &amp;value);</span>
    <span class="s0">void setAttributeValue(const char *name, const QColor &amp;value);</span>
    <span class="s0">void setAttributeArray(int location, SIP_PYOBJECT values /TypeHint=&quot;PYQT_SHADER_ATTRIBUTE_ARRAY&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">const GLfloat *values;</span>
        <span class="s0">int tsize;</span>
        
        <span class="s0">values = qpyopengl_attribute_array(a1, sipSelf, SIPLong_FromLong(a0), &amp;tsize,</span>
                <span class="s0">&amp;sipError);</span>
        
        <span class="s0">if (values)</span>
            <span class="s0">sipCpp-&gt;setAttributeArray(a0, values, tsize);</span>
<span class="s0">%End</span>

    <span class="s0">void setAttributeArray(const char *name, SIP_PYOBJECT values /TypeHint=&quot;PYQT_SHADER_ATTRIBUTE_ARRAY&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">const GLfloat *values;</span>
        <span class="s0">int tsize;</span>
        
        <span class="s0">values = qpyopengl_attribute_array(a1, sipSelf, SIPBytes_FromString(a0),</span>
                <span class="s0">&amp;tsize, &amp;sipError);</span>
        
        <span class="s0">if (values)</span>
            <span class="s0">sipCpp-&gt;setAttributeArray(a0, values, tsize);</span>
<span class="s0">%End</span>

    <span class="s0">void setAttributeBuffer(int location, GLenum type, int offset, int tupleSize, int stride = 0);</span>
    <span class="s0">void setAttributeBuffer(const char *name, GLenum type, int offset, int tupleSize, int stride = 0);</span>
    <span class="s0">void enableAttributeArray(int location);</span>
    <span class="s0">void enableAttributeArray(const char *name);</span>
    <span class="s0">void disableAttributeArray(int location);</span>
    <span class="s0">void disableAttributeArray(const char *name);</span>
    <span class="s0">int uniformLocation(const QByteArray &amp;name) const;</span>
    <span class="s0">int uniformLocation(const QString &amp;name) const;</span>
    <span class="s0">void setUniformValue(int location, GLint value /Constrained/);</span>
    <span class="s0">void setUniformValue(int location, GLfloat value /Constrained/);</span>
    <span class="s0">void setUniformValue(int location, GLfloat x, GLfloat y);</span>
    <span class="s0">void setUniformValue(int location, GLfloat x, GLfloat y, GLfloat z);</span>
    <span class="s0">void setUniformValue(int location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</span>
    <span class="s0">void setUniformValue(int location, const QVector2D &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QVector3D &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QVector4D &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QColor &amp;color);</span>
    <span class="s0">void setUniformValue(int location, const QPoint &amp;point);</span>
    <span class="s0">void setUniformValue(int location, const QPointF &amp;point);</span>
    <span class="s0">void setUniformValue(int location, const QSize &amp;size);</span>
    <span class="s0">void setUniformValue(int location, const QSizeF &amp;size);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix2x2 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix2x3 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix2x4 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix3x2 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix3x3 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix3x4 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix4x2 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix4x3 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QMatrix4x4 &amp;value);</span>
    <span class="s0">void setUniformValue(int location, const QTransform &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, GLint value /Constrained/);</span>
    <span class="s0">void setUniformValue(const char *name, GLfloat value /Constrained/);</span>
    <span class="s0">void setUniformValue(const char *name, GLfloat x, GLfloat y);</span>
    <span class="s0">void setUniformValue(const char *name, GLfloat x, GLfloat y, GLfloat z);</span>
    <span class="s0">void setUniformValue(const char *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);</span>
    <span class="s0">void setUniformValue(const char *name, const QVector2D &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QVector3D &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QVector4D &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QColor &amp;color);</span>
    <span class="s0">void setUniformValue(const char *name, const QPoint &amp;point);</span>
    <span class="s0">void setUniformValue(const char *name, const QPointF &amp;point);</span>
    <span class="s0">void setUniformValue(const char *name, const QSize &amp;size);</span>
    <span class="s0">void setUniformValue(const char *name, const QSizeF &amp;size);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix2x2 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix2x3 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix2x4 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix3x2 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix3x3 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix3x4 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix4x2 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix4x3 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QMatrix4x4 &amp;value);</span>
    <span class="s0">void setUniformValue(const char *name, const QTransform &amp;value);</span>
    <span class="s0">void setUniformValueArray(int location, SIP_PYOBJECT values /TypeHint=&quot;PYQT_SHADER_UNIFORM_VALUE_ARRAY&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">const void *values;</span>
        <span class="s0">const sipTypeDef *array_type;</span>
        <span class="s0">int array_len, tsize;</span>
        
        <span class="s0">values = qpyopengl_uniform_value_array(a1, sipSelf, SIPLong_FromLong(a0),</span>
                    <span class="s0">&amp;array_type, &amp;array_len, &amp;tsize, &amp;sipError);</span>
        
        <span class="s0">if (values)</span>
        <span class="s0">{</span>
            <span class="s0">if (array_type == sipType_QVector2D)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QVector2D *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QVector3D)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QVector3D *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QVector4D)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QVector4D *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix2x2)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix2x2 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix2x3)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix2x3 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix2x4)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix2x4 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix3x2)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix3x2 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix3x3)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix3x3 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix3x4)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix3x4 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix4x2)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix4x2 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix4x3)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix4x3 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix4x4)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix4x4 *&gt;(values), array_len);</span>
            <span class="s0">else</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const GLfloat *&gt;(values), array_len, tsize);</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">void setUniformValueArray(const char *name, SIP_PYOBJECT values /TypeHint=&quot;PYQT_SHADER_UNIFORM_VALUE_ARRAY&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">const void *values;</span>
        <span class="s0">const sipTypeDef *array_type;</span>
        <span class="s0">int array_len, tsize;</span>
        
        <span class="s0">values = qpyopengl_uniform_value_array(a1, sipSelf, SIPBytes_FromString(a0),</span>
                    <span class="s0">&amp;array_type, &amp;array_len, &amp;tsize, &amp;sipError);</span>
        
        <span class="s0">if (values)</span>
        <span class="s0">{</span>
            <span class="s0">if (array_type == sipType_QVector2D)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QVector2D *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QVector3D)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QVector3D *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QVector4D)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QVector4D *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix2x2)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix2x2 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix2x3)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix2x3 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix2x4)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix2x4 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix3x2)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix3x2 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix3x3)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix3x3 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix3x4)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix3x4 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix4x2)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix4x2 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix4x3)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix4x3 *&gt;(values), array_len);</span>
            <span class="s0">else if (array_type == sipType_QMatrix4x4)</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const QMatrix4x4 *&gt;(values), array_len);</span>
            <span class="s0">else</span>
                <span class="s0">sipCpp-&gt;setUniformValueArray(a0,</span>
                        <span class="s0">reinterpret_cast&lt;const GLfloat *&gt;(values), array_len, tsize);</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">static bool hasOpenGLShaderPrograms(QOpenGLContext *context = 0);</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">int maxGeometryOutputVertices() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">void setPatchVertexCount(int count);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">int patchVertexCount() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">void setDefaultOuterTessellationLevels(const QVector&lt;float&gt; &amp;levels);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">QVector&lt;float&gt; defaultOuterTessellationLevels() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">void setDefaultInnerTessellationLevels(const QVector&lt;float&gt; &amp;levels);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_1_0 -)</span>
    <span class="s0">QVector&lt;float&gt; defaultInnerTessellationLevels() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_3_0 -)</span>
    <span class="s0">bool create();</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">bool addCacheableShaderFromSourceCode(QOpenGLShader::ShaderType type, const QByteArray &amp;source);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">bool addCacheableShaderFromSourceCode(QOpenGLShader::ShaderType type, const QString &amp;source);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_9_0 -)</span>
    <span class="s0">bool addCacheableShaderFromSourceFile(QOpenGLShader::ShaderType type, const QString &amp;fileName);</span>
<span class="s0">%End</span>
<span class="s0">};</span>

<span class="s0">%End</span>

<span class="s0">%ModuleHeaderCode</span>
<span class="s0">#include &quot;qpyopengl_api.h&quot;</span>
<span class="s0">%End</span>

<span class="s0">%InitialisationCode</span>
<span class="s0">#if defined(SIP_FEATURE_PyQt_OpenGL)</span>
<span class="s0">qpyopengl_init();</span>
<span class="s0">#endif</span>
<span class="s0">%End</span>

<span class="s0">%ExportedTypeHintCode</span>
<span class="s0"># Convenient aliases for complicated OpenGL types.</span>
<span class="s0">PYQT_OPENGL_ARRAY = typing.Union[typing.Sequence[int], typing.Sequence[float],</span>
        <span class="s0">PyQt5.sip.Buffer, None]</span>
<span class="s0">PYQT_OPENGL_BOUND_ARRAY = typing.Union[typing.Sequence[int],</span>
        <span class="s0">typing.Sequence[float], PyQt5.sip.Buffer, int, None]</span>
<span class="s0">%End</span>

<span class="s0">%TypeHintCode</span>
<span class="s0"># Convenient aliases for complicated OpenGL types.</span>
<span class="s0">PYQT_SHADER_ATTRIBUTE_ARRAY = typing.Union[typing.Sequence['QVector2D'],</span>
        <span class="s0">typing.Sequence['QVector3D'], typing.Sequence['QVector4D'],</span>
        <span class="s0">typing.Sequence[typing.Sequence[float]]]</span>
<span class="s0">PYQT_SHADER_UNIFORM_VALUE_ARRAY = typing.Union[typing.Sequence['QVector2D'],</span>
        <span class="s0">typing.Sequence['QVector3D'], typing.Sequence['QVector4D'],</span>
        <span class="s0">typing.Sequence['QMatrix2x2'], typing.Sequence['QMatrix2x3'],</span>
        <span class="s0">typing.Sequence['QMatrix2x4'], typing.Sequence['QMatrix3x2'],</span>
        <span class="s0">typing.Sequence['QMatrix3x3'], typing.Sequence['QMatrix3x4'],</span>
        <span class="s0">typing.Sequence['QMatrix4x2'], typing.Sequence['QMatrix4x3'],</span>
        <span class="s0">typing.Sequence['QMatrix4x4'], typing.Sequence[typing.Sequence[float]]]</span>
<span class="s0">%End</span>
</pre>
</body>
</html>