<html>
<head>
<title>qpainter.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qpainter.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qpainter.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtGui Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">class QPainter</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qpainter.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">%TypeCode</span>
<span class="s0">// Return an array on the heap of class instances extracted from a set of</span>
<span class="s0">// Python arguments.</span>
<span class="s0">template&lt;class TYPE&gt;</span>
<span class="s0">static TYPE *qtgui_inst_array(const TYPE *first, PyObject *t, sipTypeDef *td)</span>
<span class="s0">{</span>
    <span class="s0">TYPE *arr = new TYPE[1 + PyTuple_Size(t)];</span>

    <span class="s0">arr[0] = *first;</span>

    <span class="s0">for (Py_ssize_t i = 0; i &lt; PyTuple_Size(t); ++i)</span>
    <span class="s0">{</span>
        <span class="s0">int iserr = 0, state;</span>
        <span class="s0">TYPE *itm;</span>

        <span class="s0">itm  = reinterpret_cast&lt;TYPE *&gt;(sipForceConvertToType(PyTuple_GetItem(t, i), td, 0, SIP_NOT_NONE, &amp;state, &amp;iserr));</span>

        <span class="s0">if (iserr)</span>
        <span class="s0">{</span>
            <span class="s0">sipReleaseType(itm, td, state);</span>

            <span class="s0">PyErr_Format(PyExc_TypeError, &quot;each argument must be an instance of %s&quot;, sipPyTypeName(sipTypeAsPyTypeObject(td)));</span>

            <span class="s0">delete[] arr;</span>
            <span class="s0">return 0;</span>
        <span class="s0">}</span>

        <span class="s0">arr[1 + i] = *itm;</span>

        <span class="s0">sipReleaseType(itm, td, state);</span>
    <span class="s0">}</span>

    <span class="s0">return arr;</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">enum RenderHint</span>
    <span class="s0">{</span>
        <span class="s0">Antialiasing,</span>
        <span class="s0">TextAntialiasing,</span>
        <span class="s0">SmoothPixmapTransform,</span>
        <span class="s0">HighQualityAntialiasing,</span>
        <span class="s0">NonCosmeticDefaultPen,</span>
        <span class="s0">Qt4CompatiblePainting,</span>
<span class="s0">%If (Qt_5_13_0 -)</span>
        <span class="s0">LosslessImageRendering,</span>
<span class="s0">%End</span>
    <span class="s0">};</span>

    <span class="s0">typedef QFlags&lt;QPainter::RenderHint&gt; RenderHints;</span>
    <span class="s0">QPainter();</span>
    <span class="s0">explicit QPainter(QPaintDevice *);</span>
    <span class="s0">~QPainter();</span>
    <span class="s0">SIP_PYOBJECT __enter__();</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// Check a device was passed.</span>
        <span class="s0">if (sipCpp-&gt;isActive())</span>
        <span class="s0">{</span>
            <span class="s0">// Just return a reference to self.</span>
            <span class="s0">sipRes = sipSelf;</span>
            <span class="s0">Py_INCREF(sipRes);</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
        <span class="s0">{</span>
            <span class="s0">PyErr_SetString(PyExc_ValueError, &quot;QPainter must be created with a device&quot;);</span>
            <span class="s0">sipRes = 0;</span>
        <span class="s0">}</span>
<span class="s0">%End</span>

    <span class="s0">void __exit__(SIP_PYOBJECT type, SIP_PYOBJECT value, SIP_PYOBJECT traceback);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipCpp-&gt;end();</span>
<span class="s0">%End</span>

    <span class="s0">QPaintDevice *device() const;</span>
    <span class="s0">bool begin(QPaintDevice *);</span>
    <span class="s0">bool end();</span>
    <span class="s0">bool isActive() const;</span>

    <span class="s0">enum CompositionMode</span>
    <span class="s0">{</span>
        <span class="s0">CompositionMode_SourceOver,</span>
        <span class="s0">CompositionMode_DestinationOver,</span>
        <span class="s0">CompositionMode_Clear,</span>
        <span class="s0">CompositionMode_Source,</span>
        <span class="s0">CompositionMode_Destination,</span>
        <span class="s0">CompositionMode_SourceIn,</span>
        <span class="s0">CompositionMode_DestinationIn,</span>
        <span class="s0">CompositionMode_SourceOut,</span>
        <span class="s0">CompositionMode_DestinationOut,</span>
        <span class="s0">CompositionMode_SourceAtop,</span>
        <span class="s0">CompositionMode_DestinationAtop,</span>
        <span class="s0">CompositionMode_Xor,</span>
        <span class="s0">CompositionMode_Plus,</span>
        <span class="s0">CompositionMode_Multiply,</span>
        <span class="s0">CompositionMode_Screen,</span>
        <span class="s0">CompositionMode_Overlay,</span>
        <span class="s0">CompositionMode_Darken,</span>
        <span class="s0">CompositionMode_Lighten,</span>
        <span class="s0">CompositionMode_ColorDodge,</span>
        <span class="s0">CompositionMode_ColorBurn,</span>
        <span class="s0">CompositionMode_HardLight,</span>
        <span class="s0">CompositionMode_SoftLight,</span>
        <span class="s0">CompositionMode_Difference,</span>
        <span class="s0">CompositionMode_Exclusion,</span>
        <span class="s0">RasterOp_SourceOrDestination,</span>
        <span class="s0">RasterOp_SourceAndDestination,</span>
        <span class="s0">RasterOp_SourceXorDestination,</span>
        <span class="s0">RasterOp_NotSourceAndNotDestination,</span>
        <span class="s0">RasterOp_NotSourceOrNotDestination,</span>
        <span class="s0">RasterOp_NotSourceXorDestination,</span>
        <span class="s0">RasterOp_NotSource,</span>
        <span class="s0">RasterOp_NotSourceAndDestination,</span>
        <span class="s0">RasterOp_SourceAndNotDestination,</span>
        <span class="s0">RasterOp_NotSourceOrDestination,</span>
        <span class="s0">RasterOp_SourceOrNotDestination,</span>
        <span class="s0">RasterOp_ClearDestination,</span>
        <span class="s0">RasterOp_SetDestination,</span>
        <span class="s0">RasterOp_NotDestination,</span>
    <span class="s0">};</span>

    <span class="s0">void setCompositionMode(QPainter::CompositionMode mode);</span>
    <span class="s0">QPainter::CompositionMode compositionMode() const;</span>
    <span class="s0">const QFont &amp;font() const;</span>
    <span class="s0">void setFont(const QFont &amp;f);</span>
    <span class="s0">QFontMetrics fontMetrics() const;</span>
    <span class="s0">QFontInfo fontInfo() const;</span>
    <span class="s0">void setPen(const QColor &amp;color);</span>
    <span class="s0">void setPen(const QPen &amp;pen);</span>
    <span class="s0">void setPen(Qt::PenStyle style);</span>
    <span class="s0">const QPen &amp;pen() const;</span>
    <span class="s0">void setBrush(const QBrush &amp;brush);</span>
    <span class="s0">void setBrush(Qt::BrushStyle style);</span>
    <span class="s0">const QBrush &amp;brush() const;</span>
    <span class="s0">void setBackgroundMode(Qt::BGMode mode);</span>
    <span class="s0">Qt::BGMode backgroundMode() const;</span>
    <span class="s0">QPoint brushOrigin() const;</span>
    <span class="s0">void setBrushOrigin(const QPointF &amp;);</span>
    <span class="s0">void setBackground(const QBrush &amp;bg);</span>
    <span class="s0">const QBrush &amp;background() const;</span>
    <span class="s0">QRegion clipRegion() const;</span>
    <span class="s0">QPainterPath clipPath() const;</span>
    <span class="s0">void setClipRect(const QRectF &amp;rectangle, Qt::ClipOperation operation = Qt::ReplaceClip);</span>
    <span class="s0">void setClipRegion(const QRegion &amp;region, Qt::ClipOperation operation = Qt::ReplaceClip);</span>
    <span class="s0">void setClipPath(const QPainterPath &amp;path, Qt::ClipOperation operation = Qt::ReplaceClip);</span>
    <span class="s0">void setClipping(bool enable);</span>
    <span class="s0">bool hasClipping() const;</span>
    <span class="s0">void save();</span>
    <span class="s0">void restore();</span>
    <span class="s0">void scale(qreal sx, qreal sy);</span>
    <span class="s0">void shear(qreal sh, qreal sv);</span>
    <span class="s0">void rotate(qreal a);</span>
    <span class="s0">void translate(const QPointF &amp;offset);</span>
    <span class="s0">QRect window() const;</span>
    <span class="s0">void setWindow(const QRect &amp;window);</span>
    <span class="s0">QRect viewport() const;</span>
    <span class="s0">void setViewport(const QRect &amp;viewport);</span>
    <span class="s0">void setViewTransformEnabled(bool enable);</span>
    <span class="s0">bool viewTransformEnabled() const;</span>
    <span class="s0">void strokePath(const QPainterPath &amp;path, const QPen &amp;pen);</span>
    <span class="s0">void fillPath(const QPainterPath &amp;path, const QBrush &amp;brush);</span>
    <span class="s0">void drawPath(const QPainterPath &amp;path);</span>
    <span class="s0">void drawPoints(const QPolygonF &amp;points);</span>
    <span class="s0">void drawPoints(const QPolygon &amp;points);</span>
    <span class="s0">void drawPoints(const QPointF *points /Array/, int pointCount /ArraySize/);</span>
    <span class="s0">void drawPoints(const QPointF *point, ... /TypeHint=&quot;QPointF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPointF *points = qtgui_inst_array&lt;QPointF&gt;(a0, a1, sipType_QPointF);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawPoints(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawPoints(const QPoint *points /Array/, int pointCount /ArraySize/);</span>
    <span class="s0">void drawPoints(const QPoint *point, ... /TypeHint=&quot;QPoint&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPoint *points = qtgui_inst_array&lt;QPoint&gt;(a0, a1, sipType_QPoint);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawPoints(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawLines(const QLineF *lines /Array/, int lineCount /ArraySize/);</span>
    <span class="s0">void drawLines(const QLineF *line, ... /TypeHint=&quot;QLineF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QLineF *lines = qtgui_inst_array&lt;QLineF&gt;(a0, a1, sipType_QLineF);</span>
        
        <span class="s0">if (lines)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawLines(lines, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] lines;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawLines(const QPointF *pointPairs /Array/, int lineCount /ArraySize/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipCpp-&gt;drawLines(a0, a1 / 2);</span>
<span class="s0">%End</span>

    <span class="s0">void drawLines(const QPointF *pointPair, ... /TypeHint=&quot;QPointF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPointF *pairs = qtgui_inst_array&lt;QPointF&gt;(a0, a1, sipType_QPointF);</span>
        
        <span class="s0">if (pairs)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawLines(pairs, (1 + PyTuple_Size(a1)) / 2);</span>
            <span class="s0">delete[] pairs;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawLines(const QLine *lines /Array/, int lineCount /ArraySize/);</span>
    <span class="s0">void drawLines(const QLine *line, ... /TypeHint=&quot;QLine&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QLine *lines = qtgui_inst_array&lt;QLine&gt;(a0, a1, sipType_QLine);</span>
        
        <span class="s0">if (lines)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawLines(lines, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] lines;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawLines(const QPoint *pointPairs /Array/, int lineCount /ArraySize/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipCpp-&gt;drawLines(a0, a1 / 2);</span>
<span class="s0">%End</span>

    <span class="s0">void drawLines(const QPoint *pointPair, ... /TypeHint=&quot;QPoint&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPoint *pairs = qtgui_inst_array&lt;QPoint&gt;(a0, a1, sipType_QPoint);</span>
        
        <span class="s0">if (pairs)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawLines(pairs, (1 + PyTuple_Size(a1)) / 2);</span>
            <span class="s0">delete[] pairs;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawRects(const QRectF *rects /Array/, int rectCount /ArraySize/);</span>
    <span class="s0">void drawRects(const QRectF *rect, ... /TypeHint=&quot;QRectF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QRectF *rects = qtgui_inst_array&lt;QRectF&gt;(a0, a1, sipType_QRectF);</span>
        
        <span class="s0">if (rects)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawRects(rects, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] rects;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawRects(const QRect *rects /Array/, int rectCount /ArraySize/);</span>
    <span class="s0">void drawRects(const QRect *rect, ... /TypeHint=&quot;QRect&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QRect *rects = qtgui_inst_array&lt;QRect&gt;(a0, a1, sipType_QRect);</span>
        
        <span class="s0">if (rects)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawRects(rects, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] rects;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawEllipse(const QRectF &amp;r);</span>
    <span class="s0">void drawEllipse(const QRect &amp;r);</span>
    <span class="s0">void drawPolyline(const QPolygonF &amp;polyline);</span>
    <span class="s0">void drawPolyline(const QPolygon &amp;polyline);</span>
    <span class="s0">void drawPolyline(const QPointF *points /Array/, int pointCount /ArraySize/);</span>
    <span class="s0">void drawPolyline(const QPointF *point, ... /TypeHint=&quot;QPointF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPointF *points = qtgui_inst_array&lt;QPointF&gt;(a0, a1, sipType_QPointF);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawPolyline(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawPolyline(const QPoint *points /Array/, int pointCount /ArraySize/);</span>
    <span class="s0">void drawPolyline(const QPoint *point, ... /TypeHint=&quot;QPoint&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPoint *points = qtgui_inst_array&lt;QPoint&gt;(a0, a1, sipType_QPoint);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawPolyline(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawPolygon(const QPolygonF &amp;points, Qt::FillRule fillRule = Qt::OddEvenFill);</span>
    <span class="s0">void drawPolygon(const QPolygon &amp;points, Qt::FillRule fillRule = Qt::OddEvenFill);</span>
    <span class="s0">void drawPolygon(const QPointF *points /Array/, int pointCount /ArraySize/, Qt::FillRule fillRule = Qt::OddEvenFill);</span>
    <span class="s0">void drawPolygon(const QPointF *point, ... /TypeHint=&quot;QPointF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPointF *points = qtgui_inst_array&lt;QPointF&gt;(a0, a1, sipType_QPointF);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawPolygon(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawPolygon(const QPoint *points /Array/, int pointCount /ArraySize/, Qt::FillRule fillRule = Qt::OddEvenFill);</span>
    <span class="s0">void drawPolygon(const QPoint *point, ... /TypeHint=&quot;QPoint&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPoint *points = qtgui_inst_array&lt;QPoint&gt;(a0, a1, sipType_QPoint);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawPolygon(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawConvexPolygon(const QPolygonF &amp;poly);</span>
    <span class="s0">void drawConvexPolygon(const QPolygon &amp;poly);</span>
    <span class="s0">void drawConvexPolygon(const QPointF *points /Array/, int pointCount /ArraySize/);</span>
    <span class="s0">void drawConvexPolygon(const QPointF *point, ... /TypeHint=&quot;QPointF&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPointF *points = qtgui_inst_array&lt;QPointF&gt;(a0, a1, sipType_QPointF);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawConvexPolygon(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawConvexPolygon(const QPoint *points /Array/, int pointCount /ArraySize/);</span>
    <span class="s0">void drawConvexPolygon(const QPoint *point, ... /TypeHint=&quot;QPoint&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">QPoint *points = qtgui_inst_array&lt;QPoint&gt;(a0, a1, sipType_QPoint);</span>
        
        <span class="s0">if (points)</span>
        <span class="s0">{</span>
            <span class="s0">sipCpp-&gt;drawConvexPolygon(points, 1 + PyTuple_Size(a1));</span>
            <span class="s0">delete[] points;</span>
        <span class="s0">}</span>
        <span class="s0">else</span>
            <span class="s0">sipIsErr = 1;</span>
<span class="s0">%End</span>

    <span class="s0">void drawArc(const QRectF &amp;rect, int a, int alen);</span>
    <span class="s0">void drawPie(const QRectF &amp;rect, int a, int alen);</span>
    <span class="s0">void drawChord(const QRectF &amp;rect, int a, int alen);</span>
    <span class="s0">void drawTiledPixmap(const QRectF &amp;rectangle, const QPixmap &amp;pixmap, const QPointF &amp;pos = QPointF());</span>
    <span class="s0">void drawPicture(const QPointF &amp;p, const QPicture &amp;picture);</span>
    <span class="s0">void drawPixmap(const QRectF &amp;targetRect, const QPixmap &amp;pixmap, const QRectF &amp;sourceRect);</span>
    <span class="s0">void setLayoutDirection(Qt::LayoutDirection direction);</span>
    <span class="s0">Qt::LayoutDirection layoutDirection() const;</span>
    <span class="s0">void drawText(const QPointF &amp;p, const QString &amp;s);</span>
    <span class="s0">void drawText(const QRectF &amp;rectangle, int flags, const QString &amp;text, QRectF *boundingRect /Out/ = 0);</span>
    <span class="s0">void drawText(const QRect &amp;rectangle, int flags, const QString &amp;text, QRect *boundingRect /Out/ = 0);</span>
    <span class="s0">void drawText(const QRectF &amp;rectangle, const QString &amp;text, const QTextOption &amp;option = QTextOption());</span>
    <span class="s0">QRectF boundingRect(const QRectF &amp;rect, int flags, const QString &amp;text);</span>
    <span class="s0">QRect boundingRect(const QRect &amp;rect, int flags, const QString &amp;text);</span>
    <span class="s0">QRectF boundingRect(const QRectF &amp;rectangle, const QString &amp;text, const QTextOption &amp;option = QTextOption());</span>
    <span class="s0">void fillRect(const QRectF &amp;, const QBrush &amp;);</span>
    <span class="s0">void fillRect(const QRect &amp;, const QBrush &amp;);</span>
    <span class="s0">void eraseRect(const QRectF &amp;);</span>
    <span class="s0">void setRenderHint(QPainter::RenderHint hint, bool on = true);</span>
    <span class="s0">QPainter::RenderHints renderHints() const;</span>
    <span class="s0">void setRenderHints(QPainter::RenderHints hints, bool on = true);</span>
    <span class="s0">QPaintEngine *paintEngine() const;</span>
    <span class="s0">void drawLine(const QLineF &amp;l);</span>
    <span class="s0">void drawLine(const QLine &amp;line);</span>
    <span class="s0">void drawLine(int x1, int y1, int x2, int y2);</span>
    <span class="s0">void drawLine(const QPoint &amp;p1, const QPoint &amp;p2);</span>
    <span class="s0">void drawLine(const QPointF &amp;p1, const QPointF &amp;p2);</span>
    <span class="s0">void drawRect(const QRectF &amp;rect);</span>
    <span class="s0">void drawRect(int x, int y, int w, int h);</span>
    <span class="s0">void drawRect(const QRect &amp;r);</span>
    <span class="s0">void drawPoint(const QPointF &amp;p);</span>
    <span class="s0">void drawPoint(int x, int y);</span>
    <span class="s0">void drawPoint(const QPoint &amp;p);</span>
    <span class="s0">void drawEllipse(int x, int y, int w, int h);</span>
    <span class="s0">void drawArc(const QRect &amp;r, int a, int alen);</span>
    <span class="s0">void drawArc(int x, int y, int w, int h, int a, int alen);</span>
    <span class="s0">void drawPie(const QRect &amp;rect, int a, int alen);</span>
    <span class="s0">void drawPie(int x, int y, int w, int h, int a, int alen);</span>
    <span class="s0">void drawChord(const QRect &amp;rect, int a, int alen);</span>
    <span class="s0">void drawChord(int x, int y, int w, int h, int a, int alen);</span>
    <span class="s0">void setClipRect(int x, int y, int width, int height, Qt::ClipOperation operation = Qt::ReplaceClip);</span>
    <span class="s0">void setClipRect(const QRect &amp;rectangle, Qt::ClipOperation operation = Qt::ReplaceClip);</span>
    <span class="s0">void eraseRect(const QRect &amp;rect);</span>
    <span class="s0">void eraseRect(int x, int y, int w, int h);</span>
    <span class="s0">void fillRect(int x, int y, int w, int h, const QBrush &amp;b);</span>
    <span class="s0">void setBrushOrigin(int x, int y);</span>
    <span class="s0">void setBrushOrigin(const QPoint &amp;p);</span>
    <span class="s0">void drawTiledPixmap(const QRect &amp;rectangle, const QPixmap &amp;pixmap, const QPoint &amp;pos = QPoint());</span>
    <span class="s0">void drawTiledPixmap(int x, int y, int width, int height, const QPixmap &amp;pixmap, int sx = 0, int sy = 0);</span>
    <span class="s0">void drawPixmap(const QRect &amp;targetRect, const QPixmap &amp;pixmap, const QRect &amp;sourceRect);</span>
    <span class="s0">void drawPixmap(const QPointF &amp;p, const QPixmap &amp;pm);</span>
    <span class="s0">void drawPixmap(const QPoint &amp;p, const QPixmap &amp;pm);</span>
    <span class="s0">void drawPixmap(const QRect &amp;r, const QPixmap &amp;pm);</span>
    <span class="s0">void drawPixmap(int x, int y, const QPixmap &amp;pm);</span>
    <span class="s0">void drawPixmap(int x, int y, int w, int h, const QPixmap &amp;pm);</span>
    <span class="s0">void drawPixmap(int x, int y, int w, int h, const QPixmap &amp;pm, int sx, int sy, int sw, int sh);</span>
    <span class="s0">void drawPixmap(int x, int y, const QPixmap &amp;pm, int sx, int sy, int sw, int sh);</span>
    <span class="s0">void drawPixmap(const QPointF &amp;p, const QPixmap &amp;pm, const QRectF &amp;sr);</span>
    <span class="s0">void drawPixmap(const QPoint &amp;p, const QPixmap &amp;pm, const QRect &amp;sr);</span>
    <span class="s0">void drawImage(const QRectF &amp;r, const QImage &amp;image);</span>
    <span class="s0">void drawImage(const QRect &amp;r, const QImage &amp;image);</span>
    <span class="s0">void drawImage(const QPointF &amp;p, const QImage &amp;image);</span>
    <span class="s0">void drawImage(const QPoint &amp;p, const QImage &amp;image);</span>
    <span class="s0">void drawImage(int x, int y, const QImage &amp;image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor);</span>
    <span class="s0">void drawText(const QPoint &amp;p, const QString &amp;s);</span>
    <span class="s0">void drawText(int x, int y, int width, int height, int flags, const QString &amp;text, QRect *boundingRect /Out/ = 0);</span>
    <span class="s0">void drawText(int x, int y, const QString &amp;s);</span>
    <span class="s0">QRect boundingRect(int x, int y, int w, int h, int flags, const QString &amp;text);</span>
    <span class="s0">qreal opacity() const;</span>
    <span class="s0">void setOpacity(qreal opacity);</span>
    <span class="s0">void translate(qreal dx, qreal dy);</span>
    <span class="s0">void translate(const QPoint &amp;offset);</span>
    <span class="s0">void setViewport(int x, int y, int w, int h);</span>
    <span class="s0">void setWindow(int x, int y, int w, int h);</span>
    <span class="s0">bool worldMatrixEnabled() const;</span>
    <span class="s0">void setWorldMatrixEnabled(bool enabled);</span>
    <span class="s0">void drawPicture(int x, int y, const QPicture &amp;p);</span>
    <span class="s0">void drawPicture(const QPoint &amp;pt, const QPicture &amp;p);</span>
    <span class="s0">void setTransform(const QTransform &amp;transform, bool combine = false);</span>
    <span class="s0">const QTransform &amp;transform() const;</span>
    <span class="s0">const QTransform &amp;deviceTransform() const;</span>
    <span class="s0">void resetTransform();</span>
    <span class="s0">void setWorldTransform(const QTransform &amp;matrix, bool combine = false);</span>
    <span class="s0">const QTransform &amp;worldTransform() const;</span>
    <span class="s0">QTransform combinedTransform() const;</span>
    <span class="s0">bool testRenderHint(QPainter::RenderHint hint) const;</span>
    <span class="s0">void drawRoundedRect(const QRectF &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);</span>
    <span class="s0">void drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);</span>
    <span class="s0">void drawRoundedRect(const QRect &amp;rect, qreal xRadius, qreal yRadius, Qt::SizeMode mode = Qt::AbsoluteSize);</span>
    <span class="s0">void drawEllipse(const QPointF &amp;center, qreal rx, qreal ry);</span>
    <span class="s0">void drawEllipse(const QPoint &amp;center, int rx, int ry);</span>
    <span class="s0">void fillRect(const QRectF &amp;, const QColor &amp;color);</span>
    <span class="s0">void fillRect(const QRect &amp;, const QColor &amp;color);</span>
    <span class="s0">void fillRect(int x, int y, int w, int h, const QColor &amp;b);</span>
    <span class="s0">void fillRect(int x, int y, int w, int h, Qt::GlobalColor c);</span>
    <span class="s0">void fillRect(const QRect &amp;r, Qt::GlobalColor c);</span>
    <span class="s0">void fillRect(const QRectF &amp;r, Qt::GlobalColor c);</span>
    <span class="s0">void fillRect(int x, int y, int w, int h, Qt::BrushStyle style);</span>
    <span class="s0">void fillRect(const QRect &amp;r, Qt::BrushStyle style);</span>
    <span class="s0">void fillRect(const QRectF &amp;r, Qt::BrushStyle style);</span>
    <span class="s0">void beginNativePainting();</span>
    <span class="s0">void endNativePainting();</span>

    <span class="s0">class PixmapFragment</span>
    <span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qpainter.h&gt;</span>
<span class="s0">%End</span>

    <span class="s0">public:</span>
        <span class="s0">qreal x;</span>
        <span class="s0">qreal y;</span>
        <span class="s0">qreal sourceLeft;</span>
        <span class="s0">qreal sourceTop;</span>
        <span class="s0">qreal width;</span>
        <span class="s0">qreal height;</span>
        <span class="s0">qreal scaleX;</span>
        <span class="s0">qreal scaleY;</span>
        <span class="s0">qreal rotation;</span>
        <span class="s0">qreal opacity;</span>
        <span class="s0">static QPainter::PixmapFragment create(const QPointF &amp;pos, const QRectF &amp;sourceRect, qreal scaleX = 1, qreal scaleY = 1, qreal rotation = 0, qreal opacity = 1) /Factory/;</span>
    <span class="s0">};</span>

    <span class="s0">enum PixmapFragmentHint</span>
    <span class="s0">{</span>
        <span class="s0">OpaqueHint,</span>
    <span class="s0">};</span>

    <span class="s0">typedef QFlags&lt;QPainter::PixmapFragmentHint&gt; PixmapFragmentHints;</span>
    <span class="s0">void drawPixmapFragments(const QPainter::PixmapFragment *fragments /Array/, int fragmentCount /ArraySize/, const QPixmap &amp;pixmap, QFlags&lt;QPainter::PixmapFragmentHint&gt; hints = 0);</span>
    <span class="s0">void drawStaticText(const QPointF &amp;topLeftPosition, const QStaticText &amp;staticText);</span>
    <span class="s0">void drawStaticText(const QPoint &amp;p, const QStaticText &amp;staticText);</span>
    <span class="s0">void drawStaticText(int x, int y, const QStaticText &amp;staticText);</span>
    <span class="s0">QRectF clipBoundingRect() const;</span>
<span class="s0">%If (PyQt_RawFont)</span>
    <span class="s0">void drawGlyphRun(const QPointF &amp;position, const QGlyphRun &amp;glyphRun);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
    <span class="s0">void fillRect(int x, int y, int w, int h, QGradient::Preset preset);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
    <span class="s0">void fillRect(const QRect &amp;r, QGradient::Preset preset);</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_12_0 -)</span>
    <span class="s0">void fillRect(const QRectF &amp;r, QGradient::Preset preset);</span>
<span class="s0">%End</span>
    <span class="s0">void drawImage(const QRectF &amp;targetRect, const QImage &amp;image, const QRectF &amp;sourceRect, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor);</span>
    <span class="s0">void drawImage(const QRect &amp;targetRect, const QImage &amp;image, const QRect &amp;sourceRect, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor);</span>
    <span class="s0">void drawImage(const QPointF &amp;p, const QImage &amp;image, const QRectF &amp;sr, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor);</span>
    <span class="s0">void drawImage(const QPoint &amp;p, const QImage &amp;image, const QRect &amp;sr, Qt::ImageConversionFlags flags = Qt::ImageConversionFlag::AutoColor);</span>

<span class="s0">private:</span>
    <span class="s0">QPainter(const QPainter &amp;);</span>
<span class="s0">};</span>

<span class="s0">QFlags&lt;QPainter::RenderHint&gt; operator|(QPainter::RenderHint f1, QFlags&lt;QPainter::RenderHint&gt; f2);</span>
</pre>
</body>
</html>