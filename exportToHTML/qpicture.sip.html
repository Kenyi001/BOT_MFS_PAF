<html>
<head>
<title>qpicture.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qpicture.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qpicture.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtGui Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">class QPicture : QPaintDevice</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qpicture.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">explicit QPicture(int formatVersion = -1);</span>
    <span class="s0">QPicture(const QPicture &amp;);</span>
    <span class="s0">virtual ~QPicture();</span>
    <span class="s0">bool isNull() const;</span>
    <span class="s0">virtual int devType() const;</span>
    <span class="s0">uint size() const;</span>
    <span class="s0">const char *data() const /Encoding=&quot;None&quot;/;</span>
    <span class="s0">virtual void setData(const char *data /Array/, uint size /ArraySize/);</span>
    <span class="s0">bool play(QPainter *p);</span>
    <span class="s0">bool load(QIODevice *dev, const char *format = 0) /ReleaseGIL/;</span>
    <span class="s0">bool load(const QString &amp;fileName, const char *format = 0) /ReleaseGIL/;</span>
    <span class="s0">bool save(QIODevice *dev, const char *format = 0) /ReleaseGIL/;</span>
    <span class="s0">bool save(const QString &amp;fileName, const char *format = 0) /ReleaseGIL/;</span>
    <span class="s0">QRect boundingRect() const;</span>
    <span class="s0">void setBoundingRect(const QRect &amp;r);</span>
    <span class="s0">void detach();</span>
    <span class="s0">bool isDetached() const;</span>
    <span class="s0">virtual QPaintEngine *paintEngine() const;</span>

<span class="s0">protected:</span>
    <span class="s0">virtual int metric(QPaintDevice::PaintDeviceMetric m) const;</span>

<span class="s0">public:</span>
    <span class="s0">void swap(QPicture &amp;other /Constrained/);</span>
<span class="s0">};</span>

<span class="s0">class QPictureIO</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qpicture.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">%TypeCode</span>
<span class="s0">// This defines the mapping between picture formats and the corresponding</span>
<span class="s0">// Python i/o handler callables.</span>
<span class="s0">struct qtgui_pio {</span>
    <span class="s0">const char *format;     // The format.</span>
    <span class="s0">PyObject *read;         // The read handler.</span>
    <span class="s0">PyObject *write;        // The write handler.</span>
    <span class="s0">qtgui_pio *next;        // The next in the list.</span>
<span class="s0">};</span>


<span class="s0">// The head of the list.</span>
<span class="s0">static qtgui_pio *qtgui_pio_head = 0;</span>


<span class="s0">// Find the entry for the given picture.</span>
<span class="s0">static const qtgui_pio *qtgui_pio_find(QPictureIO *pio)</span>
<span class="s0">{</span>
    <span class="s0">for (const qtgui_pio *p = qtgui_pio_head; p; p = p-&gt;next)</span>
        <span class="s0">if (qstrcmp(pio-&gt;format(), p-&gt;format) == 0)</span>
            <span class="s0">return p;</span>

    <span class="s0">return 0;</span>
<span class="s0">}</span>


<span class="s0">// This is the C++ read handler.</span>
<span class="s0">static void qtgui_pio_read(QPictureIO *pio)</span>
<span class="s0">{</span>
    <span class="s0">const qtgui_pio *p = qtgui_pio_find(pio);</span>

    <span class="s0">if (p &amp;&amp; p-&gt;read)</span>
    <span class="s0">{</span>
        <span class="s0">Py_XDECREF(sipCallMethod(0, p-&gt;read, &quot;D&quot;, pio, sipType_QPictureIO, NULL));</span>
    <span class="s0">}</span>
<span class="s0">}</span>


<span class="s0">// This is the C++ write handler.</span>
<span class="s0">static void qtgui_pio_write(QPictureIO *pio)</span>
<span class="s0">{</span>
    <span class="s0">const qtgui_pio *p = qtgui_pio_find(pio);</span>

    <span class="s0">if (p &amp;&amp; p-&gt;write)</span>
    <span class="s0">{</span>
        <span class="s0">Py_XDECREF(sipCallMethod(0, p-&gt;write, &quot;D&quot;, pio, sipType_QPictureIO, NULL));</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QPictureIO();</span>
    <span class="s0">QPictureIO(QIODevice *ioDevice, const char *format);</span>
    <span class="s0">QPictureIO(const QString &amp;fileName, const char *format);</span>
    <span class="s0">~QPictureIO();</span>
    <span class="s0">const QPicture &amp;picture() const;</span>
    <span class="s0">int status() const;</span>
    <span class="s0">const char *format() const;</span>
    <span class="s0">QIODevice *ioDevice() const;</span>
    <span class="s0">QString fileName() const;</span>
    <span class="s0">int quality() const;</span>
    <span class="s0">QString description() const;</span>
    <span class="s0">const char *parameters() const;</span>
    <span class="s0">float gamma() const;</span>
    <span class="s0">void setPicture(const QPicture &amp;);</span>
    <span class="s0">void setStatus(int);</span>
    <span class="s0">void setFormat(const char *);</span>
    <span class="s0">void setIODevice(QIODevice *);</span>
    <span class="s0">void setFileName(const QString &amp;);</span>
    <span class="s0">void setQuality(int);</span>
    <span class="s0">void setDescription(const QString &amp;);</span>
    <span class="s0">void setParameters(const char *);</span>
    <span class="s0">void setGamma(float);</span>
    <span class="s0">bool read() /ReleaseGIL/;</span>
    <span class="s0">bool write() /ReleaseGIL/;</span>
    <span class="s0">static QByteArray pictureFormat(const QString &amp;fileName);</span>
    <span class="s0">static QByteArray pictureFormat(QIODevice *);</span>
    <span class="s0">static QList&lt;QByteArray&gt; inputFormats();</span>
    <span class="s0">static QList&lt;QByteArray&gt; outputFormats();</span>
    <span class="s0">static void defineIOHandler(const char *format, const char *header, const char *flags, SIP_PYCALLABLE read_picture /AllowNone,TypeHint=&quot;Optional[Callable[[QPictureIO], None]]&quot;/, SIP_PYCALLABLE write_picture /AllowNone,TypeHint=&quot;Optional[Callable[[QPictureIO], None]]&quot;/);</span>
<span class="s0">%MethodCode</span>
        <span class="s0">// Convert None to NULL.</span>
        <span class="s0">if (a3 == Py_None)</span>
            <span class="s0">a3 = 0;</span>
        
        <span class="s0">if (a4 == Py_None)</span>
            <span class="s0">a4 = 0;</span>
        
        <span class="s0">// See if we already know about the format.</span>
        <span class="s0">qtgui_pio *p;</span>
        
        <span class="s0">for (p = qtgui_pio_head; p; p = p-&gt;next)</span>
            <span class="s0">if (qstrcmp(a0, p-&gt;format) == 0)</span>
                <span class="s0">break;</span>
        
        <span class="s0">if (!p)</span>
        <span class="s0">{</span>
            <span class="s0">// Handle the new format.</span>
            <span class="s0">p = new qtgui_pio;</span>
            <span class="s0">p-&gt;format = qstrdup(a0);</span>
            <span class="s0">p-&gt;read = 0;</span>
            <span class="s0">p-&gt;write = 0;</span>
            <span class="s0">p-&gt;next = qtgui_pio_head;</span>
        
            <span class="s0">qtgui_pio_head = p;</span>
        <span class="s0">}</span>
        
        <span class="s0">// Replace the old callables with the new ones.</span>
        <span class="s0">Py_XDECREF(p-&gt;read);</span>
        <span class="s0">p-&gt;read = a3;</span>
        <span class="s0">Py_XINCREF(p-&gt;read);</span>
        
        <span class="s0">Py_XDECREF(p-&gt;write);</span>
        <span class="s0">p-&gt;write = a4;</span>
        <span class="s0">Py_XINCREF(p-&gt;write);</span>
        
        <span class="s0">// Install the generic handlers.</span>
        <span class="s0">QPictureIO::defineIOHandler(a0, a1, a2, qtgui_pio_read, qtgui_pio_write);</span>
<span class="s0">%End</span>

<span class="s0">private:</span>
    <span class="s0">QPictureIO(const QPictureIO &amp;);</span>
<span class="s0">};</span>

<span class="s0">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;in, const QPicture &amp;p /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, QPicture &amp;p /Constrained/) /ReleaseGIL/;</span>
</pre>
</body>
</html>