<html>
<head>
<title>qtransform.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qtransform.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qtransform.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtGui Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">%ModuleCode</span>
<span class="s0">#include &lt;qtransform.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">class QTransform</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qtransform.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">%PickleCode</span>
    <span class="s0">sipRes = Py_BuildValue((char *)&quot;ddddddddd&quot;, sipCpp-&gt;m11(), sipCpp-&gt;m12(), sipCpp-&gt;m13(), sipCpp-&gt;m21(), sipCpp-&gt;m22(), sipCpp-&gt;m23(), sipCpp-&gt;m31(), sipCpp-&gt;m32(), sipCpp-&gt;m33());</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">enum TransformationType</span>
    <span class="s0">{</span>
        <span class="s0">TxNone,</span>
        <span class="s0">TxTranslate,</span>
        <span class="s0">TxScale,</span>
        <span class="s0">TxRotate,</span>
        <span class="s0">TxShear,</span>
        <span class="s0">TxProject,</span>
    <span class="s0">};</span>

    <span class="s0">QTransform();</span>
    <span class="s0">QTransform(qreal m11, qreal m12, qreal m13, qreal m21, qreal m22, qreal m23, qreal m31, qreal m32, qreal m33 = 1.0e+0);</span>
    <span class="s0">QTransform(qreal h11, qreal h12, qreal h13, qreal h21, qreal h22, qreal h23);</span>
<span class="s0">%If (Qt_5_7_0 -)</span>
    <span class="s0">QTransform(const QTransform &amp;other);</span>
<span class="s0">%End</span>
    <span class="s0">QTransform::TransformationType type() const;</span>
    <span class="s0">void setMatrix(qreal m11, qreal m12, qreal m13, qreal m21, qreal m22, qreal m23, qreal m31, qreal m32, qreal m33);</span>
    <span class="s0">QTransform inverted(bool *invertible = 0) const;</span>
    <span class="s0">QTransform adjoint() const;</span>
    <span class="s0">QTransform transposed() const;</span>
    <span class="s0">QTransform &amp;translate(qreal dx, qreal dy);</span>
    <span class="s0">QTransform &amp;scale(qreal sx, qreal sy);</span>
    <span class="s0">QTransform &amp;shear(qreal sh, qreal sv);</span>
    <span class="s0">QTransform &amp;rotate(qreal angle, Qt::Axis axis = Qt::ZAxis);</span>
    <span class="s0">QTransform &amp;rotateRadians(qreal angle, Qt::Axis axis = Qt::ZAxis);</span>
    <span class="s0">static bool squareToQuad(const QPolygonF &amp;square, QTransform &amp;result);</span>
    <span class="s0">static bool quadToSquare(const QPolygonF &amp;quad, QTransform &amp;result);</span>
    <span class="s0">static bool quadToQuad(const QPolygonF &amp;one, const QPolygonF &amp;two, QTransform &amp;result);</span>
    <span class="s0">bool operator==(const QTransform &amp;) const;</span>
    <span class="s0">bool operator!=(const QTransform &amp;) const;</span>
    <span class="s0">QTransform &amp;operator*=(const QTransform &amp;) /__imatmul__/;</span>
    <span class="s0">QTransform operator*(const QTransform &amp;o) const /__matmul__/;</span>
    <span class="s0">void reset();</span>
    <span class="s0">void map(int x /Constrained/, int y /Constrained/, int *tx, int *ty) const;</span>
    <span class="s0">void map(qreal x, qreal y, qreal *tx, qreal *ty) const;</span>
    <span class="s0">QPoint map(const QPoint &amp;p) const;</span>
    <span class="s0">QPointF map(const QPointF &amp;p) const;</span>
    <span class="s0">QLine map(const QLine &amp;l) const;</span>
    <span class="s0">QLineF map(const QLineF &amp;l) const;</span>
    <span class="s0">QPolygonF map(const QPolygonF &amp;a) const;</span>
    <span class="s0">QPolygon map(const QPolygon &amp;a) const;</span>
    <span class="s0">QRegion map(const QRegion &amp;r) const;</span>
    <span class="s0">QPainterPath map(const QPainterPath &amp;p) const;</span>
    <span class="s0">QPolygon mapToPolygon(const QRect &amp;r) const;</span>
    <span class="s0">QRect mapRect(const QRect &amp;) const;</span>
    <span class="s0">QRectF mapRect(const QRectF &amp;) const;</span>
    <span class="s0">bool isAffine() const;</span>
    <span class="s0">bool isIdentity() const;</span>
    <span class="s0">bool isInvertible() const;</span>
    <span class="s0">bool isScaling() const;</span>
    <span class="s0">bool isRotating() const;</span>
    <span class="s0">bool isTranslating() const;</span>
    <span class="s0">qreal determinant() const;</span>
    <span class="s0">qreal m11() const;</span>
    <span class="s0">qreal m12() const;</span>
    <span class="s0">qreal m13() const;</span>
    <span class="s0">qreal m21() const;</span>
    <span class="s0">qreal m22() const;</span>
    <span class="s0">qreal m23() const;</span>
    <span class="s0">qreal m31() const;</span>
    <span class="s0">qreal m32() const;</span>
    <span class="s0">qreal m33() const;</span>
    <span class="s0">qreal dx() const;</span>
    <span class="s0">qreal dy() const;</span>
    <span class="s0">static QTransform fromTranslate(qreal dx, qreal dy);</span>
    <span class="s0">static QTransform fromScale(qreal dx, qreal dy);</span>
    <span class="s0">QTransform &amp;operator*=(qreal num);</span>
    <span class="s0">QTransform &amp;operator/=(qreal div);</span>
    <span class="s0">QTransform &amp;operator+=(qreal num);</span>
    <span class="s0">QTransform &amp;operator-=(qreal num);</span>
<span class="s0">%If (Qt_5_6_0 -)</span>
    <span class="s0">long __hash__() const;</span>
<span class="s0">%MethodCode</span>
        <span class="s0">sipRes = qHash(*sipCpp);</span>
<span class="s0">%End</span>

<span class="s0">%End</span>
<span class="s0">};</span>

<span class="s0">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;, const QTransform &amp; /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;, QTransform &amp; /Constrained/) /ReleaseGIL/;</span>
<span class="s0">QPoint operator*(const QPoint &amp;p, const QTransform &amp;m);</span>
<span class="s0">QPointF operator*(const QPointF &amp;p, const QTransform &amp;m);</span>
<span class="s0">QLineF operator*(const QLineF &amp;l, const QTransform &amp;m);</span>
<span class="s0">QLine operator*(const QLine &amp;l, const QTransform &amp;m);</span>
<span class="s0">QPolygon operator*(const QPolygon &amp;a, const QTransform &amp;m);</span>
<span class="s0">QPolygonF operator*(const QPolygonF &amp;a, const QTransform &amp;m);</span>
<span class="s0">QRegion operator*(const QRegion &amp;r, const QTransform &amp;m);</span>
<span class="s0">QPainterPath operator*(const QPainterPath &amp;p, const QTransform &amp;m);</span>
<span class="s0">QTransform operator*(const QTransform &amp;a, qreal n);</span>
<span class="s0">QTransform operator/(const QTransform &amp;a, qreal n);</span>
<span class="s0">QTransform operator+(const QTransform &amp;a, qreal n);</span>
<span class="s0">QTransform operator-(const QTransform &amp;a, qreal n);</span>
<span class="s0">bool qFuzzyCompare(const QTransform &amp;t1, const QTransform &amp;t2);</span>
</pre>
</body>
</html>