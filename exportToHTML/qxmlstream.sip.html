<html>
<head>
<title>qxmlstream.sip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
qxmlstream.sip</font>
</center></td></tr></table>
<pre><span class="s0">// qxmlstream.sip generated by MetaSIP</span>
<span class="s0">//</span>
<span class="s0">// This file is part of the QtCore Python extension module.</span>
<span class="s0">//</span>
<span class="s0">// Copyright (c) 2023 Riverbank Computing Limited &lt;info@riverbankcomputing.com&gt;</span>
<span class="s0">// </span>
<span class="s0">// This file is part of PyQt5.</span>
<span class="s0">// </span>
<span class="s0">// This file may be used under the terms of the GNU General Public License</span>
<span class="s0">// version 3.0 as published by the Free Software Foundation and appearing in</span>
<span class="s0">// the file LICENSE included in the packaging of this file.  Please review the</span>
<span class="s0">// following information to ensure the GNU General Public License version 3.0</span>
<span class="s0">// requirements will be met: http://www.gnu.org/copyleft/gpl.html.</span>
<span class="s0">// </span>
<span class="s0">// If you do not wish to use this file under the terms of the GPL version 3.0</span>
<span class="s0">// then you may purchase a commercial license.  For more information contact</span>
<span class="s0">// info@riverbankcomputing.com.</span>
<span class="s0">// </span>
<span class="s0">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<span class="s0">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>


<span class="s0">class QXmlStreamAttribute</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QXmlStreamAttribute();</span>
    <span class="s0">QXmlStreamAttribute(const QString &amp;qualifiedName, const QString &amp;value);</span>
    <span class="s0">QXmlStreamAttribute(const QString &amp;namespaceUri, const QString &amp;name, const QString &amp;value);</span>
    <span class="s0">QXmlStreamAttribute(const QXmlStreamAttribute &amp;);</span>
    <span class="s0">~QXmlStreamAttribute();</span>
    <span class="s0">QStringRef namespaceUri() const;</span>
    <span class="s0">QStringRef name() const;</span>
    <span class="s0">QStringRef qualifiedName() const;</span>
    <span class="s0">QStringRef prefix() const;</span>
    <span class="s0">QStringRef value() const;</span>
    <span class="s0">bool isDefault() const;</span>
    <span class="s0">bool operator==(const QXmlStreamAttribute &amp;other) const;</span>
    <span class="s0">bool operator!=(const QXmlStreamAttribute &amp;other) const;</span>
<span class="s0">};</span>

<span class="s0">class QXmlStreamAttributes</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QXmlStreamAttributes();</span>
    <span class="s0">QStringRef value(const QString &amp;namespaceUri, const QString &amp;name) const;</span>
    <span class="s0">QStringRef value(const QString &amp;qualifiedName) const;</span>
    <span class="s0">void append(const QString &amp;namespaceUri, const QString &amp;name, const QString &amp;value);</span>
    <span class="s0">void append(const QString &amp;qualifiedName, const QString &amp;value);</span>
    <span class="s0">void append(const QXmlStreamAttribute &amp;attribute);</span>
    <span class="s0">bool hasAttribute(const QString &amp;qualifiedName) const;</span>
    <span class="s0">bool hasAttribute(const QString &amp;namespaceUri, const QString &amp;name) const;</span>
<span class="s0">// Methods inherited from QVector&lt;QXmlStreamAttribute&gt; and Python special methods.</span>
<span class="s0">// Keep in sync with QPolygon and QPolygonF.</span>

<span class="s0">// This is picked up with &quot;using&quot; by QXmlStreamAttributes.</span>
<span class="s0">//void append(const QXmlStreamAttribute &amp;value);</span>

<span class="s0">const QXmlStreamAttribute &amp;at(int i) const;</span>
<span class="s0">void clear();</span>
<span class="s0">bool contains(const QXmlStreamAttribute &amp;value) const;</span>
<span class="s0">int count(const QXmlStreamAttribute &amp;value) const;</span>
<span class="s0">int count() const /__len__/;</span>
<span class="s0">void *data();</span>

<span class="s0">// Note the Qt return value is discarded as it would require handwritten code</span>
<span class="s0">// and seems pretty useless.</span>
<span class="s0">void fill(const QXmlStreamAttribute &amp;value, int size = -1);</span>

<span class="s0">QXmlStreamAttribute &amp;first();</span>
<span class="s0">int indexOf(const QXmlStreamAttribute &amp;value, int from = 0) const;</span>
<span class="s0">void insert(int i, const QXmlStreamAttribute &amp;value);</span>
<span class="s0">bool isEmpty() const;</span>
<span class="s0">QXmlStreamAttribute &amp;last();</span>
<span class="s0">int lastIndexOf(const QXmlStreamAttribute &amp;value, int from = -1) const;</span>

<span class="s0">// Note the Qt return type is QVector&lt;QXmlStreamAttribute&gt;.  We can't do the</span>
<span class="s0">// usual trick because there is no QXmlStreamAttributes ctor that takes a</span>
<span class="s0">// QVector&lt;QXmlStreamAttribute&gt; argument.  We could use handwritten code but we</span>
<span class="s0">// don't bother.</span>
<span class="s0">//QXmlStreamAttributes mid(int pos, int length = -1) const;</span>

<span class="s0">void prepend(const QXmlStreamAttribute &amp;value);</span>
<span class="s0">void remove(int i);</span>
<span class="s0">void remove(int i, int count);</span>
<span class="s0">void replace(int i, const QXmlStreamAttribute &amp;value);</span>
<span class="s0">int size() const;</span>

<span class="s0">// These are hidden by other implementations in QXmlStreamAttributes.</span>
<span class="s0">//QXmlStreamAttribute value(int i) const;</span>
<span class="s0">//QXmlStreamAttribute value(int i, const QXmlStreamAttribute &amp;defaultValue) const;</span>

<span class="s0">bool operator!=(const QXmlStreamAttributes &amp;other) const;</span>

<span class="s0">// Note the Qt return type is QVector&lt;QXmlStreamAttribute&gt;.  We can't do the</span>
<span class="s0">// usual trick because there is no QXmlStreamAttributes ctor that takes a</span>
<span class="s0">// QVector&lt;QXmlStreamAttribute&gt; argument.  We could use handwritten code but we</span>
<span class="s0">// don't bother.</span>
<span class="s0">//QXmlStreamAttributes operator+(const QXmlStreamAttributes &amp;other) const;</span>

<span class="s0">QXmlStreamAttributes &amp;operator+=(const QXmlStreamAttributes &amp;other);</span>
<span class="s0">QXmlStreamAttributes &amp;operator+=(const QXmlStreamAttribute &amp;value);</span>

<span class="s0">bool operator==(const QXmlStreamAttributes &amp;other) const;</span>

<span class="s0">QXmlStreamAttribute &amp;operator[](int i);</span>
<span class="s0">%MethodCode</span>
<span class="s0">Py_ssize_t idx = sipConvertFromSequenceIndex(a0, sipCpp-&gt;count());</span>

<span class="s0">if (idx &lt; 0)</span>
    <span class="s0">sipIsErr = 1;</span>
<span class="s0">else</span>
    <span class="s0">sipRes = &amp;sipCpp-&gt;operator[]((int)idx);</span>
<span class="s0">%End</span>

<span class="s0">// Some additional Python special methods.</span>

<span class="s0">void __setitem__(int i, const QXmlStreamAttribute &amp;value);</span>
<span class="s0">%MethodCode</span>
<span class="s0">int len;</span>

<span class="s0">len = sipCpp-&gt;count();</span>

<span class="s0">if ((a0 = (int)sipConvertFromSequenceIndex(a0, len)) &lt; 0)</span>
    <span class="s0">sipIsErr = 1;</span>
<span class="s0">else</span>
    <span class="s0">(*sipCpp)[a0] = *a1;</span>
<span class="s0">%End</span>

<span class="s0">void __setitem__(SIP_PYSLICE slice, const QXmlStreamAttributes &amp;list);</span>
<span class="s0">%MethodCode</span>
<span class="s0">Py_ssize_t start, stop, step, slicelength;</span>

<span class="s0">if (sipConvertFromSliceObject(a0, sipCpp-&gt;count(), &amp;start, &amp;stop, &amp;step, &amp;slicelength) &lt; 0)</span>
<span class="s0">{</span>
    <span class="s0">sipIsErr = 1;</span>
<span class="s0">}</span>
<span class="s0">else</span>
<span class="s0">{</span>
    <span class="s0">int vlen = a1-&gt;count();</span>

    <span class="s0">if (vlen != slicelength)</span>
    <span class="s0">{</span>
        <span class="s0">sipBadLengthForSlice(vlen, slicelength);</span>
        <span class="s0">sipIsErr = 1;</span>
    <span class="s0">}</span>
    <span class="s0">else</span>
    <span class="s0">{</span>
        <span class="s0">QVector&lt;QXmlStreamAttribute&gt;::const_iterator it = a1-&gt;begin();</span>

        <span class="s0">for (Py_ssize_t i = 0; i &lt; slicelength; ++i)</span>
        <span class="s0">{</span>
            <span class="s0">(*sipCpp)[start] = *it;</span>
            <span class="s0">start += step;</span>
            <span class="s0">++it;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">void __delitem__(int i);</span>
<span class="s0">%MethodCode</span>
<span class="s0">if ((a0 = (int)sipConvertFromSequenceIndex(a0, sipCpp-&gt;count())) &lt; 0)</span>
    <span class="s0">sipIsErr = 1;</span>
<span class="s0">else</span>
    <span class="s0">sipCpp-&gt;remove(a0);</span>
<span class="s0">%End</span>

<span class="s0">void __delitem__(SIP_PYSLICE slice);</span>
<span class="s0">%MethodCode</span>
<span class="s0">Py_ssize_t start, stop, step, slicelength;</span>

<span class="s0">if (sipConvertFromSliceObject(a0, sipCpp-&gt;count(), &amp;start, &amp;stop, &amp;step, &amp;slicelength) &lt; 0)</span>
<span class="s0">{</span>
    <span class="s0">sipIsErr = 1;</span>
<span class="s0">}</span>
<span class="s0">else</span>
<span class="s0">{</span>
    <span class="s0">for (Py_ssize_t i = 0; i &lt; slicelength; ++i)</span>
    <span class="s0">{</span>
        <span class="s0">sipCpp-&gt;remove(start);</span>
        <span class="s0">start += step - 1;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">QXmlStreamAttributes operator[](SIP_PYSLICE slice);</span>
<span class="s0">%MethodCode</span>
<span class="s0">Py_ssize_t start, stop, step, slicelength;</span>

<span class="s0">if (sipConvertFromSliceObject(a0, sipCpp-&gt;count(), &amp;start, &amp;stop, &amp;step, &amp;slicelength) &lt; 0)</span>
<span class="s0">{</span>
    <span class="s0">sipIsErr = 1;</span>
<span class="s0">}</span>
<span class="s0">else</span>
<span class="s0">{</span>
    <span class="s0">sipRes = new QXmlStreamAttributes();</span>

    <span class="s0">for (Py_ssize_t i = 0; i &lt; slicelength; ++i)</span>
    <span class="s0">{</span>
        <span class="s0">(*sipRes) += (*sipCpp)[start];</span>
        <span class="s0">start += step;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">%End</span>

<span class="s0">int __contains__(const QXmlStreamAttribute &amp;value);</span>
<span class="s0">%MethodCode</span>
<span class="s0">// It looks like you can't assign QBool to int.</span>
<span class="s0">sipRes = bool(sipCpp-&gt;contains(*a0));</span>
<span class="s0">%End</span>
<span class="s0">};</span>

<span class="s0">class QXmlStreamNamespaceDeclaration</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QXmlStreamNamespaceDeclaration();</span>
    <span class="s0">QXmlStreamNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &amp;);</span>
    <span class="s0">QXmlStreamNamespaceDeclaration(const QString &amp;prefix, const QString &amp;namespaceUri);</span>
    <span class="s0">~QXmlStreamNamespaceDeclaration();</span>
    <span class="s0">QStringRef prefix() const;</span>
    <span class="s0">QStringRef namespaceUri() const;</span>
    <span class="s0">bool operator==(const QXmlStreamNamespaceDeclaration &amp;other) const;</span>
    <span class="s0">bool operator!=(const QXmlStreamNamespaceDeclaration &amp;other) const;</span>
<span class="s0">};</span>

<span class="s0">typedef QVector&lt;QXmlStreamNamespaceDeclaration&gt; QXmlStreamNamespaceDeclarations;</span>

<span class="s0">class QXmlStreamNotationDeclaration</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QXmlStreamNotationDeclaration();</span>
    <span class="s0">QXmlStreamNotationDeclaration(const QXmlStreamNotationDeclaration &amp;);</span>
    <span class="s0">~QXmlStreamNotationDeclaration();</span>
    <span class="s0">QStringRef name() const;</span>
    <span class="s0">QStringRef systemId() const;</span>
    <span class="s0">QStringRef publicId() const;</span>
    <span class="s0">bool operator==(const QXmlStreamNotationDeclaration &amp;other) const;</span>
    <span class="s0">bool operator!=(const QXmlStreamNotationDeclaration &amp;other) const;</span>
<span class="s0">};</span>

<span class="s0">typedef QVector&lt;QXmlStreamNotationDeclaration&gt; QXmlStreamNotationDeclarations;</span>

<span class="s0">class QXmlStreamEntityDeclaration</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QXmlStreamEntityDeclaration();</span>
    <span class="s0">QXmlStreamEntityDeclaration(const QXmlStreamEntityDeclaration &amp;);</span>
    <span class="s0">~QXmlStreamEntityDeclaration();</span>
    <span class="s0">QStringRef name() const;</span>
    <span class="s0">QStringRef notationName() const;</span>
    <span class="s0">QStringRef systemId() const;</span>
    <span class="s0">QStringRef publicId() const;</span>
    <span class="s0">QStringRef value() const;</span>
    <span class="s0">bool operator==(const QXmlStreamEntityDeclaration &amp;other) const;</span>
    <span class="s0">bool operator!=(const QXmlStreamEntityDeclaration &amp;other) const;</span>
<span class="s0">};</span>

<span class="s0">typedef QVector&lt;QXmlStreamEntityDeclaration&gt; QXmlStreamEntityDeclarations;</span>

<span class="s0">class QXmlStreamEntityResolver</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">virtual ~QXmlStreamEntityResolver();</span>
    <span class="s0">virtual QString resolveUndeclaredEntity(const QString &amp;name);</span>
<span class="s0">};</span>

<span class="s0">class QXmlStreamReader</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">enum TokenType</span>
    <span class="s0">{</span>
        <span class="s0">NoToken,</span>
        <span class="s0">Invalid,</span>
        <span class="s0">StartDocument,</span>
        <span class="s0">EndDocument,</span>
        <span class="s0">StartElement,</span>
        <span class="s0">EndElement,</span>
        <span class="s0">Characters,</span>
        <span class="s0">Comment,</span>
        <span class="s0">DTD,</span>
        <span class="s0">EntityReference,</span>
        <span class="s0">ProcessingInstruction,</span>
    <span class="s0">};</span>

    <span class="s0">QXmlStreamReader();</span>
    <span class="s0">explicit QXmlStreamReader(QIODevice *device);</span>
    <span class="s0">explicit QXmlStreamReader(const QByteArray &amp;data);</span>
    <span class="s0">explicit QXmlStreamReader(const QString &amp;data);</span>
    <span class="s0">~QXmlStreamReader();</span>
    <span class="s0">void setDevice(QIODevice *device);</span>
    <span class="s0">QIODevice *device() const;</span>
    <span class="s0">void addData(const QByteArray &amp;data);</span>
    <span class="s0">void addData(const QString &amp;data);</span>
    <span class="s0">void clear();</span>
    <span class="s0">bool atEnd() const;</span>
    <span class="s0">QXmlStreamReader::TokenType readNext();</span>
    <span class="s0">QXmlStreamReader::TokenType tokenType() const;</span>
    <span class="s0">QString tokenString() const;</span>
    <span class="s0">void setNamespaceProcessing(bool);</span>
    <span class="s0">bool namespaceProcessing() const;</span>
    <span class="s0">bool isStartDocument() const;</span>
    <span class="s0">bool isEndDocument() const;</span>
    <span class="s0">bool isStartElement() const;</span>
    <span class="s0">bool isEndElement() const;</span>
    <span class="s0">bool isCharacters() const;</span>
    <span class="s0">bool isWhitespace() const;</span>
    <span class="s0">bool isCDATA() const;</span>
    <span class="s0">bool isComment() const;</span>
    <span class="s0">bool isDTD() const;</span>
    <span class="s0">bool isEntityReference() const;</span>
    <span class="s0">bool isProcessingInstruction() const;</span>
    <span class="s0">bool isStandaloneDocument() const;</span>
    <span class="s0">QStringRef documentVersion() const;</span>
    <span class="s0">QStringRef documentEncoding() const;</span>
    <span class="s0">qint64 lineNumber() const;</span>
    <span class="s0">qint64 columnNumber() const;</span>
    <span class="s0">qint64 characterOffset() const;</span>
    <span class="s0">QXmlStreamAttributes attributes() const;</span>

    <span class="s0">enum ReadElementTextBehaviour</span>
    <span class="s0">{</span>
        <span class="s0">ErrorOnUnexpectedElement,</span>
        <span class="s0">IncludeChildElements,</span>
        <span class="s0">SkipChildElements,</span>
    <span class="s0">};</span>

    <span class="s0">QString readElementText(QXmlStreamReader::ReadElementTextBehaviour behaviour = QXmlStreamReader::ErrorOnUnexpectedElement);</span>
    <span class="s0">QStringRef name() const;</span>
    <span class="s0">QStringRef namespaceUri() const;</span>
    <span class="s0">QStringRef qualifiedName() const;</span>
    <span class="s0">QStringRef prefix() const;</span>
    <span class="s0">QStringRef processingInstructionTarget() const;</span>
    <span class="s0">QStringRef processingInstructionData() const;</span>
    <span class="s0">QStringRef text() const;</span>
    <span class="s0">QXmlStreamNamespaceDeclarations namespaceDeclarations() const;</span>
    <span class="s0">void addExtraNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &amp;extraNamespaceDeclaraction);</span>
    <span class="s0">void addExtraNamespaceDeclarations(const QXmlStreamNamespaceDeclarations &amp;extraNamespaceDeclaractions);</span>
    <span class="s0">QXmlStreamNotationDeclarations notationDeclarations() const;</span>
    <span class="s0">QXmlStreamEntityDeclarations entityDeclarations() const;</span>
    <span class="s0">QStringRef dtdName() const;</span>
    <span class="s0">QStringRef dtdPublicId() const;</span>
    <span class="s0">QStringRef dtdSystemId() const;</span>

    <span class="s0">enum Error</span>
    <span class="s0">{</span>
        <span class="s0">NoError,</span>
        <span class="s0">UnexpectedElementError,</span>
        <span class="s0">CustomError,</span>
        <span class="s0">NotWellFormedError,</span>
        <span class="s0">PrematureEndOfDocumentError,</span>
    <span class="s0">};</span>

    <span class="s0">void raiseError(const QString &amp;message = QString());</span>
    <span class="s0">QString errorString() const;</span>
    <span class="s0">QXmlStreamReader::Error error() const;</span>
    <span class="s0">bool hasError() const;</span>
    <span class="s0">void setEntityResolver(QXmlStreamEntityResolver *resolver /KeepReference/);</span>
    <span class="s0">QXmlStreamEntityResolver *entityResolver() const;</span>
    <span class="s0">bool readNextStartElement();</span>
    <span class="s0">void skipCurrentElement();</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
    <span class="s0">int entityExpansionLimit() const;</span>
<span class="s0">%End</span>
<span class="s0">%If (Qt_5_15_0 -)</span>
    <span class="s0">void setEntityExpansionLimit(int limit);</span>
<span class="s0">%End</span>

<span class="s0">private:</span>
    <span class="s0">QXmlStreamReader(const QXmlStreamReader &amp;);</span>
<span class="s0">};</span>

<span class="s0">class QXmlStreamWriter</span>
<span class="s0">{</span>
<span class="s0">%TypeHeaderCode</span>
<span class="s0">#include &lt;qxmlstream.h&gt;</span>
<span class="s0">%End</span>

<span class="s0">public:</span>
    <span class="s0">QXmlStreamWriter();</span>
    <span class="s0">explicit QXmlStreamWriter(QIODevice *device);</span>
    <span class="s0">explicit QXmlStreamWriter(QByteArray *array);</span>
    <span class="s0">~QXmlStreamWriter();</span>
    <span class="s0">void setDevice(QIODevice *device);</span>
    <span class="s0">QIODevice *device() const;</span>
    <span class="s0">void setCodec(QTextCodec *codec /KeepReference/);</span>
    <span class="s0">void setCodec(const char *codecName);</span>
    <span class="s0">QTextCodec *codec() const;</span>
    <span class="s0">void setAutoFormatting(bool);</span>
    <span class="s0">bool autoFormatting() const;</span>
    <span class="s0">void setAutoFormattingIndent(int spaces);</span>
    <span class="s0">int autoFormattingIndent() const;</span>
    <span class="s0">void writeAttribute(const QString &amp;qualifiedName, const QString &amp;value);</span>
    <span class="s0">void writeAttribute(const QString &amp;namespaceUri, const QString &amp;name, const QString &amp;value);</span>
    <span class="s0">void writeAttribute(const QXmlStreamAttribute &amp;attribute);</span>
    <span class="s0">void writeAttributes(const QXmlStreamAttributes &amp;attributes);</span>
    <span class="s0">void writeCDATA(const QString &amp;text);</span>
    <span class="s0">void writeCharacters(const QString &amp;text);</span>
    <span class="s0">void writeComment(const QString &amp;text);</span>
    <span class="s0">void writeDTD(const QString &amp;dtd);</span>
    <span class="s0">void writeEmptyElement(const QString &amp;qualifiedName);</span>
    <span class="s0">void writeEmptyElement(const QString &amp;namespaceUri, const QString &amp;name);</span>
    <span class="s0">void writeTextElement(const QString &amp;qualifiedName, const QString &amp;text);</span>
    <span class="s0">void writeTextElement(const QString &amp;namespaceUri, const QString &amp;name, const QString &amp;text);</span>
    <span class="s0">void writeEndDocument();</span>
    <span class="s0">void writeEndElement();</span>
    <span class="s0">void writeEntityReference(const QString &amp;name);</span>
    <span class="s0">void writeNamespace(const QString &amp;namespaceUri, const QString &amp;prefix = QString());</span>
    <span class="s0">void writeDefaultNamespace(const QString &amp;namespaceUri);</span>
    <span class="s0">void writeProcessingInstruction(const QString &amp;target, const QString &amp;data = QString());</span>
    <span class="s0">void writeStartDocument();</span>
    <span class="s0">void writeStartDocument(const QString &amp;version);</span>
    <span class="s0">void writeStartDocument(const QString &amp;version, bool standalone);</span>
    <span class="s0">void writeStartElement(const QString &amp;qualifiedName);</span>
    <span class="s0">void writeStartElement(const QString &amp;namespaceUri, const QString &amp;name);</span>
    <span class="s0">void writeCurrentToken(const QXmlStreamReader &amp;reader);</span>
    <span class="s0">bool hasError() const;</span>

<span class="s0">private:</span>
    <span class="s0">QXmlStreamWriter(const QXmlStreamWriter &amp;);</span>
<span class="s0">};</span>
</pre>
</body>
</html>