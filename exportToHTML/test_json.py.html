<html>
<head>
<title>test_json.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_json.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tests</span><span class="s2">.</span><span class="s1">extension </span><span class="s0">import </span><span class="s1">base</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tests</span><span class="s2">.</span><span class="s1">extension</span><span class="s2">.</span><span class="s1">json</span><span class="s2">.</span><span class="s1">array </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">JSONArray</span><span class="s2">,</span>
    <span class="s1">JSONDtype</span><span class="s2">,</span>
    <span class="s1">make_data</span><span class="s2">,</span>
<span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">dtype</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONDtype</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data</span><span class="s2">():</span>
    <span class="s3">&quot;&quot;&quot;Length-100 PeriodArray for semantics test.&quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">make_data</span><span class="s2">()</span>

    <span class="s4"># Why the while loop? NumPy is unable to construct an ndarray from</span>
    <span class="s4"># equal-length ndarrays. Many of our operations involve coercing the</span>
    <span class="s4"># EA to an ndarray of objects. To avoid random test failures, we ensure</span>
    <span class="s4"># that our data is coercible to an ndarray. Several tests deal with only</span>
    <span class="s4"># the first two elements, so that's what we'll check.</span>

    <span class="s0">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]):</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">make_data</span><span class="s2">()</span>

    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_missing</span><span class="s2">():</span>
    <span class="s3">&quot;&quot;&quot;Length 2 array with [NA, Valid]&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">([{}, {</span><span class="s6">&quot;a&quot;</span><span class="s2">: </span><span class="s5">10</span><span class="s2">}])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_for_sorting</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">([{</span><span class="s6">&quot;b&quot;</span><span class="s2">: </span><span class="s5">1</span><span class="s2">}, {</span><span class="s6">&quot;c&quot;</span><span class="s2">: </span><span class="s5">4</span><span class="s2">}, {</span><span class="s6">&quot;a&quot;</span><span class="s2">: </span><span class="s5">2</span><span class="s2">, </span><span class="s6">&quot;c&quot;</span><span class="s2">: </span><span class="s5">3</span><span class="s2">}])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_missing_for_sorting</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">([{</span><span class="s6">&quot;b&quot;</span><span class="s2">: </span><span class="s5">1</span><span class="s2">}, {}, {</span><span class="s6">&quot;a&quot;</span><span class="s2">: </span><span class="s5">4</span><span class="s2">}])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">na_cmp</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_for_grouping</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">(</span>
        <span class="s2">[</span>
            <span class="s2">{</span><span class="s6">&quot;b&quot;</span><span class="s2">: </span><span class="s5">1</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s6">&quot;b&quot;</span><span class="s2">: </span><span class="s5">1</span><span class="s2">},</span>
            <span class="s2">{},</span>
            <span class="s2">{},</span>
            <span class="s2">{</span><span class="s6">&quot;a&quot;</span><span class="s2">: </span><span class="s5">0</span><span class="s2">, </span><span class="s6">&quot;c&quot;</span><span class="s2">: </span><span class="s5">2</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s6">&quot;a&quot;</span><span class="s2">: </span><span class="s5">0</span><span class="s2">, </span><span class="s6">&quot;c&quot;</span><span class="s2">: </span><span class="s5">2</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s6">&quot;b&quot;</span><span class="s2">: </span><span class="s5">1</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s6">&quot;c&quot;</span><span class="s2">: </span><span class="s5">2</span><span class="s2">},</span>
        <span class="s2">]</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">BaseJSON</span><span class="s2">:</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestDtype</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseDtypeTests</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestInterface</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseInterfaceTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;comparison method not implemented for JSONArray (GH-37867)&quot;</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_contains</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s4"># GH-37867</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_contains</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestConstructors</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseConstructorsTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;not implemented constructor from dtype&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_from_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s4"># construct from our dtype &amp; string dtype</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_from_dtype</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;RecursionError, GH-33900&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_series_constructor_no_data_with_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">):</span>
        <span class="s4"># RecursionError: maximum recursion depth exceeded in comparison</span>
        <span class="s1">rec_limit </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getrecursionlimit</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s4"># Limit to avoid stack overflow on Windows CI</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s5">100</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_series_constructor_no_data_with_index</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s1">rec_limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;RecursionError, GH-33900&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_series_constructor_scalar_na_with_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">):</span>
        <span class="s4"># RecursionError: maximum recursion depth exceeded in comparison</span>
        <span class="s1">rec_limit </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getrecursionlimit</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s4"># Limit to avoid stack overflow on Windows CI</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s5">100</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_series_constructor_scalar_na_with_index</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s1">rec_limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;collection as scalar, GH-33901&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_series_constructor_scalar_with_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s4"># TypeError: All values must be of type &lt;class 'collections.abc.Mapping'&gt;</span>
        <span class="s1">rec_limit </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getrecursionlimit</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s4"># Limit to avoid stack overflow on Windows CI</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s5">100</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_series_constructor_scalar_with_index</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s1">rec_limit</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestReshaping</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseReshapingTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Different definitions of NA&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_stack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        The test does .astype(object).stack(future_stack=True). If we happen to have 
        any missing values in `data`, then we'll end up with different 
        rows since we consider `{}` NA, but `.astype(object)` doesn't. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_stack</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;dict for NA&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_unstack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">):</span>
        <span class="s4"># The base test has NaN for the expected NA value.</span>
        <span class="s4"># this matches otherwise</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">test_unstack</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestGetitem</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseGetitemTests</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestIndex</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseIndexTests</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestMissing</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseMissingTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Setting a dict as a scalar&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_fillna_series</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;We treat dictionaries as a mapping in fillna, not a scalar.&quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_fillna_series</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Setting a dict as a scalar&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_fillna_frame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;We treat dictionaries as a mapping in fillna, not a scalar.&quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_fillna_frame</span><span class="s2">()</span>


<span class="s1">unhashable </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Unhashable&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestReduce</span><span class="s2">(</span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseReduceTests</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestMethods</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseMethodsTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_value_counts</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">all_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_value_counts</span><span class="s2">(</span><span class="s1">all_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_value_counts_with_normalize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_value_counts_with_normalize</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_sort_values_frame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># TODO (EA.factorize): see if _values_for_factorize allows this.</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_sort_values_frame</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;ascending&quot;</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_sort_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_sort_values</span><span class="s2">(</span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;ascending&quot;</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_sort_values_missing</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_sort_values_missing</span><span class="s2">(</span>
            <span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;combine for JSONArray not supported&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_combine_le</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_repeated</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_combine_le</span><span class="s2">(</span><span class="s1">data_repeated</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;combine for JSONArray not supported - &quot;</span>
        <span class="s6">&quot;may pass depending on random data&quot;</span><span class="s2">,</span>
        <span class="s1">strict</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">raises</span><span class="s2">=</span><span class="s1">AssertionError</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_combine_first</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_combine_first</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;broadcasting error&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_where_series</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">):</span>
        <span class="s4"># Fails with</span>
        <span class="s4"># *** ValueError: operands could not be broadcast together</span>
        <span class="s4"># with shapes (4,) (4,) (0,)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_where_series</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Can't compare dicts.&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_searchsorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_searchsorted</span><span class="s2">(</span><span class="s1">data_for_sorting</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Can't compare dicts.&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_equals</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">as_series</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_equals</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">as_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skip</span><span class="s2">(</span><span class="s6">&quot;fill-value is interpreted as a dict of values&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_fillna_copy_frame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_missing</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_fillna_copy_frame</span><span class="s2">(</span><span class="s1">data_missing</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_equals_same_data_different_object</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">using_copy_on_write</span><span class="s2">, </span><span class="s1">request</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Fails with CoW&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">add_marker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_equals_same_data_different_object</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestCasting</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseCastingTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;failing on np.array(self, dtype=str)&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_astype_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;This currently fails in NumPy on np.array(self, dtype=str) with 
 
        *** ValueError: setting an array element with a sequence 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_astype_str</span><span class="s2">()</span>


<span class="s4"># We intentionally don't run base.BaseSetitemTests because pandas'</span>
<span class="s4"># internals has trouble setting sequences of values into scalar positions.</span>


<span class="s0">class </span><span class="s1">TestGroupby</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseGroupbyTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This currently fails in Series.name.setter, since the 
        name must be hashable, but the value is a dictionary. 
        I think this is what we want, i.e. `.name` should be the original 
        values, and not the values for factorization. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_transform</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This fails in Index._do_unique_check with 
 
        &gt;   hash(val) 
        E   TypeError: unhashable type: 'UserDict' with 
 
        I suspect that once we support Index[ExtensionArray], 
        we'll be able to dispatch unique. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_apply</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_agg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This fails when we get to tm.assert_series_equal when left.index 
        contains dictionaries, which are not hashable. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_agg</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_no_sort</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This fails when we get to tm.assert_series_equal when left.index 
        contains dictionaries, which are not hashable. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_no_sort</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">TestArithmeticOps</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseArithmeticOpsTests</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">test_arith_frame_with_scalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) != </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;raises in coercing to Series&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">add_marker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_arith_frame_with_scalar</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestComparisonOps</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BaseComparisonOpsTests</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">test_compare_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">comparison_op</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s0">in </span><span class="s2">[</span><span class="s6">&quot;eq&quot;</span><span class="s2">, </span><span class="s6">&quot;ne&quot;</span><span class="s2">]:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s6">&quot;Comparison methods not implemented&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">add_marker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_compare_array</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestPrinting</span><span class="s2">(</span><span class="s1">BaseJSON</span><span class="s2">, </span><span class="s1">base</span><span class="s2">.</span><span class="s1">BasePrintingTests</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s4"># NumPy doesn't handle an array of equal-length UserDicts.</span>
    <span class="s4"># The default assert_series_equal eventually does a</span>
    <span class="s4"># Series.values, which raises. We work around it by</span>
    <span class="s4"># converting the UserDicts to dicts.</span>
    <span class="s0">if </span><span class="s1">left</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s6">&quot;json&quot;</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">left</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">right</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">left </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span>
            <span class="s1">JSONArray</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)), </span><span class="s1">index</span><span class="s2">=</span><span class="s1">left</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">left</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s2">)</span>
        <span class="s1">right </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span>
            <span class="s1">JSONArray</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)),</span>
            <span class="s1">index</span><span class="s2">=</span><span class="s1">right</span><span class="s2">.</span><span class="s1">index</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">right</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s1">tm</span><span class="s2">.</span><span class="s1">assert_series_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">custom_assert_frame_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s1">obj_type </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;obj&quot;</span><span class="s2">, </span><span class="s6">&quot;DataFrame&quot;</span><span class="s2">)</span>
    <span class="s1">tm</span><span class="s2">.</span><span class="s1">assert_index_equal</span><span class="s2">(</span>
        <span class="s1">left</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">,</span>
        <span class="s1">right</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">,</span>
        <span class="s1">exact</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;check_column_type&quot;</span><span class="s2">, </span><span class="s6">&quot;equiv&quot;</span><span class="s2">),</span>
        <span class="s1">check_names</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;check_names&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">),</span>
        <span class="s1">check_exact</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;check_exact&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">),</span>
        <span class="s1">check_categorical</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;check_categorical&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">),</span>
        <span class="s1">obj</span><span class="s2">=</span><span class="s6">f&quot;</span><span class="s0">{</span><span class="s1">obj_type</span><span class="s0">}</span><span class="s6">.columns&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">jsons </span><span class="s2">= (</span><span class="s1">left</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s2">== </span><span class="s6">&quot;json&quot;</span><span class="s2">).</span><span class="s1">index</span>

    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">jsons</span><span class="s2">:</span>
        <span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">[</span><span class="s1">col</span><span class="s2">], </span><span class="s1">right</span><span class="s2">[</span><span class="s1">col</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s1">left </span><span class="s2">= </span><span class="s1">left</span><span class="s2">.</span><span class="s1">drop</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">=</span><span class="s1">jsons</span><span class="s2">)</span>
    <span class="s1">right </span><span class="s2">= </span><span class="s1">right</span><span class="s2">.</span><span class="s1">drop</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">=</span><span class="s1">jsons</span><span class="s2">)</span>
    <span class="s1">tm</span><span class="s2">.</span><span class="s1">assert_frame_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_custom_asserts</span><span class="s2">():</span>
    <span class="s4"># This would always trigger the KeyError from trying to put</span>
    <span class="s4"># an array of equal-length UserDicts inside an ndarray.</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">JSONArray</span><span class="s2">(</span>
        <span class="s2">[</span>
            <span class="s1">collections</span><span class="s2">.</span><span class="s1">UserDict</span><span class="s2">({</span><span class="s6">&quot;a&quot;</span><span class="s2">: </span><span class="s5">1</span><span class="s2">}),</span>
            <span class="s1">collections</span><span class="s2">.</span><span class="s1">UserDict</span><span class="s2">({</span><span class="s6">&quot;b&quot;</span><span class="s2">: </span><span class="s5">2</span><span class="s2">}),</span>
            <span class="s1">collections</span><span class="s2">.</span><span class="s1">UserDict</span><span class="s2">({</span><span class="s6">&quot;c&quot;</span><span class="s2">: </span><span class="s5">3</span><span class="s2">}),</span>
        <span class="s2">]</span>
    <span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">custom_assert_frame_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">(), </span><span class="s1">a</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">())</span>

    <span class="s1">b </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">take</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]))</span>
    <span class="s1">msg </span><span class="s2">= </span><span class="s6">r&quot;Series are different&quot;</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">AssertionError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
        <span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">AssertionError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
        <span class="s1">custom_assert_frame_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">(), </span><span class="s1">b</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">())</span>
</pre>
</body>
</html>